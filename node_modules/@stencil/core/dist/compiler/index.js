'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ts = require('typescript');
var path = require('path');
var rollupPluginutils = require('rollup-pluginutils');
var rollup = require('rollup');

/**
 * SSR Attribute Names
 */
const SSR_VNODE_ID = 'data-ssrv';
const SSR_CHILD_ID = 'data-ssrc';
/**
 * Default style mode id
 */
const DEFAULT_STYLE_MODE = '$';
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
/**
 * Key Name to Key Code Map
 */
const KEY_CODE_MAP = {
    'enter': 13,
    'escape': 27,
    'space': 32,
    'tab': 9,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40
};
/**
 * File names and value
 */
const BANNER = `Built with http://stenciljs.com`;
const COLLECTION_MANIFEST_FILE_NAME = 'collection-manifest.json';
const APP_NAMESPACE_REGEX = /["']__APP__['"]/g;

/**
 * Test if a file is a typescript source file, such as .ts or .tsx.
 * However, d.ts files and spec.ts files return false.
 * @param filePath
 */
function isTsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 1) {
        if (parts[parts.length - 1] === 'ts' || parts[parts.length - 1] === 'tsx') {
            if (parts.length > 2 && (parts[parts.length - 2] === 'd' || parts[parts.length - 2] === 'spec')) {
                return false;
            }
            return true;
        }
    }
    return false;
}
function isDtsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 2) {
        return (parts[parts.length - 2] === 'd' && parts[parts.length - 1] === 'ts');
    }
    return false;
}
function isJsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 1) {
        if (parts[parts.length - 1] === 'js') {
            if (parts.length > 2 && parts[parts.length - 2] === 'spec') {
                return false;
            }
            return true;
        }
    }
    return false;
}
function hasFileExtension(filePath, extensions) {
    filePath = filePath.toLowerCase();
    return extensions.some(ext => filePath.endsWith('.' + ext));
}
/**
 * Only web development text files, like ts, tsx,
 * js, html, css, scss, etc.
 * @param filePath
 */
function isWebDevFile(filePath) {
    return (hasFileExtension(filePath, WEB_DEV_EXT) || isTsFile(filePath));
}
const WEB_DEV_EXT = ['js', 'jsx', 'html', 'htm', 'css', 'scss', 'sass', 'less', 'styl', 'pcss'];
function generatePreamble(config, content) {
    let preamble = [];
    if (config.preamble) {
        preamble = config.preamble.split('\n');
    }
    if (content) {
        content.split('\n').forEach(c => {
            preamble.push(c);
        });
    }
    preamble.push(BANNER);
    if (preamble.length > 1) {
        preamble = preamble.map(l => ` * ${l}`);
        preamble.unshift(`/*!`);
        preamble.push(` */`);
        return preamble.join('\n');
    }
    return `/*! ${BANNER} */`;
}
function buildError(diagnostics) {
    const d = {
        level: 'error',
        type: 'build',
        header: 'build error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(d);
    return d;
}
function buildWarn(diagnostics) {
    const diagnostic = {
        level: 'warn',
        type: 'build',
        header: 'build warn',
        messageText: 'build warn',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(diagnostic);
    return diagnostic;
}
function catchError(diagnostics, err) {
    const diagnostic = {
        level: 'error',
        type: 'build',
        header: 'build error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (err) {
        if (err.stack) {
            diagnostic.messageText = err.stack.toString();
        }
        else {
            if (err.message) {
                diagnostic.messageText = err.message.toString();
            }
            else {
                diagnostic.messageText = err.toString();
            }
        }
    }
    diagnostics.push(diagnostic);
    return diagnostic;
}
function hasError(diagnostics) {
    if (!diagnostics) {
        return false;
    }
    return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
}
function pathJoin(config, ...paths) {
    return normalizePath(config.sys.path.join.apply(config.sys.path, paths));
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, '/');
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === '/') {
        const colonIndex = str.indexOf(':');
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

function cleanDiagnostics(diagnostics) {
    const cleaned = [];
    const maxErrors = Math.min(diagnostics.length, MAX_ERRORS);
    const dups = {};
    for (var i = 0; i < maxErrors; i++) {
        const d = diagnostics[i];
        const key = d.absFilePath + d.code + d.messageText + d.type;
        if (dups[key]) {
            continue;
        }
        dups[key] = true;
        if (d.messageText) {
            if (typeof d.messageText.message === 'string') {
                d.messageText = d.messageText.message;
            }
            else if (typeof d.messageText === 'string' && d.messageText.indexOf('Error: ') === 0) {
                d.messageText = d.messageText.substr(7);
            }
        }
        cleaned.push(d);
    }
    return cleaned;
}
function formatFileName(rootDir, fileName) {
    if (!rootDir || !fileName)
        return '';
    fileName = fileName.replace(rootDir, '');
    if (/\/|\\/.test(fileName.charAt(0))) {
        fileName = fileName.substr(1);
    }
    if (fileName.length > 80) {
        fileName = '...' + fileName.substr(fileName.length - 80);
    }
    return fileName;
}
function formatHeader(type, fileName, rootDir, startLineNumber = null, endLineNumber = null) {
    let header = `${type}: ${formatFileName(rootDir, fileName)}`;
    if (startLineNumber !== null && startLineNumber > 0) {
        if (endLineNumber !== null && endLineNumber > startLineNumber) {
            header += `, lines: ${startLineNumber} - ${endLineNumber}`;
        }
        else {
            header += `, line: ${startLineNumber}`;
        }
    }
    return header;
}
function splitLineBreaks(sourceText) {
    if (!sourceText)
        return [];
    sourceText = sourceText.replace(/\\r/g, '\n');
    return sourceText.split('\n');
}
const MAX_ERRORS = 15;

const AUTO_GENERATE_COMMENT = `<!-- Auto Generated Below -->`;
const NOTE = `*Built with [StencilJS](https://stenciljs.com/)*`;

function getMemberDocumentation(jsDoc) {
    if (jsDoc && jsDoc.documentation) {
        return jsDoc.documentation.trim();
    }
    return '';
}

class MarkdownAttrs {
    constructor() {
        this.rows = [];
    }
    addRow(memberMeta) {
        this.rows.push(new Row(memberMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Attributes`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberMeta.attribName < b.memberMeta.attribName)
                return -1;
            if (a.memberMeta.attribName > b.memberMeta.attribName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row {
    constructor(memberMeta) {
        this.memberMeta = memberMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberMeta.attribName}`);
        content.push(``);
        content.push(getPropType(this.memberMeta.propType));
        content.push(``);
        const doc = getMemberDocumentation(this.memberMeta.jsdoc);
        if (doc) {
            content.push(doc);
            content.push(``);
        }
        content.push(``);
        return content;
    }
}
function getPropType(propType) {
    switch (propType) {
        case 1 /* Any */:
            return 'any';
        case 3 /* Boolean */:
            return 'boolean';
        case 4 /* Number */:
            return 'number';
        case 2 /* String */:
            return 'string';
    }
    return '';
}

class MarkdownEvents {
    constructor() {
        this.rows = [];
    }
    addRow(eventMeta) {
        this.rows.push(new Row$1(eventMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Events`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.eventMeta.eventName < b.eventMeta.eventName)
                return -1;
            if (a.eventMeta.eventName > b.eventMeta.eventName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$1 {
    constructor(eventMeta) {
        this.eventMeta = eventMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.eventMeta.eventName}`);
        content.push(``);
        const doc = getMemberDocumentation(this.eventMeta.jsdoc);
        if (doc) {
            content.push(doc);
            content.push(``);
        }
        content.push(``);
        return content;
    }
}

class MarkdownMethods {
    constructor() {
        this.rows = [];
    }
    addRow(memberName, memberMeta) {
        this.rows.push(new Row$2(memberName, memberMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Methods`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberName < b.memberName)
                return -1;
            if (a.memberName > b.memberName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$2 {
    constructor(memberName, memberMeta) {
        this.memberName = memberName;
        this.memberMeta = memberMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberName}()`);
        content.push(``);
        const doc = getMemberDocumentation(this.memberMeta.jsdoc);
        if (doc) {
            content.push(doc);
            content.push(``);
        }
        content.push(``);
        return content;
    }
}

class MarkdownProps {
    constructor() {
        this.rows = [];
    }
    addRow(memberName, memberMeta) {
        this.rows.push(new Row$3(memberName, memberMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Properties`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberName < b.memberName)
                return -1;
            if (a.memberName > b.memberName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$3 {
    constructor(memberName, memberMeta) {
        this.memberName = memberName;
        this.memberMeta = memberMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberName}`);
        content.push(``);
        content.push(getPropType$1(this.memberMeta.propType));
        content.push(``);
        const doc = getMemberDocumentation(this.memberMeta.jsdoc);
        if (doc) {
            content.push(doc);
            content.push(``);
        }
        content.push(``);
        return content;
    }
}
function getPropType$1(propType) {
    switch (propType) {
        case 1 /* Any */:
            return 'any';
        case 3 /* Boolean */:
            return 'boolean';
        case 4 /* Number */:
            return 'number';
        case 2 /* String */:
            return 'string';
    }
    return '';
}

function addAutoGenerate(cmpMeta, content) {
    content.push(AUTO_GENERATE_COMMENT);
    content.push(``);
    content.push(``);
    content.push(...generateMemberMarkdown(cmpMeta));
    content.push(``);
    content.push(`----------------------------------------------`);
    content.push(``);
    content.push(NOTE);
    content.push(``);
}
function generateMemberMarkdown(cmpMeta) {
    const attrs = new MarkdownAttrs();
    const events = new MarkdownEvents();
    const methods = new MarkdownMethods();
    const props = new MarkdownProps();
    cmpMeta.membersMeta && Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const memberMeta = cmpMeta.membersMeta[memberName];
        if (memberMeta.memberType === 1 /* Prop */ || memberMeta.memberType === 2 /* PropMutable */) {
            props.addRow(memberName, memberMeta);
            if (memberMeta.attribName) {
                attrs.addRow(memberMeta);
            }
        }
        else if (memberMeta.memberType === 6 /* Method */) {
            methods.addRow(memberName, memberMeta);
        }
    });
    cmpMeta.eventsMeta && cmpMeta.eventsMeta.forEach(ev => {
        events.addRow(ev);
    });
    return [
        ...props.toMarkdown(),
        ...attrs.toMarkdown(),
        ...events.toMarkdown(),
        ...methods.toMarkdown()
    ];
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateJsDocComponent(config, compilerCtx, jsonDocs, cmpMeta, dirPath, readmeContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const jsonCmp = {
            tag: cmpMeta.tagNameMeta,
            readme: readmeContent || '',
            usage: yield generateJsDocsUsages(config, compilerCtx, dirPath),
            props: [],
            methods: [],
            events: []
        };
        generateJsDocMembers(cmpMeta, jsonCmp);
        generateJsDocEvents(cmpMeta, jsonCmp);
        jsonDocs.components.push(jsonCmp);
    });
}
function generateJsDocsUsages(config, compilerCtx, dirPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const rtn = {};
        const usagesDir = config.sys.path.join(dirPath, 'usage');
        try {
            const usageFilePaths = yield compilerCtx.fs.readdir(usagesDir);
            const usages = {};
            yield Promise.all(usageFilePaths.map((f) => __awaiter(this, void 0, void 0, function* () {
                if (!f.isFile) {
                    return;
                }
                const fileName = config.sys.path.basename(f.relPath);
                if (!fileName.endsWith('.md')) {
                    return;
                }
                const parts = fileName.split('.');
                parts.pop();
                const key = parts.join('.');
                usages[key] = yield compilerCtx.fs.readFile(f.absPath);
            })));
            Object.keys(usages).sort().forEach(key => {
                rtn[key] = usages[key];
            });
        }
        catch (e) { }
        return rtn;
    });
}
function generateJsDocMembers(cmpMeta, jsonCmp) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort((a, b) => {
        if (a.toLowerCase() < b.toLowerCase())
            return -1;
        if (a.toLowerCase() > b.toLowerCase())
            return 1;
        return 0;
    }).forEach(memberName => {
        const memberMeta = cmpMeta.membersMeta[memberName];
        if (memberMeta.memberType === 1 /* Prop */ || memberMeta.memberType === 2 /* PropMutable */) {
            const propData = {
                name: memberName
            };
            if (memberMeta.propType === 3 /* Boolean */) {
                propData.type = 'boolean';
            }
            else if (memberMeta.propType === 4 /* Number */) {
                propData.type = 'number';
            }
            else if (memberMeta.propType === 2 /* String */) {
                propData.type = 'string';
            }
            else if (memberMeta.propType === 1 /* Any */) {
                propData.type = 'any';
            }
            if (memberMeta.memberType === 2 /* PropMutable */) {
                propData.mutable = true;
            }
            if (typeof memberMeta.attribName === 'string') {
                propData.attr = memberMeta.attribName;
            }
            propData.docs = getMemberDocumentation(memberMeta.jsdoc);
            jsonCmp.props.push(propData);
        }
        else if (memberMeta.memberType === 6 /* Method */) {
            jsonCmp.methods.push({
                name: memberName,
                docs: getMemberDocumentation(memberMeta.jsdoc)
            });
        }
    });
}
function generateJsDocEvents(cmpMeta, jsonCmp) {
    if (!Array.isArray(cmpMeta.eventsMeta)) {
        return;
    }
    cmpMeta.eventsMeta.sort((a, b) => {
        if (a.eventName.toLowerCase() < b.eventName.toLowerCase())
            return -1;
        if (a.eventName.toLowerCase() > b.eventName.toLowerCase())
            return 1;
        return 0;
    }).forEach(eventMeta => {
        const eventData = {
            event: eventMeta.eventName,
            bubbles: !!eventMeta.eventBubbles,
            cancelable: !!eventMeta.eventCancelable,
            composed: !!eventMeta.eventComposed,
            docs: getMemberDocumentation(eventMeta.jsdoc)
        };
        jsonCmp.events.push(eventData);
    });
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateReadmes(config, compilerCtx, outputTargets) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const cmpDirectories = [];
        const promises = [];
        const warnings = [];
        const jsonDocs = { components: [] };
        const moduleFiles = Object.keys(compilerCtx.moduleFiles).sort();
        moduleFiles.forEach(filePath => {
            const moduleFile = compilerCtx.moduleFiles[filePath];
            if (!moduleFile.cmpMeta || moduleFile.isCollectionDependency) {
                return;
            }
            const dirPath = config.sys.path.dirname(filePath);
            if (cmpDirectories.includes(dirPath)) {
                if (!warnings.includes(dirPath)) {
                    config.logger.warn(`multiple components found in: ${dirPath}`);
                    warnings.push(dirPath);
                }
            }
            else {
                cmpDirectories.push(dirPath);
                promises.push(genereateReadme(config, compilerCtx, outputTargets, jsonDocs, moduleFile, dirPath));
            }
        });
        yield Promise.all(promises);
        yield Promise.all(outputTargets.map((outputTarget) => __awaiter$1(this, void 0, void 0, function* () {
            if (outputTarget.jsonFile) {
                jsonDocs.components = jsonDocs.components.sort((a, b) => {
                    if (a.tag < b.tag)
                        return -1;
                    if (a.tag > b.tag)
                        return 1;
                    return 0;
                });
                const jsonContent = JSON.stringify(jsonDocs, null, 2);
                yield compilerCtx.fs.writeFile(outputTarget.jsonFile, jsonContent);
            }
        })));
    });
}
function genereateReadme(config, compilerCtx, readmeOutputs, jsonDocs, moduleFile, dirPath) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const readMePath = config.sys.path.join(dirPath, 'readme.md');
        let existingContent = null;
        try {
            existingContent = yield compilerCtx.fs.readFile(readMePath);
        }
        catch (e) { }
        if (typeof existingContent === 'string' && existingContent.trim() !== '') {
            // update
            return updateReadme(config, compilerCtx, readmeOutputs, jsonDocs, moduleFile, dirPath, readMePath, existingContent);
        }
        else {
            // create
            return createReadme(config, compilerCtx, readmeOutputs, jsonDocs, moduleFile, dirPath, readMePath);
        }
    });
}
function createReadme(config, compilerCtx, readmeOutputs, jsonDocs, moduleFile, dirPath, readMePath) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const content = [];
        content.push(`# ${moduleFile.cmpMeta.tagNameMeta}`);
        content.push(``);
        content.push(``);
        content.push(``);
        addAutoGenerate(moduleFile.cmpMeta, content);
        const readmeContent = content.join('\n');
        const writeFiles = {};
        yield Promise.all(readmeOutputs.map((readmeOutput) => __awaiter$1(this, void 0, void 0, function* () {
            if (readmeOutput.readmeDir) {
                const relPath = config.sys.path.relative(config.srcDir, readMePath);
                const absPath = config.sys.path.join(readmeOutput.readmeDir, relPath);
                writeFiles[absPath] = readmeContent;
            }
            if (readmeOutput.jsonFile) {
                yield generateJsDocComponent(config, compilerCtx, jsonDocs, moduleFile.cmpMeta, dirPath, '');
            }
        })));
        writeFiles[readMePath] = readmeContent;
        config.logger.info(`created readme docs: ${moduleFile.cmpMeta.tagNameMeta}`);
        yield compilerCtx.fs.writeFiles(writeFiles);
    });
}
function updateReadme(config, compilerCtx, readmeOutputs, jsonDocs, moduleFile, dirPath, readMePath, existingContent) {
    return __awaiter$1(this, void 0, void 0, function* () {
        if (typeof existingContent !== 'string' || existingContent.trim() === '') {
            throw new Error('missing existing content');
        }
        const content = [];
        const existingLines = existingContent.split(/(\r?\n)/);
        let foundAutoGenerate = false;
        for (var i = 0; i < existingLines.length; i++) {
            if (existingLines[i].trim() === AUTO_GENERATE_COMMENT) {
                foundAutoGenerate = true;
                break;
            }
            if (existingLines[i] !== '\n' && existingLines[i] !== '\r') {
                content.push(existingLines[i]);
            }
        }
        if (!foundAutoGenerate) {
            config.logger.warn(`Unable to find ${AUTO_GENERATE_COMMENT} comment for docs auto-generation updates: ${readMePath}`);
            return true;
        }
        const userContent = content.join('\n');
        addAutoGenerate(moduleFile.cmpMeta, content);
        const updatedContent = content.join('\n');
        const writeFiles = {};
        if (updatedContent.trim() !== existingContent.trim()) {
            writeFiles[readMePath] = updatedContent;
            config.logger.info(`updated readme docs: ${moduleFile.cmpMeta.tagNameMeta}`);
        }
        yield Promise.all(readmeOutputs.map((readmeOutput) => __awaiter$1(this, void 0, void 0, function* () {
            if (readmeOutput.readmeDir) {
                const relPath = config.sys.path.relative(config.srcDir, readMePath);
                const absPath = config.sys.path.join(readmeOutput.readmeDir, relPath);
                writeFiles[absPath] = updatedContent;
            }
            if (readmeOutput.jsonFile) {
                yield generateJsDocComponent(config, compilerCtx, jsonDocs, moduleFile.cmpMeta, dirPath, userContent);
            }
        })));
        yield compilerCtx.fs.writeFiles(writeFiles);
        return true;
    });
}

function generateBuildResults(config, compilerCtx, buildCtx) {
    // create the build results that get returned
    const buildResults = {
        buildId: buildCtx.buildId,
        diagnostics: cleanDiagnostics(buildCtx.diagnostics),
        hasError: hasError(buildCtx.diagnostics),
        aborted: buildCtx.aborted,
        duration: Date.now() - buildCtx.startTime,
        isRebuild: compilerCtx.isRebuild,
        transpileBuildCount: buildCtx.transpileBuildCount,
        bundleBuildCount: buildCtx.bundleBuildCount,
        hasChangedJsText: buildCtx.hasChangedJsText,
        filesWritten: buildCtx.filesWritten.sort(),
        filesChanged: buildCtx.filesChanged.slice().sort(),
        filesUpdated: buildCtx.filesUpdated.slice().sort(),
        filesAdded: buildCtx.filesAdded.slice().sort(),
        filesDeleted: buildCtx.filesDeleted.slice().sort(),
        dirsAdded: buildCtx.dirsAdded.slice().sort(),
        dirsDeleted: buildCtx.dirsDeleted.slice().sort(),
        hasSlot: !!buildCtx.hasSlot,
        hasSvg: !!buildCtx.hasSvg,
        components: [],
        entries: buildCtx.entryModules.map(en => {
            en.modeNames = en.modeNames || [];
            en.entryBundles = en.entryBundles || [];
            en.moduleFiles = en.moduleFiles || [];
            const entryCmps = [];
            buildCtx.entryPoints.forEach(ep => {
                entryCmps.push(...ep);
            });
            const buildEntry = {
                entryId: en.entryKey,
                components: en.moduleFiles.map(m => {
                    const entryCmp = entryCmps.find(ec => {
                        return ec.tag === m.cmpMeta.tagNameMeta;
                    });
                    const dependencyOf = ((entryCmp && entryCmp.dependencyOf) || []).slice().sort();
                    const buildCmp = {
                        tag: m.cmpMeta.tagNameMeta,
                        dependencies: m.cmpMeta.dependencies.slice(),
                        dependencyOf: dependencyOf
                    };
                    return buildCmp;
                }),
                bundles: en.entryBundles.map(entryBundle => {
                    const buildBundle = {
                        fileName: entryBundle.fileName,
                        size: entryBundle.text.length,
                        outputs: entryBundle.outputs.map(filePath => {
                            return normalizePath(config.sys.path.relative(config.rootDir, filePath));
                        }).sort()
                    };
                    if (typeof entryBundle.sourceTarget === 'string') {
                        buildBundle.target = entryBundle.sourceTarget;
                    }
                    if (entryBundle.modeName !== DEFAULT_STYLE_MODE) {
                        buildBundle.mode = entryBundle.modeName;
                    }
                    if (entryBundle.isScopedStyles) {
                        buildBundle.scopedStyles = entryBundle.isScopedStyles;
                    }
                    return buildBundle;
                }),
                inputs: en.moduleFiles.map(m => {
                    return normalizePath(config.sys.path.relative(config.rootDir, m.jsFilePath));
                }).sort(),
                encapsulations: []
            };
            const modes = en.modeNames.slice();
            if (modes.length > 1 || (modes.length === 1 && modes[0] !== DEFAULT_STYLE_MODE)) {
                buildEntry.modes = modes.sort();
            }
            en.moduleFiles.forEach(m => {
                const encap = m.cmpMeta.encapsulation === 2 /* ScopedCss */ ? 'scoped' : m.cmpMeta.encapsulation === 1 /* ShadowDom */ ? 'shadow' : 'none';
                if (!buildEntry.encapsulations.includes(encap)) {
                    buildEntry.encapsulations.push(encap);
                }
            });
            buildEntry.encapsulations.sort();
            return buildEntry;
        })
    };
    buildResults.entries.forEach(en => {
        buildResults.components.push(...en.components);
    });
    return buildResults;
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateBuildStats(config, compilerCtx, buildCtx, buildResults) {
    return __awaiter$2(this, void 0, void 0, function* () {
        const statsTargets = config.outputTargets.filter(o => o.type === 'stats');
        yield Promise.all(statsTargets.map(outputTarget => {
            return generateStatsOutputTarget(config, compilerCtx, buildCtx, buildResults, outputTarget);
        }));
    });
}
function generateStatsOutputTarget(config, compilerCtx, buildCtx, buildResults, outputTarget) {
    return __awaiter$2(this, void 0, void 0, function* () {
        if (buildCtx.aborted) {
            return;
        }
        try {
            let jsonData;
            if (buildResults.hasError) {
                jsonData = {
                    diagnostics: buildResults.diagnostics
                };
            }
            else {
                const stats = {
                    compiler: {
                        name: config.sys.compiler.name,
                        version: config.sys.compiler.version
                    },
                    app: {
                        namespace: config.namespace,
                        fsNamespace: config.fsNamespace,
                        components: buildResults.components.length,
                        entries: buildResults.entries.length,
                        bundles: buildResults.entries.reduce((total, en) => {
                            total += en.bundles.length;
                            return total;
                        }, 0)
                    },
                    options: {
                        minifyJs: config.minifyJs,
                        minifyCss: config.minifyCss,
                        hashFileNames: config.hashFileNames,
                        hashedFileNameLength: config.hashedFileNameLength,
                        buildEs5: config.buildEs5
                    },
                    components: buildResults.components,
                    entries: buildResults.entries,
                    sourceGraph: {},
                    collections: buildCtx.collections.map(c => {
                        return {
                            name: c.collectionName,
                            source: normalizePath(config.sys.path.relative(config.rootDir, c.moduleDir)),
                            tags: c.moduleFiles.map(m => m.cmpMeta.tagNameMeta).sort()
                        };
                    }).sort((a, b) => {
                        if (a.name < b.name)
                            return -1;
                        if (a.name > b.name)
                            return 1;
                        return 0;
                    })
                };
                buildCtx.moduleGraphs
                    .sort((a, b) => {
                    if (a.filePath < b.filePath)
                        return -1;
                    if (a.filePath > b.filePath)
                        return 1;
                    return 0;
                }).forEach(mg => {
                    const key = normalizePath(config.sys.path.relative(config.rootDir, mg.filePath));
                    stats.sourceGraph[key] = mg.importPaths.map(importPath => {
                        return normalizePath(config.sys.path.relative(config.rootDir, importPath));
                    }).sort();
                });
                jsonData = stats;
            }
            yield compilerCtx.fs.writeFile(outputTarget.file, JSON.stringify(jsonData, null, 2));
            yield compilerCtx.fs.commit();
        }
        catch (e) { }
    });
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function copyComponentStyles(config, compilerCtx, buildCtx) {
    return __awaiter$3(this, void 0, void 0, function* () {
        config.logger.debug(`copy styles`);
        try {
            const absSrcStylePaths = [];
            buildCtx.entryModules.forEach(entryModule => {
                const cmps = entryModule.moduleFiles.filter(m => m.cmpMeta.stylesMeta);
                cmps.forEach(c => {
                    if (c.isCollectionDependency) {
                        return;
                    }
                    Object.keys(c.cmpMeta.stylesMeta).forEach(modeName => {
                        const styleMeta = c.cmpMeta.stylesMeta[modeName];
                        if (styleMeta.externalStyles) {
                            styleMeta.externalStyles.forEach(externalStyle => {
                                absSrcStylePaths.push(externalStyle.absolutePath);
                            });
                        }
                    });
                });
            });
            const promises = [];
            const outputTargets = config.outputTargets.filter(o => o.collectionDir);
            absSrcStylePaths.map((absSrcStylePath) => __awaiter$3(this, void 0, void 0, function* () {
                outputTargets.forEach(outputTarget => {
                    const relPath = config.sys.path.relative(config.srcDir, absSrcStylePath);
                    const dest = config.sys.path.join(outputTarget.collectionDir, relPath);
                    promises.push(compilerCtx.fs.copy(absSrcStylePath, dest));
                });
            }));
            yield Promise.all(promises);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}

function getAppBuildDir(config, outputTarget) {
    return pathJoin(config, outputTarget.buildDir, config.fsNamespace);
}
function getRegistryFileName(config) {
    return `${config.fsNamespace}.registry.json`;
}
function getRegistryJson(config, outputTarget) {
    return pathJoin(config, getAppBuildDir(config, outputTarget), getRegistryFileName(config));
}
function getLoaderFileName(config) {
    return `${config.fsNamespace}.js`;
}
function getLoaderPath(config, outputTarget) {
    return pathJoin(config, outputTarget.buildDir, getLoaderFileName(config));
}
function getGlobalFileName(config) {
    return `${config.fsNamespace}.global.js`;
}
function getGlobalJsBuildPath(config, outputTarget) {
    return pathJoin(config, getAppBuildDir(config, outputTarget), getGlobalFileName(config));
}
function getCoreFilename(config, coreId, jsContent) {
    if (config.hashFileNames) {
        // prod mode renames the core file with its hashed content
        const contentHash = config.sys.generateContentHash(jsContent, config.hashedFileNameLength);
        return `${config.fsNamespace}.${contentHash}.js`;
    }
    // dev file name
    return `${config.fsNamespace}.${coreId}.js`;
}
function getDistCjsIndexPath(config, outputTarget) {
    return pathJoin(config, outputTarget.buildDir, 'index.js');
}
function getDistEsmBuildDir(config, outputTarget) {
    return pathJoin(config, outputTarget.buildDir, 'esm');
}
function getDistEsmIndexPath(config, outputTarget) {
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), 'index.js');
}
function getCoreEsmFileName(config) {
    return `${config.fsNamespace}.core.js`;
}
function getCoreEsmBuildPath(config, outputTarget, sourceTarget) {
    if (sourceTarget === 'es5') {
        return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `es5`, getCoreEsmFileName(config));
    }
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), getCoreEsmFileName(config));
}
function getDefineCustomElementsPath(config, outputTarget, sourceTarget) {
    if (sourceTarget === 'es5') {
        return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `es5`, `${config.fsNamespace}.define.js`);
    }
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `${config.fsNamespace}.define.js`);
}
function getGlobalEsmFileName(config) {
    return `${config.fsNamespace}.global.js`;
}
function getGlobalEsmBuildPath(config, outputTarget, sourceTarget) {
    if (sourceTarget === 'es5') {
        return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `es5`, getGlobalEsmFileName(config));
    }
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), getGlobalEsmFileName(config));
}
function getComponentsEsmFileName(config) {
    return `${config.fsNamespace}.components.js`;
}
function getComponentsEsmBuildPath(config, outputTarget, sourceTarget) {
    if (sourceTarget === 'es5') {
        return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `es5`, getComponentsEsmFileName(config));
    }
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), getComponentsEsmFileName(config));
}
function getHyperScriptFnEsmFileName(config) {
    return `${config.fsNamespace}.core.js`;
}
function getPolyfillsEsmBuildPath(config, outputTarget) {
    return pathJoin(config, getDistEsmBuildDir(config, outputTarget), `es5`, `polyfills`);
}
function getGlobalStyleFilename(config) {
    return `${config.fsNamespace}.css`;
}
function getBrowserFilename(bundleId, isScopedStyles, sourceTarget) {
    return `${bundleId}${isScopedStyles ? '.sc' : ''}${sourceTarget === 'es5' ? '.es5' : ''}.js`;
}
function getEsmFilename(bundleId, isScopedStyles) {
    return `${bundleId}${isScopedStyles ? '.sc' : ''}.js`;
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateCommonJsIndex(config, compilerCtx, outputTarget) {
    return __awaiter$4(this, void 0, void 0, function* () {
        const cjs = [
            `// ${config.namespace}: CommonJS Main`
        ];
        const distIndexCjsPath = getDistCjsIndexPath(config, outputTarget);
        yield compilerCtx.fs.writeFile(distIndexCjsPath, cjs.join('\n'));
    });
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getAppBrowserCorePolyfills(config) {
    return __awaiter$5(this, void 0, void 0, function* () {
        // first load up all of the polyfill content
        const readFilePromises = POLYFILLS.map(polyfillFile => {
            const staticName = config.sys.path.join('polyfills', 'es5', polyfillFile);
            return config.sys.getClientCoreFile({ staticName: staticName });
        });
        // read all the polyfill content, in this particular order
        const results = yield Promise.all(readFilePromises);
        // concat the polyfills
        return results.join('\n').trim();
    });
}
function copyEsmCorePolyfills(config, compilerCtx, outputTarget) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const polyfillsBuildDir = getPolyfillsEsmBuildPath(config, outputTarget);
        yield POLYFILLS.map((polyfillFile) => __awaiter$5(this, void 0, void 0, function* () {
            const staticName = config.sys.path.join('polyfills', 'esm', polyfillFile);
            const polyfillsContent = yield config.sys.getClientCoreFile({ staticName: staticName });
            const polyfillDst = pathJoin(config, polyfillsBuildDir, polyfillFile);
            yield compilerCtx.fs.writeFile(polyfillDst, polyfillsContent);
        }));
    });
}
// order of the polyfills matters!! test test test
// actual source of the polyfills are found in /src/client/polyfills/
const POLYFILLS = [
    'dom.js',
    'array.js',
    'object.js',
    'string.js',
    'promise.js',
    'fetch.js',
];

const isDef = (v) => v != null;
const toLowerCase = (str) => str.toLowerCase();
const toDashCase = (str) => toLowerCase(str.replace(/([A-Z0-9])/g, g => ' ' + g[0]).trim().replace(/ /g, '-'));
const dashToPascalCase = (str) => toLowerCase(str).split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
const captializeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const noop = () => { };

function formatBrowserLoaderComponentRegistry(cmpRegistry) {
    // ensure we've got a standard order of the components
    return Object.keys(cmpRegistry).sort().map(tag => {
        const cmpMeta = cmpRegistry[tag];
        cmpMeta.tagNameMeta = tag.toLowerCase().trim();
        return formatBrowserLoaderComponent(cmpMeta);
    });
}
function formatBrowserLoaderComponent(cmpMeta) {
    const d = [
        /* 0 */ cmpMeta.tagNameMeta,
        /* 1 */ formatBrowserLoaderBundleIds(cmpMeta.bundleIds),
        /* 2 */ formatHasStyles(cmpMeta.stylesMeta),
        /* 3 */ formatMembers(cmpMeta.membersMeta),
        /* 4 */ formatEncapsulation(cmpMeta.encapsulation),
        /* 5 */ formatListeners(cmpMeta.listenersMeta)
    ];
    return trimFalsyData(d);
}
function formatEsmLoaderComponent(config, cmpMeta) {
    const d = [
        /* 0 */ cmpMeta.tagNameMeta,
        /* 1 */ '__GET_MODULE_FN__',
        /* 2 */ formatHasStyles(cmpMeta.stylesMeta),
        /* 3 */ formatMembers(cmpMeta.membersMeta),
        /* 4 */ formatEncapsulation(cmpMeta.encapsulation),
        /* 5 */ formatListeners(cmpMeta.listenersMeta)
    ];
    trimFalsyData(d);
    const str = JSON.stringify(d);
    const importFn = formatEsmLoaderImportFns(config, cmpMeta);
    return str.replace(`"__GET_MODULE_FN__"`, importFn);
}
function formatBrowserLoaderBundleIds(bundleIds) {
    if (!bundleIds) {
        return `invalid-bundle-id`;
    }
    if (typeof bundleIds === 'string') {
        return bundleIds;
    }
    const modes = Object.keys(bundleIds).sort();
    if (!modes.length) {
        return `invalid-bundle-id`;
    }
    if (modes.length === 1) {
        return bundleIds[modes[0]];
    }
    const bundleIdObj = {};
    modes.forEach(modeName => {
        bundleIdObj[modeName] = bundleIds[modeName];
    });
    return bundleIdObj;
}
function formatEsmLoaderImportFns(config, cmpMeta) {
    const modes = Object.keys(cmpMeta.bundleIds).sort((a, b) => {
        if (a === '$' || a === 'md')
            return 1;
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    });
    const moduleImports = modes.map(styleMode => {
        return getModuleImport(cmpMeta, styleMode);
    }).join('');
    let importFn = `(function(){${moduleImports}})()`;
    importFn = config.sys.minifyJs(importFn).output;
    if (importFn.endsWith(';')) {
        importFn = importFn.substring(0, importFn.length - 1);
    }
    return `function(${importFn.includes('o.') ? 'o' : ''}){return(${importFn}).then(function(m){return m.${dashToPascalCase(cmpMeta.tagNameMeta)}})}`;
}
function getModuleFileName(cmpMeta, styleMode) {
    return (typeof cmpMeta.bundleIds !== 'string') ? cmpMeta.bundleIds[styleMode] : cmpMeta.bundleIds;
}
function getModuleImport(cmpMeta, styleMode) {
    const bundleFileName = getModuleFileName(cmpMeta, styleMode);
    const isScoped = cmpMeta.encapsulation === 2 /* ScopedCss */;
    if (styleMode === '$' || styleMode === 'md') {
        if (isScoped) {
            return `
        if (o.scoped) {
          return import('./${bundleFileName}.sc.js');
        }
        return import('./${bundleFileName}.js');
      `;
        }
        return `return import('./${bundleFileName}.js');`;
    }
    if (isScoped) {
        return `
      if (o.mode == '${styleMode}') {
        if (o.scoped) {
          return import('./${bundleFileName}.sc.js');
        }
        return import('./${bundleFileName}.js');
      }`;
    }
    return `
    if (o.mode == '${styleMode}') {
      return import('./${bundleFileName}.js');
    }`;
}
function formatHasStyles(stylesMeta) {
    if (stylesMeta && Object.keys(stylesMeta).length > 0) {
        return 1;
    }
    return 0;
}
function formatMembers(membersMeta) {
    if (!membersMeta) {
        return 0;
    }
    const observeAttrs = [];
    const memberNames = Object.keys(membersMeta).sort();
    memberNames.forEach(memberName => {
        const memberMeta = membersMeta[memberName];
        const d = [
            memberName,
            memberMeta.memberType /* 1 - memberType */
        ];
        if (memberMeta.propType === 3 /* Boolean */ || memberMeta.propType === 4 /* Number */ || memberMeta.propType === 2 /* String */ || memberMeta.propType === 1 /* Any */) {
            // observe the attribute
            if (memberMeta.reflectToAttrib) {
                d.push(1); /* 2 - reflectToAttr */
            }
            else {
                d.push(0); /* 2 - reflectToAttr */
            }
            if (memberMeta.attribName !== memberName) {
                // property name and attribute name are different
                // ariaDisabled !== aria-disabled
                d.push(memberMeta.attribName); /* 3 - attribName */
            }
            else {
                // property name and attribute name are the exact same
                // checked === checked
                d.push(1); /* 3 - attribName */
            }
            d.push(memberMeta.propType); /* 4 - propType */
        }
        else {
            // do not observe the attribute
            d.push(0); /* 2 - reflectToAttr */
            d.push(0); /* 3 - attribName */
            d.push(0 /* Unknown */); /* 4 - propType */
        }
        if (memberMeta.ctrlId) {
            d.push(memberMeta.ctrlId); /* 5 - ctrlId */
        }
        observeAttrs.push(d);
    });
    if (!observeAttrs.length) {
        return 0;
    }
    return observeAttrs.map(p => {
        return trimFalsyData(p);
    });
}
function formatEncapsulation(val) {
    if (val === 1 /* ShadowDom */) {
        return 1 /* ShadowDom */;
    }
    if (val === 2 /* ScopedCss */) {
        return 2 /* ScopedCss */;
    }
    return 0 /* NoEncapsulation */;
}
function formatListeners(listeners) {
    if (!listeners || !listeners.length) {
        return 0;
    }
    return listeners.map(listener => {
        const d = [
            listener.eventName,
            listener.eventMethodName,
            listener.eventDisabled ? 1 : 0,
            listener.eventPassive ? 1 : 0,
            listener.eventCapture ? 1 : 0
        ];
        return trimFalsyData(d);
    });
}
function formatConstructorEncapsulation(encapsulation) {
    if (encapsulation) {
        if (encapsulation === 1 /* ShadowDom */) {
            return 'shadow';
        }
        else if (encapsulation === 2 /* ScopedCss */) {
            return 'scoped';
        }
    }
    return null;
}
function formatComponentConstructorProperties(membersMeta, stringify, excludeInternal) {
    if (!membersMeta) {
        return null;
    }
    const memberNames = Object.keys(membersMeta).sort((a, b) => {
        if (a.toLowerCase() < b.toLowerCase())
            return -1;
        if (a.toLowerCase() > b.toLowerCase())
            return 1;
        return 0;
    });
    if (!memberNames.length) {
        return null;
    }
    const properties = {};
    memberNames.forEach(memberName => {
        const prop = formatComponentConstructorProperty(membersMeta[memberName], stringify, excludeInternal);
        if (prop !== null) {
            properties[memberName] = prop;
        }
    });
    if (!Object.keys(properties).length) {
        return null;
    }
    if (stringify) {
        let str = JSON.stringify(properties);
        str = str.replace(`"TYPE_String"`, `String`);
        str = str.replace(`"TYPE_Boolean"`, `Boolean`);
        str = str.replace(`"TYPE_Number"`, `Number`);
        return str;
    }
    return properties;
}
function formatComponentConstructorProperty(memberMeta, stringify, excludeInternal) {
    const property = {};
    if (memberMeta.memberType === 5 /* State */) {
        if (excludeInternal)
            return null;
        property.state = true;
    }
    else if (memberMeta.memberType === 7 /* Element */) {
        if (excludeInternal)
            return null;
        property.elementRef = true;
    }
    else if (memberMeta.memberType === 6 /* Method */) {
        property.method = true;
    }
    else if (memberMeta.memberType === 4 /* PropConnect */) {
        if (excludeInternal)
            return null;
        property.connect = memberMeta.ctrlId;
    }
    else if (memberMeta.memberType === 3 /* PropContext */) {
        if (excludeInternal)
            return null;
        property.context = memberMeta.ctrlId;
    }
    else {
        if (memberMeta.propType === 2 /* String */) {
            if (stringify) {
                property.type = 'TYPE_String';
            }
            else {
                property.type = String;
            }
        }
        else if (memberMeta.propType === 3 /* Boolean */) {
            if (stringify) {
                property.type = 'TYPE_Boolean';
            }
            else {
                property.type = Boolean;
            }
        }
        else if (memberMeta.propType === 4 /* Number */) {
            if (stringify) {
                property.type = 'TYPE_Number';
            }
            else {
                property.type = Number;
            }
        }
        else {
            property.type = 'Any';
        }
        if (typeof memberMeta.attribName === 'string') {
            property.attr = memberMeta.attribName;
            if (memberMeta.reflectToAttrib) {
                property.reflectToAttr = true;
            }
        }
        if (memberMeta.memberType === 2 /* PropMutable */) {
            property.mutable = true;
        }
    }
    if (memberMeta.watchCallbacks && memberMeta.watchCallbacks.length > 0) {
        property.watchCallbacks = memberMeta.watchCallbacks.slice();
    }
    return property;
}
function formatComponentConstructorEvents(eventsMeta) {
    if (!eventsMeta || !eventsMeta.length) {
        return null;
    }
    return eventsMeta.map(ev => formatComponentConstructorEvent(ev));
}
function formatComponentConstructorEvent(eventMeta) {
    const constructorEvent = {
        name: eventMeta.eventName,
        method: eventMeta.eventMethodName,
        bubbles: true,
        cancelable: true,
        composed: true
    };
    // default bubbles true
    if (typeof eventMeta.eventBubbles === 'boolean') {
        constructorEvent.bubbles = eventMeta.eventBubbles;
    }
    // default cancelable true
    if (typeof eventMeta.eventCancelable === 'boolean') {
        constructorEvent.cancelable = eventMeta.eventCancelable;
    }
    // default composed true
    if (typeof eventMeta.eventComposed === 'boolean') {
        constructorEvent.composed = eventMeta.eventComposed;
    }
    return constructorEvent;
}
function formatComponentConstructorListeners(listenersMeta, stringify) {
    if (!listenersMeta || !listenersMeta.length) {
        return null;
    }
    const listeners = listenersMeta.map(ev => formatComponentConstructorListener(ev));
    if (stringify) {
        return JSON.stringify(listeners);
    }
    return listeners;
}
function formatComponentConstructorListener(listenMeta) {
    const constructorListener = {
        name: listenMeta.eventName,
        method: listenMeta.eventMethodName
    };
    // default capture falsy
    if (listenMeta.eventCapture === true) {
        constructorListener.capture = true;
    }
    // default disabled falsy
    if (listenMeta.eventDisabled === true) {
        constructorListener.disabled = true;
    }
    // default passive falsy
    if (listenMeta.eventPassive === true) {
        constructorListener.passive = true;
    }
    return constructorListener;
}
function trimFalsyData(d) {
    for (var i = d.length - 1; i >= 0; i--) {
        if (d[i]) {
            break;
        }
        // if falsy, safe to pop()
        d.pop();
    }
    return d;
}
function getStylePlaceholder(tagName) {
    return `/**style-placeholder:${tagName}:**/`;
}
function getStyleIdPlaceholder(tagName) {
    return `/**style-id-placeholder:${tagName}:**/`;
}
function getBundleIdPlaceholder() {
    return `/**:bundle-id:**/`;
}
function replaceBundleIdPlaceholder(jsText, bundleId) {
    return jsText.replace(getBundleIdPlaceholder(), bundleId);
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateEsmIndex(config, compilerCtx, outputTarget) {
    return __awaiter$6(this, void 0, void 0, function* () {
        const esm = [
            `// ${config.namespace}: ES Module`
        ];
        const defineLibraryEsm = getDefineCustomElementsPath(config, outputTarget, 'es5');
        yield addExport(config, compilerCtx, outputTarget, esm, defineLibraryEsm);
        const collectionIndexPath = pathJoin(config, outputTarget.collectionDir, 'index.js');
        yield addExport(config, compilerCtx, outputTarget, esm, collectionIndexPath);
        const distIndexEsmPath = getDistEsmIndexPath(config, outputTarget);
        yield Promise.all([
            compilerCtx.fs.writeFile(distIndexEsmPath, esm.join('\n')),
            copyEsmCorePolyfills(config, compilerCtx, outputTarget),
            patchCollection(config, compilerCtx, outputTarget)
        ]);
    });
}
function addExport(config, compilerCtx, outputTarget, esm, filePath) {
    return __awaiter$6(this, void 0, void 0, function* () {
        const fileExists = yield compilerCtx.fs.access(filePath);
        if (fileExists) {
            let relPath = normalizePath(config.sys.path.relative(getDistEsmBuildDir(config, outputTarget), filePath));
            if (!relPath.startsWith('.')) {
                relPath = './' + relPath;
            }
            esm.push(`export * from '${relPath}';`);
        }
    });
}
function generateEsmHosts(config, compilerCtx, cmpRegistry, outputTarget) {
    return __awaiter$6(this, void 0, void 0, function* () {
        if (outputTarget.type !== 'dist') {
            return;
        }
        yield Promise.all([
            generateEsmEs5(config, compilerCtx, cmpRegistry, outputTarget),
            generateDefineCustomElements(config, compilerCtx, cmpRegistry, outputTarget)
        ]);
    });
}
function generateDefineCustomElements(config, compilerCtx, cmpRegistry, outputTarget) {
    return __awaiter$6(this, void 0, void 0, function* () {
        const componentClassList = Object.keys(cmpRegistry).map(tagName => {
            const cmpMeta = cmpRegistry[tagName];
            return cmpMeta.componentClass;
        }).sort();
        const c = [
            `// ${config.namespace}: Custom Elements Define Library, ES Module/ES5 Target`
        ];
        c.push(`import { defineCustomElement } from './${getCoreEsmFileName(config)}';`);
        c.push(`import {\n  ${componentClassList.join(',\n  ')}\n} from './${getComponentsEsmFileName(config)}';`);
        c.push(``);
        c.push(`export function defineCustomElements(window, opts) {`);
        c.push(`  defineCustomElement(window, [\n    ${componentClassList.join(',\n    ')}\n  ], opts);`);
        c.push(`}`);
        const defineFilePath = getDefineCustomElementsPath(config, outputTarget, 'es5');
        yield compilerCtx.fs.writeFile(defineFilePath, c.join('\n'));
    });
}
function appendDefineCustomElementsType(content) {
    const types = `export declare function defineCustomElements(window: any): void;`;
    if (!content.includes(types)) {
        content += '\n' + types;
    }
    return content;
}
function generateEsmEs5(config, compilerCtx, cmpRegistry, outputTarget) {
    return __awaiter$6(this, void 0, void 0, function* () {
        const c = [
            `// ${config.namespace}: Host Data, ES Module/ES5 Target`
        ];
        Object.keys(cmpRegistry).sort().forEach(tagName => {
            const cmpMeta = cmpRegistry[tagName];
            const data = formatEsmLoaderComponent(config, cmpMeta);
            c.push(`export var ${cmpMeta.componentClass} = ${data};`);
        });
        const componentsEsmFilePath = getComponentsEsmBuildPath(config, outputTarget, 'es5');
        yield compilerCtx.fs.writeFile(componentsEsmFilePath, c.join('\n\n'));
    });
}
function patchCollection(config, compilerCtx, outputTarget) {
    return __awaiter$6(this, void 0, void 0, function* () {
        // it's possible a d.ts file was exported from the index.ts file
        // which is fine, except that messes with any raw JS exports
        // in the collection/index.js
        // so let's just make this work by putting in empty js files
        // and call it a day
        const collectionInterfacePath = pathJoin(config, outputTarget.collectionDir, 'interface.js');
        const exists = yield compilerCtx.fs.access(collectionInterfacePath);
        if (!exists) {
            yield compilerCtx.fs.writeFile(collectionInterfacePath, '');
        }
    });
}

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function validatePackageFiles(config, outputTarget, diagnostics, pkgData) {
    if (pkgData.files) {
        const actualDistDir = normalizePath(config.sys.path.relative(config.rootDir, outputTarget.dir));
        const validPaths = [
            `${actualDistDir}`,
            `${actualDistDir}/`,
            `./${actualDistDir}`,
            `./${actualDistDir}/`
        ];
        const containsDistDir = pkgData.files
            .some(userPath => validPaths.some(validPath => normalizePath(userPath) === validPath));
        if (!containsDistDir) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "files" array must contain the distribution directory "${actualDistDir}/" when generating a distribution.`;
        }
    }
}
function validateModule(config, compilerCtx, outputTarget, diagnostics, pkgData) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const moduleAbs = getDistEsmIndexPath(config, outputTarget);
        const moduleRel = normalizePath(config.sys.path.relative(config.rootDir, moduleAbs));
        if (typeof pkgData.module !== 'string') {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "module" property is required when generating a distribution. It's recommended to set the "module" property to: ${moduleRel}`;
            return;
        }
        const pkgFile = pathJoin(config, config.rootDir, pkgData.module);
        const fileExists = yield compilerCtx.fs.access(pkgFile);
        if (!fileExists) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "module" property is set to "${pkgData.module}" but cannot be found. It's recommended to set the "module" property to: ${moduleRel}`;
            return;
        }
    });
}
function validateMain(config, compilerCtx, outputTarget, diagnostics, pkgData) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const mainAbs = getDistCjsIndexPath(config, outputTarget);
        const mainRel = pathJoin(config, config.sys.path.relative(config.rootDir, mainAbs));
        if (typeof pkgData.main !== 'string' || pkgData.main === '') {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "main" property is required when generating a distribution. It's recommended to set the "main" property to: ${mainRel}`;
            return;
        }
        const pkgFile = pathJoin(config, config.rootDir, pkgData.main);
        const fileExists = yield compilerCtx.fs.access(pkgFile);
        if (!fileExists) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "main" property is set to "${pkgData.main}" but cannot be found. It's recommended to set the "main" property to: ${mainRel}`;
            return;
        }
        const loaderAbs = getLoaderPath(config, outputTarget);
        const loaderRel = pathJoin(config, config.sys.path.relative(config.rootDir, loaderAbs));
        if (normalizePath(pkgData.main) === loaderRel) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "main" property should not be set to "${pkgData.main}", which is the browser loader (this was a previous recommendation, but recently updated). Instead, please set the "main" property to: ${mainRel}`;
            return;
        }
    });
}
function validateTypes(config, compilerCtx, outputTarget, diagnostics, pkgData) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const typesAbs = config.sys.path.join(outputTarget.typesDir, COMPONENTS_DTS);
        const typesRel = pathJoin(config, config.sys.path.relative(config.rootDir, typesAbs));
        if (typeof pkgData.types !== 'string' || pkgData.types === '') {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "types" property is required when generating a distribution. It's recommended to set the "types" property to: ${typesRel}`;
            return false;
        }
        if (!pkgData.types.endsWith('.d.ts')) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "types" file must have a ".d.ts" extension: ${pkgData.types}`;
            return false;
        }
        const pkgFile = pathJoin(config, config.rootDir, pkgData.types);
        const fileExists = yield compilerCtx.fs.access(pkgFile);
        if (!fileExists) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "types" property is set to "${pkgData.types}" but cannot be found. It's recommended to set the "types" property to: ${typesRel}`;
            return false;
        }
        return true;
    });
}
function validateCollection(config, outputTarget, diagnostics, pkgData) {
    if (outputTarget.collectionDir) {
        const collectionRel = pathJoin(config, config.sys.path.relative(config.rootDir, outputTarget.collectionDir), COLLECTION_MANIFEST_FILE_NAME);
        if (!pkgData.collection || normalizePath(pkgData.collection) !== collectionRel) {
            const err = buildWarn(diagnostics);
            err.messageText = `package.json "collection" property is required when generating a distribution and must be set to: ${collectionRel}`;
        }
    }
}
function validateBrowser(diagnostics, pkgData) {
    if (typeof pkgData.browser === 'string') {
        const err = buildWarn(diagnostics);
        err.messageText = `package.json "browser" property is set to "${pkgData.browser}". However, for maximum compatibility with all bundlers it's recommended to not set the "browser" property and instead ensure both "module" and "main" properties are set.`;
        return;
    }
}
function validateNamespace(config, diagnostics) {
    if (typeof config.namespace !== 'string' || config.fsNamespace === 'app') {
        const err = buildWarn(diagnostics);
        err.messageText = `When generating a distribution it is recommended to choose a unique namespace rather than the default setting "App". Please updated the "namespace" config property within the stencil.config.js file.`;
    }
}

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateTypes(config, compilerCtx, outputTarget, buildCtx, pkgData) {
    return __awaiter$8(this, void 0, void 0, function* () {
        const isValid = yield validateTypes(config, compilerCtx, outputTarget, buildCtx.diagnostics, pkgData);
        if (!isValid) {
            return;
        }
        const srcDirItems = yield compilerCtx.fs.readdir(config.srcDir, { recursive: false });
        const srcDtsFiles = srcDirItems.filter(srcItem => srcItem.isFile && isDtsFile(srcItem.absPath));
        const distTypesDir = config.sys.path.dirname(pkgData.types);
        yield Promise.all(srcDtsFiles.map((srcDtsFile) => __awaiter$8(this, void 0, void 0, function* () {
            const relPath = config.sys.path.relative(config.srcDir, srcDtsFile.absPath);
            const distPath = pathJoin(config, config.rootDir, distTypesDir, relPath);
            const dtsContent = yield compilerCtx.fs.readFile(srcDtsFile.absPath);
            yield compilerCtx.fs.writeFile(distPath, dtsContent);
        })));
        const dtsEntryFilePath = config.sys.path.join(config.rootDir, pkgData.types);
        const dtsFileExists = yield compilerCtx.fs.access(dtsEntryFilePath);
        if (!dtsFileExists) {
            const err = buildError(buildCtx.diagnostics);
            err.header = `package.json error`;
            err.messageText = `package.json "types" file does not exist: ${dtsEntryFilePath}`;
        }
        const outputTargets = config.outputTargets.filter(o => o.typesDir);
        yield Promise.all(outputTargets.map(outputTarget => {
            return updateTypes(config, compilerCtx, outputTarget);
        }));
    });
}
function updateTypes(config, compilerCtx, outputTarget) {
    return __awaiter$8(this, void 0, void 0, function* () {
        const typeDirItems = yield compilerCtx.fs.readdir(outputTarget.typesDir, { inMemoryOnly: true, recursive: true });
        const dtsFiles = typeDirItems.filter(dtsItem => dtsItem.isFile && isDtsFile(dtsItem.absPath));
        const updates = yield Promise.all(dtsFiles.map(dtsFile => {
            return updateDtsContent(config, compilerCtx, outputTarget, dtsFile.absPath);
        }));
        if (updates.some(u => u)) {
            yield copyCoreDts(config, compilerCtx, outputTarget);
        }
    });
}
function updateDtsContent(config, compilerCtx, outputTarget, dtsFilePath) {
    return __awaiter$8(this, void 0, void 0, function* () {
        let content = yield compilerCtx.fs.readFile(dtsFilePath);
        let madeChanges = false;
        const relPath = config.sys.path.relative(config.sys.path.dirname(dtsFilePath), outputTarget.typesDir);
        let coreDtsPath = pathJoin(config, relPath, CORE_FILENAME);
        if (!coreDtsPath.startsWith('.')) {
            coreDtsPath = `./${coreDtsPath}`;
        }
        if (content.includes('JSX')) {
            content = `import '${coreDtsPath}';\n${content}`;
            madeChanges = true;
        }
        if (content.includes('@stencil/core')) {
            content = content.replace(/\@stencil\/core/g, coreDtsPath);
            madeChanges = true;
        }
        if (madeChanges) {
            yield compilerCtx.fs.writeFile(dtsFilePath, content);
        }
        return madeChanges;
    });
}
function copyCoreDts(config, compilerCtx, outputTarget) {
    return __awaiter$8(this, void 0, void 0, function* () {
        const srcDts = yield config.sys.getClientCoreFile({
            staticName: 'declarations/stencil.core.d.ts'
        });
        const coreDtsFilePath = pathJoin(config, outputTarget.typesDir, CORE_DTS);
        yield compilerCtx.fs.writeFile(coreDtsFilePath, srcDts);
    });
}
const CORE_FILENAME = `stencil.core`;
const CORE_DTS = `${CORE_FILENAME}.d.ts`;

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateDistributions(config, compilerCtx, buildCtx) {
    return __awaiter$9(this, void 0, void 0, function* () {
        const distOutputs = config.outputTargets.filter(o => o.type === 'dist');
        return Promise.all(distOutputs.map(outputTarget => {
            return generateDistribution(config, compilerCtx, buildCtx, outputTarget);
        }));
    });
}
function generateDistribution(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$9(this, void 0, void 0, function* () {
        const pkgData = yield readPackageJson(config, compilerCtx);
        validatePackageFiles(config, outputTarget, buildCtx.diagnostics, pkgData);
        validateCollection(config, outputTarget, buildCtx.diagnostics, pkgData);
        validateNamespace(config, buildCtx.diagnostics);
        if (hasError(buildCtx.diagnostics)) {
            return;
        }
        yield Promise.all([
            generateCommonJsIndex(config, compilerCtx, outputTarget),
            generateEsmIndex(config, compilerCtx, outputTarget),
            copyComponentStyles(config, compilerCtx, buildCtx),
            generateTypes(config, compilerCtx, outputTarget, buildCtx, pkgData)
        ]);
        yield validateModule(config, compilerCtx, outputTarget, buildCtx.diagnostics, pkgData);
        yield validateMain(config, compilerCtx, outputTarget, buildCtx.diagnostics, pkgData);
        validateBrowser(buildCtx.diagnostics, pkgData);
    });
}
function readPackageJson(config, compilerCtx) {
    return __awaiter$9(this, void 0, void 0, function* () {
        const pkgJsonPath = config.sys.path.join(config.rootDir, 'package.json');
        let pkgJson;
        try {
            pkgJson = yield compilerCtx.fs.readFile(pkgJsonPath);
        }
        catch (e) {
            throw new Error(`Missing "package.json" file for distribution: ${pkgJsonPath}`);
        }
        let pkgData;
        try {
            pkgData = JSON.parse(pkgJson);
        }
        catch (e) {
            throw new Error(`Error parsing package.json: ${pkgJsonPath}, ${e}`);
        }
        return pkgData;
    });
}
function getComponentsDtsSrcFilePath(config) {
    return pathJoin(config, config.srcDir, COMPONENTS_DTS);
}
function getComponentsDtsTypesFilePath(config, outputTarget) {
    return pathJoin(config, outputTarget.typesDir, COMPONENTS_DTS);
}
const COMPONENTS_DTS = 'components.d.ts';

var __awaiter$10 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function copyTasks(config, compilerCtx, diagnostics, commit) {
    return __awaiter$10(this, void 0, void 0, function* () {
        if (!config.copy) {
            config.logger.debug(`copy tasks disabled`);
            return;
        }
        const timeSpan = config.logger.createTimeSpan(`copy task started`, true);
        try {
            const allCopyTasks = [];
            const copyTasks = Object.keys(config.copy).map(copyTaskName => config.copy[copyTaskName]);
            yield Promise.all(copyTasks.map((copyTask) => __awaiter$10(this, void 0, void 0, function* () {
                yield processCopyTasks(config, compilerCtx, allCopyTasks, copyTask);
            })));
            yield Promise.all(allCopyTasks.map((copyTask) => __awaiter$10(this, void 0, void 0, function* () {
                yield compilerCtx.fs.copy(copyTask.src, copyTask.dest, { filter: copyTask.filter });
            })));
            if (commit && allCopyTasks.length > 0) {
                config.logger.debug(`copy task commit, tasks: ${allCopyTasks.length}`);
                yield compilerCtx.fs.commit();
            }
        }
        catch (e) {
            catchError(diagnostics, e);
        }
        timeSpan.finish(`copy task finished`);
    });
}
function processCopyTasks(config, compilerCtx, allCopyTasks, copyTask) {
    return __awaiter$10(this, void 0, void 0, function* () {
        if (!copyTask) {
            // possible null was set, which is fine, just skip over this one
            return;
        }
        if (!copyTask.src) {
            throw new Error(`copy missing "src" property`);
        }
        if (copyTask.dest && config.sys.isGlob(copyTask.dest)) {
            throw new Error(`copy "dest" property cannot be a glob: ${copyTask.dest}`);
        }
        const outputTargets = config.outputTargets.filter(outputTarget => {
            return outputTarget.appBuild;
        });
        if (config.sys.isGlob(copyTask.src)) {
            const copyTasks = yield processGlob(config, outputTargets, copyTask);
            allCopyTasks.push(...copyTasks);
            return;
        }
        return Promise.all(outputTargets.map(outputTarget => {
            if (outputTarget.collectionDir) {
                return processCopyTaskDestDir(config, compilerCtx, allCopyTasks, copyTask, outputTarget.collectionDir);
            }
            else {
                return processCopyTaskDestDir(config, compilerCtx, allCopyTasks, copyTask, outputTarget.dir);
            }
        }));
    });
}
function processCopyTaskDestDir(config, compilerCtx, allCopyTasks, copyTask, destAbsDir) {
    return __awaiter$10(this, void 0, void 0, function* () {
        const processedCopyTask = processCopyTask(config, copyTask, destAbsDir);
        try {
            const stats = yield compilerCtx.fs.stat(processedCopyTask.src);
            processedCopyTask.isDirectory = stats.isDirectory;
            config.logger.debug(`copy, ${processedCopyTask.src} to ${processedCopyTask.dest}, isDirectory: ${processedCopyTask.isDirectory}`);
            allCopyTasks.push(processedCopyTask);
        }
        catch (e) {
            if (copyTask.warn !== false) {
                config.logger.warn(`copy, ${processedCopyTask.src}: ${e}`);
            }
        }
    });
}
function processGlob(config, outputTargets, copyTask) {
    return __awaiter$10(this, void 0, void 0, function* () {
        const globCopyTasks = [];
        const globOpts = {
            cwd: config.srcDir,
            nodir: true
        };
        const files = yield config.sys.glob(copyTask.src, globOpts);
        files.forEach(globRelPath => {
            outputTargets.forEach(outputTarget => {
                if (outputTarget.collectionDir) {
                    globCopyTasks.push(createGlobCopyTask(config, copyTask, outputTarget.collectionDir, globRelPath));
                }
                else {
                    globCopyTasks.push(createGlobCopyTask(config, copyTask, outputTarget.dir, globRelPath));
                }
            });
        });
        return globCopyTasks;
    });
}
function createGlobCopyTask(config, copyTask, destDir, globRelPath) {
    const processedCopyTask = {
        src: config.sys.path.join(config.srcDir, globRelPath),
        filter: copyTask.filter
    };
    if (copyTask.dest) {
        if (config.sys.path.isAbsolute(copyTask.dest)) {
            processedCopyTask.dest = config.sys.path.join(copyTask.dest, config.sys.path.basename(globRelPath));
        }
        else {
            processedCopyTask.dest = config.sys.path.join(destDir, copyTask.dest, config.sys.path.basename(globRelPath));
        }
    }
    else {
        processedCopyTask.dest = config.sys.path.join(destDir, globRelPath);
    }
    return processedCopyTask;
}
function processCopyTask(config, copyTask, destAbsPath) {
    const processedCopyTask = {
        src: getSrcAbsPath(config, copyTask.src),
        dest: getDestAbsPath(config, copyTask.src, destAbsPath, copyTask.dest),
        filter: copyTask.filter
    };
    return processedCopyTask;
}
function getSrcAbsPath(config, src) {
    if (config.sys.path.isAbsolute(src)) {
        return src;
    }
    return config.sys.path.join(config.srcDir, src);
}
function getDestAbsPath(config, src, destAbsPath, destRelPath) {
    if (destRelPath) {
        if (config.sys.path.isAbsolute(destRelPath)) {
            return destRelPath;
        }
        else {
            return config.sys.path.join(destAbsPath, destRelPath);
        }
    }
    if (config.sys.path.isAbsolute(src)) {
        throw new Error(`copy task, "to" property must exist if "from" property is an absolute path: ${src}`);
    }
    return config.sys.path.join(destAbsPath, src);
}
function isCopyTaskFile(config, filePath) {
    if (!config.copy) {
        // there is no copy config
        return false;
    }
    const copyTaskNames = Object.keys(config.copy);
    if (!copyTaskNames.length) {
        // there are no copy tasks
        return false;
    }
    filePath = normalizePath(filePath);
    // go through all the copy tasks and see if this path matches
    for (var i = 0; i < copyTaskNames.length; i++) {
        var copySrc = config.copy[copyTaskNames[i]].src;
        if (config.sys.isGlob(copySrc)) {
            // test the glob
            copySrc = config.sys.path.join(config.srcDir, copySrc);
            if (config.sys.minimatch(filePath, copySrc)) {
                return true;
            }
        }
        else {
            copySrc = normalizePath(getSrcAbsPath(config, copySrc));
            if (!config.sys.path.relative(copySrc, filePath).startsWith('.')) {
                return true;
            }
        }
    }
    return false;
}

class BuildEvents {
    constructor(config) {
        this.config = config;
        this.evCallbacks = {};
    }
    subscribe(eventName, cb) {
        const evName = getEventName(eventName);
        if (eventName === 'rebuild' && !this.config.watch) {
            throw new Error(`config must set "watch" to "true" in order to enable "rebuild" events`);
        }
        if (!this.evCallbacks[evName]) {
            this.evCallbacks[evName] = [];
        }
        this.evCallbacks[evName].push(cb);
        return () => {
            this.unsubscribe(evName, cb);
        };
    }
    unsubscribe(eventName, cb) {
        const evName = getEventName(eventName);
        if (this.evCallbacks[evName]) {
            const index = this.evCallbacks[evName].indexOf(cb);
            if (index > -1) {
                this.evCallbacks[evName].splice(index, 1);
            }
        }
    }
    unsubscribeAll() {
        this.evCallbacks = {};
    }
    emit(eventName, ...args) {
        const evName = getEventName(eventName);
        const evCallbacks = this.evCallbacks[evName];
        if (evCallbacks) {
            evCallbacks.forEach(cb => {
                try {
                    cb.apply(this, args);
                }
                catch (e) {
                    console.log(e);
                }
            });
        }
    }
}
function getEventName(evName) {
    return evName.trim().toLowerCase();
}

var __awaiter$11 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Cache {
    constructor(config, cacheFs, tmpDir) {
        this.config = config;
        this.cacheFs = cacheFs;
        this.tmpDir = tmpDir;
        this.failed = 0;
        this.skip = false;
        if (config.enableCache) {
            config.logger.debug(`cache enabled, tmpdir: ${tmpDir}`);
        }
        else {
            config.logger.debug(`cache disabled, empty tmpdir: ${tmpDir}`);
            this.clearDiskCache();
        }
    }
    get(key) {
        return __awaiter$11(this, void 0, void 0, function* () {
            if (!this.config.enableCache || this.skip) {
                return null;
            }
            if (this.failed >= MAX_FAILED) {
                if (!this.skip) {
                    this.skip = true;
                    this.config.logger.debug(`cache had ${this.failed} failed ops, skip disk ops for remander of build`);
                }
                return null;
            }
            let result;
            try {
                result = yield this.cacheFs.readFile(this.getCacheFilePath(key));
                this.failed = 0;
                this.skip = false;
            }
            catch (e) {
                this.failed++;
                result = null;
            }
            return result;
        });
    }
    put(key, value) {
        return __awaiter$11(this, void 0, void 0, function* () {
            if (!this.config.enableCache) {
                return false;
            }
            let result;
            try {
                yield this.cacheFs.writeFile(this.getCacheFilePath(key), value);
                result = true;
            }
            catch (e) {
                this.failed++;
                result = false;
            }
            return result;
        });
    }
    createKey(domain, ...args) {
        if (!this.config.enableCache) {
            return '';
        }
        return domain + '_' + this.config.sys.generateContentHash(JSON.stringify(args), 32);
    }
    commit() {
        return __awaiter$11(this, void 0, void 0, function* () {
            if (this.config.enableCache) {
                this.skip = false;
                this.failed = 0;
                yield this.cacheFs.commit();
            }
        });
    }
    clear() {
        this.cacheFs.clearCache();
    }
    clearDiskCache() {
        return __awaiter$11(this, void 0, void 0, function* () {
            yield this.cacheFs.emptyDir(this.tmpDir);
            yield this.cacheFs.commit();
        });
    }
    getCacheFilePath(key) {
        return this.config.sys.path.join(this.tmpDir, key);
    }
    getMemoryStats() {
        return this.cacheFs.getMemoryStats();
    }
}
const MAX_FAILED = 20;

var __awaiter$12 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class InMemoryFileSystem {
    constructor(disk, path$$1) {
        this.disk = disk;
        this.path = path$$1;
        this.items = {};
    }
    accessData(filePath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(filePath);
            const data = {
                exists: false,
                isDirectory: false,
                isFile: false
            };
            if (typeof item.exists === 'boolean') {
                data.exists = item.exists;
                data.isDirectory = item.isDirectory;
                data.isFile = item.isFile;
                return data;
            }
            try {
                const s = yield this.stat(filePath);
                item.exists = true;
                item.isDirectory = s.isDirectory;
                item.isFile = s.isFile;
                data.exists = item.exists;
                data.isDirectory = item.isDirectory;
                data.isFile = item.isFile;
            }
            catch (e) {
                item.exists = false;
            }
            return data;
        });
    }
    access(filePath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const data = yield this.accessData(filePath);
            return data.exists;
        });
    }
    /**
     * Synchronous!!! Do not use!!!
     * (Only typescript transpiling is allowed to use)
     * @param filePath
     */
    accessSync(filePath) {
        const item = this.getItem(filePath);
        if (typeof item.exists === 'boolean') {
            return item.exists;
        }
        let hasAccess = false;
        try {
            const s = this.statSync(filePath);
            item.exists = true;
            item.isDirectory = s.isDirectory;
            item.isFile = s.isFile;
            hasAccess = true;
        }
        catch (e) {
            item.exists = false;
        }
        return hasAccess;
    }
    copy(src, dest, opts) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const stats = yield this.stat(src);
            if (stats.isDirectory) {
                yield this.copyDir(src, dest, opts);
            }
            else if (stats.isFile) {
                yield this.copyFile(src, dest, opts);
            }
        });
    }
    copyDir(src, dest, opts) {
        return __awaiter$12(this, void 0, void 0, function* () {
            src = normalizePath(src);
            dest = normalizePath(dest);
            const dirItems = yield this.readdir(src, { recursive: true });
            yield Promise.all(dirItems.map((dirItem) => __awaiter$12(this, void 0, void 0, function* () {
                const srcPath = dirItem.absPath;
                const destPath = normalizePath(this.path.join(dest, dirItem.relPath));
                if (dirItem.isDirectory) {
                    yield this.copyDir(srcPath, destPath, opts);
                }
                else if (dirItem.isFile) {
                    yield this.copyFile(srcPath, destPath, opts);
                }
            })));
        });
    }
    copyFile(src, dest, opts) {
        return __awaiter$12(this, void 0, void 0, function* () {
            src = normalizePath(src);
            dest = normalizePath(dest);
            if (opts && typeof opts.filter === 'function' && !opts.filter(src, dest)) {
                return;
            }
            if (shouldIgnore(src)) {
                return;
            }
            const srcItem = this.getItem(src);
            srcItem.isFile = true;
            srcItem.isDirectory = false;
            const destItem = this.getItem(dest);
            destItem.isFile = true;
            destItem.isDirectory = false;
            destItem.queueDeleteFromDisk = false;
            if (isTextFile(src)) {
                const srcFileText = yield this.readFile(src);
                if (srcFileText !== destItem.fileText) {
                    destItem.fileText = srcFileText;
                    destItem.queueWriteToDisk = true;
                }
            }
            else {
                destItem.fileSrc = src;
                destItem.queueWriteToDisk = true;
            }
        });
    }
    emptyDir(dirPath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(dirPath);
            yield this.removeDir(dirPath);
            item.isFile = false;
            item.isDirectory = true;
            item.queueWriteToDisk = true;
            item.queueDeleteFromDisk = false;
        });
    }
    readdir(dirPath, opts = {}) {
        return __awaiter$12(this, void 0, void 0, function* () {
            dirPath = normalizePath(dirPath);
            const collectedPaths = [];
            if (opts.inMemoryOnly) {
                let inMemoryDir = dirPath;
                if (!inMemoryDir.endsWith('/')) {
                    inMemoryDir += '/';
                }
                const inMemoryDirs = dirPath.split('/');
                const filePaths = Object.keys(this.items);
                filePaths.forEach(filePath => {
                    if (!filePath.startsWith(dirPath)) {
                        return;
                    }
                    const parts = filePath.split('/');
                    if (parts.length === inMemoryDirs.length + 1 || (opts.recursive && parts.length > inMemoryDirs.length)) {
                        const d = this.items[filePath];
                        if (d.exists) {
                            // console.log(filePath, d)
                            const item = {
                                absPath: filePath,
                                relPath: parts[inMemoryDirs.length],
                                isDirectory: d.isDirectory,
                                isFile: d.isFile
                            };
                            collectedPaths.push(item);
                        }
                    }
                });
            }
            else {
                // always a disk read
                yield this.readDirectory(dirPath, dirPath, opts, collectedPaths);
            }
            return collectedPaths.sort((a, b) => {
                if (a.absPath < b.absPath)
                    return -1;
                if (a.absPath > b.absPath)
                    return 1;
                return 0;
            });
        });
    }
    readDirectory(initPath, dirPath, opts, collectedPaths) {
        return __awaiter$12(this, void 0, void 0, function* () {
            // used internally only so we could easily recursively drill down
            // loop through this directory and sub directories
            // always a disk read!!
            const dirItems = yield this.disk.readdir(dirPath);
            // cache some facts about this path
            const item = this.getItem(dirPath);
            item.exists = true;
            item.isFile = false;
            item.isDirectory = true;
            yield Promise.all(dirItems.map((dirItem) => __awaiter$12(this, void 0, void 0, function* () {
                // let's loop through each of the files we've found so far
                // create an absolute path of the item inside of this directory
                const absPath = normalizePath(this.path.join(dirPath, dirItem));
                const relPath = normalizePath(this.path.relative(initPath, absPath));
                // get the fs stats for the item, could be either a file or directory
                const stats = yield this.stat(absPath);
                // cache some stats about this path
                const subItem = this.getItem(absPath);
                subItem.exists = true;
                subItem.isDirectory = stats.isDirectory;
                subItem.isFile = stats.isFile;
                collectedPaths.push({
                    absPath: absPath,
                    relPath: relPath,
                    isDirectory: stats.isDirectory,
                    isFile: stats.isFile
                });
                if (opts.recursive && stats.isDirectory) {
                    // looks like it's yet another directory
                    // let's keep drilling down
                    yield this.readDirectory(initPath, absPath, opts, collectedPaths);
                }
            })));
        });
    }
    readFile(filePath, opts) {
        return __awaiter$12(this, void 0, void 0, function* () {
            if (!opts || (opts.useCache === true || opts.useCache === undefined)) {
                const item = this.getItem(filePath);
                if (item.exists && typeof item.fileText === 'string') {
                    return item.fileText;
                }
            }
            const fileContent = yield this.disk.readFile(filePath, 'utf-8');
            if (fileContent.length < MAX_TEXT_CACHE) {
                const item = this.getItem(filePath);
                item.exists = true;
                item.isFile = true;
                item.isDirectory = false;
                item.fileText = fileContent;
            }
            return fileContent;
        });
    }
    /**
     * Synchronous!!! Do not use!!!
     * (Only typescript transpiling is allowed to use)
     * @param filePath
     */
    readFileSync(filePath) {
        const item = this.getItem(filePath);
        if (item.exists && typeof item.fileText === 'string') {
            return item.fileText;
        }
        const fileContent = this.disk.readFileSync(filePath, 'utf-8');
        if (fileContent.length < MAX_TEXT_CACHE) {
            item.exists = true;
            item.isFile = true;
            item.isDirectory = false;
            item.fileText = fileContent;
        }
        return fileContent;
    }
    remove(itemPath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const stats = yield this.stat(itemPath);
            if (stats.isDirectory) {
                yield this.removeDir(itemPath);
            }
            else if (stats.isFile) {
                yield this.removeItem(itemPath);
            }
        });
    }
    removeDir(dirPath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(dirPath);
            item.isFile = false;
            item.isDirectory = true;
            if (!item.queueWriteToDisk) {
                item.queueDeleteFromDisk = true;
            }
            try {
                const dirItems = yield this.readdir(dirPath, { recursive: true });
                yield Promise.all(dirItems.map((item) => __awaiter$12(this, void 0, void 0, function* () {
                    yield this.removeItem(item.absPath);
                })));
            }
            catch (e) {
                // do not throw error if the directory never existed
            }
        });
    }
    removeItem(filePath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(filePath);
            if (!item.queueWriteToDisk) {
                item.queueDeleteFromDisk = true;
            }
        });
    }
    stat(itemPath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(itemPath);
            if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
                const s = yield this.disk.stat(itemPath);
                item.exists = true;
                item.isDirectory = s.isDirectory();
                item.isFile = s.isFile();
            }
            return {
                isFile: item.isFile,
                isDirectory: item.isDirectory
            };
        });
    }
    /**
     * Synchronous!!! Do not use!!!
     * (Only typescript transpiling is allowed to use)
     * @param itemPath
     */
    statSync(itemPath) {
        const item = this.getItem(itemPath);
        if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
            const s = this.disk.statSync(itemPath);
            item.exists = true;
            item.isDirectory = s.isDirectory();
            item.isFile = s.isFile();
        }
        return {
            isFile: item.isFile,
            isDirectory: item.isDirectory
        };
    }
    writeFile(filePath, content, opts) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const results = {};
            if (typeof filePath !== 'string') {
                throw new Error(`writeFile, invalid filePath: ${filePath}`);
            }
            if (typeof content !== 'string') {
                throw new Error(`writeFile, invalid content: ${filePath}`);
            }
            if (shouldIgnore(filePath)) {
                results.ignored = true;
                return results;
            }
            const item = this.getItem(filePath);
            item.exists = true;
            item.isFile = true;
            item.isDirectory = false;
            item.queueDeleteFromDisk = false;
            results.changedContent = item.fileText !== content;
            results.queuedWrite = false;
            item.fileText = content;
            if (opts && opts.inMemoryOnly) {
                // we don't want to actually write this to disk
                // just keep it in memory
                if (item.queueWriteToDisk) {
                    // we already queued this file to write to disk
                    // in that case we still need to do it
                    results.queuedWrite = true;
                }
                else {
                    // we only want this in memory and
                    // it wasn't already queued to be written
                    item.queueWriteToDisk = false;
                }
            }
            else if (opts && opts.immediateWrite) {
                // If this is an immediate write then write the file
                // and do not add it to the queue
                yield this.disk.writeFile(filePath, item.fileText);
            }
            else {
                // we want to write this to disk (eventually)
                // but only if the content is different
                // from our existing cached content
                if (!item.queueWriteToDisk && results.changedContent) {
                    // not already queued to be written
                    // and the content is different
                    item.queueWriteToDisk = true;
                    results.queuedWrite = true;
                }
            }
            return results;
        });
    }
    writeFiles(files, opts) {
        return Promise.all(Object.keys(files).map(filePath => {
            return this.writeFile(filePath, files[filePath], opts);
        }));
    }
    commit() {
        return __awaiter$12(this, void 0, void 0, function* () {
            const instructions = getCommitInstructions(this.path, this.items);
            // ensure directories we need exist
            const dirsAdded = yield this.commitEnsureDirs(instructions.dirsToEnsure);
            // write all queued the files
            const filesWritten = yield this.commitWriteFiles(instructions.filesToWrite);
            // remove all the queued files to be deleted
            const filesDeleted = yield this.commitDeleteFiles(instructions.filesToDelete);
            // remove all the queued dirs to be deleted
            const dirsDeleted = yield this.commitDeleteDirs(instructions.dirsToDelete);
            instructions.filesToDelete.forEach(fileToDelete => {
                this.clearFileCache(fileToDelete);
            });
            instructions.dirsToDelete.forEach(dirToDelete => {
                this.clearDirCache(dirToDelete);
            });
            // return only the files that were
            return {
                filesWritten: filesWritten,
                filesDeleted: filesDeleted,
                dirsDeleted: dirsDeleted,
                dirsAdded: dirsAdded
            };
        });
    }
    commitEnsureDirs(dirsToEnsure) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const dirsAdded = [];
            for (const dirPath of dirsToEnsure) {
                const item = this.getItem(dirPath);
                if (item.exists && item.isDirectory) {
                    // already cached that this path is indeed an existing directory
                    continue;
                }
                try {
                    // cache that we know this is a directory on disk
                    item.exists = true;
                    item.isDirectory = true;
                    item.isFile = false;
                    yield this.disk.mkdir(dirPath);
                    dirsAdded.push(dirPath);
                }
                catch (e) { }
            }
            return dirsAdded;
        });
    }
    commitWriteFiles(filesToWrite) {
        return Promise.all(filesToWrite.map((filePath) => __awaiter$12(this, void 0, void 0, function* () {
            if (typeof filePath !== 'string') {
                throw new Error(`unable to writeFile without filePath`);
            }
            return this.commitWriteFile(filePath);
        })));
    }
    commitWriteFile(filePath) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const item = this.getItem(filePath);
            if (typeof item.fileSrc === 'string') {
                yield this.disk.copyFile(item.fileSrc, filePath);
                return filePath;
            }
            if (item.fileText == null) {
                throw new Error(`unable to find item fileText to write: ${filePath}`);
            }
            yield this.disk.writeFile(filePath, item.fileText);
            return filePath;
        });
    }
    commitDeleteFiles(filesToDelete) {
        return Promise.all(filesToDelete.map((filePath) => __awaiter$12(this, void 0, void 0, function* () {
            if (typeof filePath !== 'string') {
                throw new Error(`unable to unlink without filePath`);
            }
            yield this.disk.unlink(filePath);
            return filePath;
        })));
    }
    commitDeleteDirs(dirsToDelete) {
        return __awaiter$12(this, void 0, void 0, function* () {
            const dirsDeleted = [];
            for (const dirPath of dirsToDelete) {
                try {
                    yield this.disk.rmdir(dirPath);
                }
                catch (e) { }
                dirsDeleted.push(dirPath);
            }
            return dirsDeleted;
        });
    }
    clearDirCache(dirPath) {
        dirPath = normalizePath(dirPath);
        const filePaths = Object.keys(this.items);
        filePaths.forEach(f => {
            const filePath = this.path.relative(dirPath, f).split('/')[0];
            if (!filePath.startsWith('.') && !filePath.startsWith('/')) {
                this.clearFileCache(f);
            }
        });
    }
    clearFileCache(filePath) {
        filePath = normalizePath(filePath);
        const item = this.items[filePath];
        if (item && !item.queueWriteToDisk) {
            delete this.items[filePath];
        }
    }
    getItem(itemPath) {
        itemPath = normalizePath(itemPath);
        const item = this.items[itemPath];
        if (item) {
            return item;
        }
        return this.items[itemPath] = {};
    }
    clearCache() {
        this.items = {};
    }
    get keys() {
        return Object.keys(this.items).sort();
    }
    getMemoryStats() {
        return `data length: ${Object.keys(this.items).length}`;
    }
}
function getCommitInstructions(path$$1, d) {
    const instructions = {
        filesToDelete: [],
        filesToWrite: [],
        dirsToDelete: [],
        dirsToEnsure: []
    };
    Object.keys(d).forEach(itemPath => {
        const item = d[itemPath];
        if (item.queueWriteToDisk) {
            if (item.isFile) {
                instructions.filesToWrite.push(itemPath);
                const dir = normalizePath(path$$1.dirname(itemPath));
                if (!instructions.dirsToEnsure.includes(dir)) {
                    instructions.dirsToEnsure.push(dir);
                }
                const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
                if (dirDeleteIndex > -1) {
                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
                }
                const fileDeleteIndex = instructions.filesToDelete.indexOf(itemPath);
                if (fileDeleteIndex > -1) {
                    instructions.filesToDelete.splice(fileDeleteIndex, 1);
                }
            }
            else if (item.isDirectory) {
                if (!instructions.dirsToEnsure.includes(itemPath)) {
                    instructions.dirsToEnsure.push(itemPath);
                }
                const dirDeleteIndex = instructions.dirsToDelete.indexOf(itemPath);
                if (dirDeleteIndex > -1) {
                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
                }
            }
        }
        else if (item.queueDeleteFromDisk) {
            if (item.isDirectory && !instructions.dirsToEnsure.includes(itemPath)) {
                instructions.dirsToDelete.push(itemPath);
            }
            else if (item.isFile && !instructions.filesToWrite.includes(itemPath)) {
                instructions.filesToDelete.push(itemPath);
            }
        }
        item.queueDeleteFromDisk = false;
        item.queueWriteToDisk = false;
    });
    // add all the ancestor directories for each directory too
    for (let i = 0, ilen = instructions.dirsToEnsure.length; i < ilen; i++) {
        const segments = instructions.dirsToEnsure[i].split('/');
        for (let j = 2; j < segments.length; j++) {
            const dir = segments.slice(0, j).join('/');
            if (!instructions.dirsToEnsure.includes(dir)) {
                instructions.dirsToEnsure.push(dir);
            }
        }
    }
    // sort directories so shortest paths are ensured first
    instructions.dirsToEnsure.sort((a, b) => {
        const segmentsA = a.split('/').length;
        const segmentsB = b.split('/').length;
        if (segmentsA < segmentsB)
            return -1;
        if (segmentsA > segmentsB)
            return 1;
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
    // sort directories so longest paths are removed first
    instructions.dirsToDelete.sort((a, b) => {
        const segmentsA = a.split('/').length;
        const segmentsB = b.split('/').length;
        if (segmentsA < segmentsB)
            return 1;
        if (segmentsA > segmentsB)
            return -1;
        if (a.length < b.length)
            return 1;
        if (a.length > b.length)
            return -1;
        return 0;
    });
    instructions.dirsToEnsure.forEach(dirToEnsure => {
        const i = instructions.dirsToDelete.indexOf(dirToEnsure);
        if (i > -1) {
            instructions.dirsToDelete.splice(i, 1);
        }
    });
    instructions.dirsToDelete = instructions.dirsToDelete.filter(dir => {
        if (dir === '/' || dir.endsWith(':/')) {
            return false;
        }
        return true;
    });
    instructions.dirsToEnsure = instructions.dirsToEnsure.filter(dir => {
        if (d[dir] && d[dir].exists && d[dir].isDirectory) {
            return false;
        }
        if (dir === '/' || dir.endsWith(':/')) {
            return false;
        }
        return true;
    });
    return instructions;
}
function isTextFile(filePath) {
    filePath = filePath.toLowerCase().trim();
    return TXT_EXT.some(ext => filePath.endsWith(ext));
}
const TXT_EXT = [
    '.ts', '.tsx', '.js', '.jsx', '.svg',
    '.html', '.txt', '.md', '.markdown', '.json',
    '.css', '.scss', '.sass', '.less', '.styl'
];
function shouldIgnore(filePath) {
    filePath = filePath.trim().toLowerCase();
    return IGNORE.some(ignoreFile => filePath.endsWith(ignoreFile));
}
const IGNORE = [
    '.ds_store',
    '.gitignore',
    'desktop.ini',
    'thumbs.db'
];
// only cache if it's less than 5MB-ish (using .length as a rough guess)
// why 5MB? idk, seems like a good number for source text
// it's pretty darn large to cover almost ALL legitimate source files
// and anything larger is probably a REALLY large file and a rare case
// which we don't need to eat up memory for
const MAX_TEXT_CACHE = 5242880;
const IN_MEMORY_DIR = '__tmp__in__memory__';

function getCompilerCtx(config, compilerCtx) {
    // reusable data between builds
    compilerCtx = compilerCtx || {};
    compilerCtx.fs = compilerCtx.fs || new InMemoryFileSystem(config.sys.fs, config.sys.path);
    compilerCtx.cache = compilerCtx.cache || new Cache(config, new InMemoryFileSystem(config.sys.fs, config.sys.path), config.sys.tmpdir());
    compilerCtx.events = compilerCtx.events || new BuildEvents(config);
    compilerCtx.appFiles = compilerCtx.appFiles || {};
    compilerCtx.moduleFiles = compilerCtx.moduleFiles || {};
    compilerCtx.collections = compilerCtx.collections || [];
    compilerCtx.resolvedCollections = compilerCtx.resolvedCollections || [];
    compilerCtx.compiledModuleJsText = compilerCtx.compiledModuleJsText || {};
    compilerCtx.compiledModuleLegacyJsText = compilerCtx.compiledModuleLegacyJsText || {};
    if (typeof compilerCtx.activeBuildId !== 'number') {
        compilerCtx.activeBuildId = -1;
    }
    return compilerCtx;
}
function resetCompilerCtx(compilerCtx) {
    compilerCtx.fs.clearCache();
    compilerCtx.cache.clear();
    compilerCtx.appFiles = {};
    compilerCtx.moduleFiles = {};
    compilerCtx.collections.length = 0;
    compilerCtx.resolvedCollections.length = 0;
    compilerCtx.compiledModuleJsText = {};
    compilerCtx.compiledModuleLegacyJsText = {};
    // do NOT reset 'hasSuccessfulBuild'
}

function setBooleanConfig(config, configName, flagName, defaultValue) {
    if (flagName) {
        if (typeof config.flags[flagName] === 'boolean') {
            config[configName] = config.flags[flagName];
        }
    }
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = !!config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'boolean') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setNumberConfig(config, configName, _flagName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'number') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setStringConfig(config, configName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'string') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setArrayConfig(config, configName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (!Array.isArray(config[configName])) {
        if (Array.isArray(defaultValue)) {
            config[configName] = defaultValue.slice();
        }
        else {
            config[configName] = [];
        }
    }
}
function getUserConfigName(config, correctConfigName) {
    const userConfigNames = Object.keys(config);
    for (const userConfigName of userConfigNames) {
        if (userConfigName.toLowerCase() === correctConfigName.toLowerCase()) {
            if (userConfigName !== correctConfigName) {
                config.logger.warn(`config "${userConfigName}" should be "${correctConfigName}"`);
                return userConfigName;
            }
            break;
        }
    }
    return correctConfigName;
}

function validateAssetVerioning(config) {
    if (!config.assetVersioning) {
        config.assetVersioning = null;
        return;
    }
    if ((config.assetVersioning) === true) {
        config.assetVersioning = {};
    }
    const hashLength = config.hashedFileNameLength > 3 ? config.hashedFileNameLength : DEFAULTS.hashLength;
    setArrayConfig(config.assetVersioning, 'cssProperties', DEFAULTS.cssProperties);
    setNumberConfig(config.assetVersioning, 'hashLength', null, hashLength);
    setBooleanConfig(config.assetVersioning, 'queryMode', null, DEFAULTS.queryMode);
    setStringConfig(config.assetVersioning, 'prefix', DEFAULTS.separator);
    setStringConfig(config.assetVersioning, 'separator', DEFAULTS.separator);
    setBooleanConfig(config.assetVersioning, 'versionHtml', null, DEFAULTS.versionHtml);
    setBooleanConfig(config.assetVersioning, 'versionManifest', null, DEFAULTS.versionManifest);
    setBooleanConfig(config.assetVersioning, 'versionCssProperties', null, DEFAULTS.versionCssProperties);
}
const DEFAULTS = {
    cssProperties: ['background', 'background-url', 'url'],
    hashLength: 8,
    queryMode: false,
    pattern: '**/*.{css,js,png,jpg,jpeg,gif,svg,json,woff,woff2,ttf,eot}',
    prefix: '',
    separator: '.',
    versionHtml: true,
    versionManifest: true,
    versionCssProperties: true,
};

function validateCopy(config) {
    if (config.copy) {
        // merge user copy tasks into the default
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS, config.copy);
    }
    else if (config.copy === null || config.copy === false) {
        // manually forcing to skip the copy task
        config.copy = null;
    }
    else {
        // use the default copy tasks
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS);
    }
}
const DEFAULT_COPY_TASKS = {
    assets: { src: 'assets', warn: false },
    manifestJson: { src: 'manifest.json', warn: false }
};

function validateNamespace$1(config) {
    setStringConfig(config, 'namespace', DEFAULT_NAMESPACE);
    config.namespace = config.namespace.trim();
    const invalidNamespaceChars = config.namespace.replace(/(\w)|(\-)|(\$)/g, '');
    if (invalidNamespaceChars !== '') {
        throw new Error(`Namespace "${config.namespace}" contains invalid characters: ${invalidNamespaceChars}`);
    }
    if (config.namespace.length < 3) {
        throw new Error(`Namespace "${config.namespace}" must be at least 3 characters`);
    }
    if (/^\d+$/.test(config.namespace.charAt(0))) {
        throw new Error(`Namespace "${config.namespace}" cannot have a number for the first character`);
    }
    if (config.namespace.charAt(0) === '-') {
        throw new Error(`Namespace "${config.namespace}" cannot have a dash for the first character`);
    }
    if (config.namespace.charAt(config.namespace.length - 1) === '-') {
        throw new Error(`Namespace "${config.namespace}" cannot have a dash for the last character`);
    }
    // the file system namespace is the one
    // used in filenames and seen in the url
    setStringConfig(config, 'fsNamespace', config.namespace.toLowerCase());
    if (config.namespace.includes('-')) {
        // convert to PascalCase
        // this is the same namespace that gets put on "window"
        config.namespace = dashToPascalCase(config.namespace);
    }
}
const DEFAULT_NAMESPACE = 'App';

function validateDocs(config) {
    if (config.flags.docs || typeof config.flags.docsJson === 'string') {
        // docs flag
        config.outputTargets = config.outputTargets || [];
        if (!config.outputTargets.some(o => o.type === 'docs')) {
            // didn't provide a docs config, so let's add one
            const outputTarget = {
                type: 'docs'
            };
            if (typeof config.flags.docsJson === 'string') {
                outputTarget.jsonFile = config.flags.docsJson;
            }
            else if (config.flags.docs) {
                outputTarget.readmeDir = config.srcDir;
            }
            config.outputTargets.push(outputTarget);
        }
        config.outputTargets.forEach(outputTarget => {
            validateDocsOutputTarget(config, outputTarget);
        });
    }
    else {
        if (config.outputTargets) {
            // remove docs if there is no docs flag
            config.outputTargets = config.outputTargets.filter(o => o.type !== 'docs');
        }
    }
}
function validateDocsOutputTarget(config, outputTarget) {
    if (typeof outputTarget.readmeDir === 'string' && !config.sys.path.isAbsolute(outputTarget.readmeDir)) {
        outputTarget.readmeDir = pathJoin(config, config.rootDir, outputTarget.readmeDir);
    }
    if (typeof outputTarget.jsonFile === 'string') {
        outputTarget.jsonFile = pathJoin(config, config.rootDir, outputTarget.jsonFile);
    }
}

function validateOutputTargetAngular(config) {
    const path$$1 = config.sys.path;
    const distOutputTargets = config.outputTargets.filter(o => o.type === 'angular');
    distOutputTargets.forEach(outputTarget => {
        outputTarget.excludeComponents = outputTarget.excludeComponents || [];
        if (typeof outputTarget.appBuild !== 'boolean') {
            outputTarget.appBuild = true;
        }
        if (!outputTarget.dir) {
            outputTarget.dir = DEFAULT_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.dir)) {
            outputTarget.dir = normalizePath(path$$1.join(config.rootDir, outputTarget.dir));
        }
        if (!outputTarget.buildDir) {
            outputTarget.buildDir = DEFAULT_BUILD_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.buildDir)) {
            outputTarget.buildDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.buildDir));
        }
        if (!outputTarget.typesDir) {
            outputTarget.typesDir = DEFAULT_TYPES_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.typesDir)) {
            outputTarget.typesDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.typesDir));
        }
        if (typeof outputTarget.empty !== 'boolean') {
            outputTarget.empty = DEFAULT_EMPTY_DIR;
        }
        if (typeof outputTarget.appBuild !== 'boolean') {
            outputTarget.appBuild = true;
        }
        if (!path$$1.isAbsolute(outputTarget.directivesProxyFile)) {
            outputTarget.directivesProxyFile = normalizePath(path$$1.join(config.rootDir, outputTarget.directivesProxyFile));
        }
    });
}
const DEFAULT_DIR = 'dist';
const DEFAULT_BUILD_DIR = '';
const DEFAULT_EMPTY_DIR = true;
const DEFAULT_TYPES_DIR = 'types';

function validateOutputTargetDist(config) {
    const path$$1 = config.sys.path;
    const distOutputTargets = config.outputTargets.filter(o => o.type === 'dist');
    distOutputTargets.forEach(outputTarget => {
        if (!outputTarget.dir) {
            outputTarget.dir = DEFAULT_DIR$1;
        }
        if (!path$$1.isAbsolute(outputTarget.dir)) {
            outputTarget.dir = normalizePath(path$$1.join(config.rootDir, outputTarget.dir));
        }
        if (!outputTarget.buildDir) {
            outputTarget.buildDir = DEFAULT_BUILD_DIR$1;
        }
        if (!path$$1.isAbsolute(outputTarget.buildDir)) {
            outputTarget.buildDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.buildDir));
        }
        if (!outputTarget.collectionDir) {
            outputTarget.collectionDir = DEFAULT_COLLECTION_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.collectionDir)) {
            outputTarget.collectionDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.collectionDir));
        }
        if (!outputTarget.typesDir) {
            outputTarget.typesDir = DEFAULT_TYPES_DIR$1;
        }
        if (!path$$1.isAbsolute(outputTarget.typesDir)) {
            outputTarget.typesDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.typesDir));
        }
        if (typeof outputTarget.empty !== 'boolean') {
            outputTarget.empty = DEFAULT_EMPTY_DIR$1;
        }
        if (typeof outputTarget.appBuild !== 'boolean') {
            outputTarget.appBuild = true;
        }
    });
}
const DEFAULT_DIR$1 = 'dist';
const DEFAULT_BUILD_DIR$1 = '';
const DEFAULT_EMPTY_DIR$1 = true;
const DEFAULT_COLLECTION_DIR = 'collection';
const DEFAULT_TYPES_DIR$1 = 'types';

function validatePrerender(config, outputTarget) {
    let defaults;
    if (config.flags.prerender) {
        // forcing a prerender build
        defaults = FULL_PRERENDER_DEFAULTS;
    }
    else if (config.flags.ssr) {
        // forcing a ssr build
        defaults = SSR_DEFAULTS;
    }
    else {
        // not forcing a prerender build
        if (config.devMode) {
            // not forcing a prerender build
            // but we're in dev mode
            defaults = DEV_MODE_DEFAULTS;
        }
        else {
            // not forcing a prerender build
            // but we're in prod mode
            defaults = PROD_NON_HYDRATE_DEFAULTS;
        }
    }
    setStringConfig(outputTarget, 'baseUrl', defaults.baseUrl);
    setBooleanConfig(outputTarget, 'canonicalLink', null, defaults.canonicalLink);
    setBooleanConfig(outputTarget, 'collapseWhitespace', null, defaults.collapseWhitespace);
    setBooleanConfig(outputTarget, 'hydrateComponents', null, defaults.hydrateComponents);
    setBooleanConfig(outputTarget, 'inlineStyles', null, defaults.inlineStyles);
    setBooleanConfig(outputTarget, 'inlineLoaderScript', null, defaults.inlineLoaderScript);
    setNumberConfig(outputTarget, 'inlineAssetsMaxSize', null, defaults.inlineAssetsMaxSize);
    setBooleanConfig(outputTarget, 'prerenderUrlCrawl', null, defaults.prerenderUrlCrawl);
    setArrayConfig(outputTarget, 'prerenderLocations', defaults.prerenderLocations);
    setBooleanConfig(outputTarget, 'prerenderPathHash', null, defaults.prerenderPathHash);
    setBooleanConfig(outputTarget, 'prerenderPathQuery', null, defaults.prerenderPathQuery);
    setNumberConfig(outputTarget, 'prerenderMaxConcurrent', null, defaults.prerenderMaxConcurrent);
    setBooleanConfig(outputTarget, 'removeUnusedStyles', null, defaults.removeUnusedStyles);
    defaults.baseUrl = normalizePath(defaults.baseUrl);
    if (!outputTarget.baseUrl.startsWith('/')) {
        throw new Error(`baseUrl "${outputTarget.baseUrl}" must start with a slash "/". This represents an absolute path to the root of the domain.`);
    }
    if (!outputTarget.baseUrl.endsWith('/')) {
        outputTarget.baseUrl += '/';
    }
    if (config.flags.prerender && outputTarget.prerenderLocations.length === 0) {
        outputTarget.prerenderLocations.push({
            path: outputTarget.baseUrl
        });
    }
    if (outputTarget.hydrateComponents) {
        config.buildEs5 = true;
    }
}
const FULL_PRERENDER_DEFAULTS = {
    baseUrl: '/',
    canonicalLink: true,
    collapseWhitespace: true,
    hydrateComponents: true,
    inlineStyles: true,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 5000,
    prerenderUrlCrawl: true,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 4,
    removeUnusedStyles: true
};
const SSR_DEFAULTS = {
    baseUrl: '/',
    canonicalLink: true,
    collapseWhitespace: true,
    hydrateComponents: true,
    inlineStyles: true,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};
const PROD_NON_HYDRATE_DEFAULTS = {
    baseUrl: '/',
    canonicalLink: false,
    collapseWhitespace: true,
    hydrateComponents: false,
    inlineStyles: false,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};
const DEV_MODE_DEFAULTS = {
    baseUrl: '/',
    canonicalLink: false,
    collapseWhitespace: false,
    hydrateComponents: false,
    inlineStyles: false,
    inlineLoaderScript: false,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};

function validateOutputTargetWww(config) {
    if (!Array.isArray(config.outputTargets)) {
        config.outputTargets = [
            { type: 'www' }
        ];
    }
    const wwwOutputTargets = config.outputTargets.filter(o => o.type === 'www');
    wwwOutputTargets.forEach(outputTarget => {
        validateOutputTarget(config, outputTarget);
    });
}
function validateOutputTarget(config, outputTarget) {
    const path$$1 = config.sys.path;
    setStringConfig(outputTarget, 'dir', DEFAULT_DIR$2);
    if (!path$$1.isAbsolute(outputTarget.dir)) {
        outputTarget.dir = pathJoin(config, config.rootDir, outputTarget.dir);
    }
    setStringConfig(outputTarget, 'buildDir', DEFAULT_BUILD_DIR$2);
    if (!path$$1.isAbsolute(outputTarget.buildDir)) {
        outputTarget.buildDir = pathJoin(config, outputTarget.dir, outputTarget.buildDir);
    }
    setStringConfig(outputTarget, 'indexHtml', DEFAULT_INDEX_HTML);
    if (!path$$1.isAbsolute(outputTarget.indexHtml)) {
        outputTarget.indexHtml = pathJoin(config, outputTarget.dir, outputTarget.indexHtml);
    }
    setBooleanConfig(outputTarget, 'empty', null, DEFAULT_EMPTY_DIR$2);
    validatePrerender(config, outputTarget);
    if (typeof outputTarget.appBuild !== 'boolean') {
        outputTarget.appBuild = true;
    }
}
const DEFAULT_DIR$2 = 'www';
const DEFAULT_INDEX_HTML = 'index.html';
const DEFAULT_BUILD_DIR$2 = 'build';
const DEFAULT_EMPTY_DIR$2 = true;

function validateResourcesUrl(outputTarget) {
    if (typeof outputTarget.resourcesUrl === 'string') {
        outputTarget.resourcesUrl = normalizePath(outputTarget.resourcesUrl.trim());
        if (outputTarget.resourcesUrl.charAt(outputTarget.resourcesUrl.length - 1) !== '/') {
            // ensure there's a trailing /
            outputTarget.resourcesUrl += '/';
        }
    }
}

var __awaiter$13 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateHostConfig(config, compilerCtx, outputTarget, entryModules, hydrateResultss) {
    return __awaiter$13(this, void 0, void 0, function* () {
        const hostConfig = {
            hosting: {
                rules: []
            }
        };
        hydrateResultss = hydrateResultss.sort((a, b) => {
            if (a.url.toLowerCase() < b.url.toLowerCase())
                return -1;
            if (a.url.toLowerCase() > b.url.toLowerCase())
                return 1;
            return 0;
        });
        hydrateResultss.forEach(hydrateResults => {
            const hostRule = generateHostRule(config, compilerCtx, outputTarget, entryModules, hydrateResults);
            if (hostRule) {
                hostConfig.hosting.rules.push(hostRule);
            }
        });
        addDefaults(config, outputTarget, hostConfig);
        const hostConfigFilePath = pathJoin(config, outputTarget.dir, HOST_CONFIG_FILENAME);
        yield mergeUserHostConfigFile(config, compilerCtx, hostConfig);
        yield compilerCtx.fs.writeFile(hostConfigFilePath, JSON.stringify(hostConfig, null, 2));
    });
}
function generateHostRule(config, compilerCtx, outputTarget, entryModules, hydrateResults) {
    const hostRule = {
        include: hydrateResults.path,
        headers: generateHostRuleHeaders(config, compilerCtx, outputTarget, entryModules, hydrateResults)
    };
    if (hostRule.headers.length === 0) {
        return null;
    }
    return hostRule;
}
function generateHostRuleHeaders(config, compilerCtx, outputTarget, entryModules, hydrateResults) {
    const hostRuleHeaders = [];
    addStyles(config, hostRuleHeaders, hydrateResults);
    addCoreJs(config, outputTarget, compilerCtx.appCoreWWWPath, hostRuleHeaders);
    addBundles(config, outputTarget, entryModules, hostRuleHeaders, hydrateResults.components);
    addScripts(config, hostRuleHeaders, hydrateResults);
    addImgs(config, hostRuleHeaders, hydrateResults);
    return hostRuleHeaders;
}
function addCoreJs(config, outputTarget, appCoreWWWPath, hostRuleHeaders) {
    const url = getUrlFromFilePath(config, outputTarget, appCoreWWWPath);
    hostRuleHeaders.push(formatLinkRelPreloadHeader(url));
}
function addBundles(config, outputTarget, entryModules, hostRuleHeaders, components) {
    components = sortComponents(components);
    const bundleIds = getBundleIds(entryModules, components);
    bundleIds.forEach(bundleId => {
        if (hostRuleHeaders.length < MAX_LINK_REL_PRELOAD_COUNT) {
            const bundleUrl = getBundleUrl(config, outputTarget, bundleId);
            hostRuleHeaders.push(formatLinkRelPreloadHeader(bundleUrl));
        }
    });
}
function getBundleIds(entryModules, components) {
    const bundleIds = [];
    components.forEach(cmp => {
        entryModules.forEach(mb => {
            const moduleFile = mb.moduleFiles.find(mf => mf.cmpMeta && mf.cmpMeta.tagNameMeta === cmp.tag);
            if (!moduleFile) {
                return;
            }
            let bundleId;
            if (typeof moduleFile.cmpMeta.bundleIds === 'string') {
                bundleId = moduleFile.cmpMeta.bundleIds;
            }
            else {
                bundleId = moduleFile.cmpMeta.bundleIds[DEFAULT_MODE];
                if (!bundleId) {
                    bundleId = moduleFile.cmpMeta.bundleIds[DEFAULT_STYLE_MODE];
                }
            }
            if (bundleId && bundleIds.indexOf(bundleId) === -1) {
                bundleIds.push(bundleId);
            }
        });
    });
    return bundleIds;
}
function getBundleUrl(config, outputTarget, bundleId) {
    const unscopedFileName = getBrowserFilename(bundleId, false);
    const unscopedWwwBuildPath = pathJoin(config, getAppBuildDir(config, outputTarget), unscopedFileName);
    return getUrlFromFilePath(config, outputTarget, unscopedWwwBuildPath);
}
function getUrlFromFilePath(config, outputTarget, filePath) {
    let url = pathJoin(config, '/', config.sys.path.relative(outputTarget.dir, filePath));
    url = outputTarget.baseUrl + url.substring(1);
    return url;
}
function sortComponents(components) {
    return components.sort((a, b) => {
        if (a.depth > b.depth)
            return -1;
        if (a.depth < b.depth)
            return 1;
        if (a.count > b.count)
            return -1;
        if (a.count < b.count)
            return 1;
        if (a.tag < b.tag)
            return -1;
        if (a.tag > b.tag)
            return 1;
        return 0;
    });
}
function addStyles(config, hostRuleHeaders, hydrateResults) {
    hydrateResults.styleUrls.forEach(styleUrl => {
        if (hostRuleHeaders.length >= MAX_LINK_REL_PRELOAD_COUNT) {
            return;
        }
        const url = config.sys.url.parse(styleUrl);
        if (url.hostname === hydrateResults.hostname) {
            hostRuleHeaders.push(formatLinkRelPreloadHeader(url.path));
        }
    });
}
function addScripts(config, hostRuleHeaders, hydrateResults) {
    hydrateResults.scriptUrls.forEach(scriptUrl => {
        if (hostRuleHeaders.length >= MAX_LINK_REL_PRELOAD_COUNT) {
            return;
        }
        const url = config.sys.url.parse(scriptUrl);
        if (url.hostname === hydrateResults.hostname) {
            hostRuleHeaders.push(formatLinkRelPreloadHeader(url.path));
        }
    });
}
function addImgs(config, hostRuleHeaders, hydrateResults) {
    hydrateResults.imgUrls.forEach(imgUrl => {
        if (hostRuleHeaders.length >= MAX_LINK_REL_PRELOAD_COUNT) {
            return;
        }
        const url = config.sys.url.parse(imgUrl);
        if (url.hostname === hydrateResults.hostname) {
            hostRuleHeaders.push(formatLinkRelPreloadHeader(url.path));
        }
    });
}
function formatLinkRelPreloadHeader(url) {
    const header = {
        name: 'Link',
        value: formatLinkRelPreloadValue(url)
    };
    return header;
}
function formatLinkRelPreloadValue(url) {
    const parts = [
        `<${url}>`,
        `rel=preload`
    ];
    const ext = url.split('.').pop().toLowerCase();
    if (ext === SCRIPT_EXT) {
        parts.push(`as=script`);
    }
    else if (ext === STYLE_EXT) {
        parts.push(`as=style`);
    }
    else if (IMG_EXTS.indexOf(ext) > -1) {
        parts.push(`as=image`);
    }
    return parts.join(';');
}
function addDefaults(config, outputTarget, hostConfig) {
    addBuildDirCacheControl(config, outputTarget, hostConfig);
    addServiceWorkerNoCacheControl(config, outputTarget, hostConfig);
}
function addBuildDirCacheControl(config, outputTarget, hostConfig) {
    const url = getUrlFromFilePath(config, outputTarget, getAppBuildDir(config, outputTarget));
    hostConfig.hosting.rules.push({
        include: pathJoin(config, url, '**'),
        headers: [
            {
                name: `Cache-Control`,
                value: `public, max-age=31536000`
            }
        ]
    });
}
function addServiceWorkerNoCacheControl(config, outputTarget, hostConfig) {
    if (!outputTarget.serviceWorker) {
        return;
    }
    const url = getUrlFromFilePath(config, outputTarget, outputTarget.serviceWorker.swDest);
    hostConfig.hosting.rules.push({
        include: url,
        headers: [
            {
                name: `Cache-Control`,
                value: `no-cache, no-store, must-revalidate`
            }
        ]
    });
}
function mergeUserHostConfigFile(config, compilerCtx, hostConfig) {
    return __awaiter$13(this, void 0, void 0, function* () {
        const hostConfigFilePath = pathJoin(config, config.srcDir, HOST_CONFIG_FILENAME);
        try {
            const userHostConfigStr = yield compilerCtx.fs.readFile(hostConfigFilePath);
            const userHostConfig = JSON.parse(userHostConfigStr);
            mergeUserHostConfig(userHostConfig, hostConfig);
        }
        catch (e) { }
    });
}
function mergeUserHostConfig(userHostConfig, hostConfig) {
    if (!userHostConfig || !userHostConfig.hosting) {
        return;
    }
    if (!Array.isArray(userHostConfig.hosting.rules)) {
        return;
    }
    const rules = userHostConfig.hosting.rules.concat(hostConfig.hosting.rules);
    hostConfig.hosting.rules = rules;
}
const DEFAULT_MODE = 'md';
const MAX_LINK_REL_PRELOAD_COUNT = 6;
const HOST_CONFIG_FILENAME = 'host.config.json';
const IMG_EXTS = ['png', 'gif', 'svg', 'jpg', 'jpeg', 'webp'];
const STYLE_EXT = 'css';
const SCRIPT_EXT = 'js';

function validateServiceWorker(config, outputTarget) {
    if (config.devMode) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (outputTarget.serviceWorker === false || outputTarget.serviceWorker === null) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (!outputTarget.serviceWorker && outputTarget.type !== 'www') {
        outputTarget.serviceWorker = null;
        return;
    }
    if (outputTarget.serviceWorker === true) {
        outputTarget.serviceWorker = {};
    }
    else if (!outputTarget.serviceWorker && config.devMode) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (typeof outputTarget.serviceWorker !== 'object') {
        // what was passed in could have been a boolean
        // in that case let's just turn it into an empty obj so Object.assign doesn't crash
        outputTarget.serviceWorker = {};
    }
    if (!Array.isArray(outputTarget.serviceWorker.globPatterns)) {
        if (typeof outputTarget.serviceWorker.globPatterns === 'string') {
            outputTarget.serviceWorker.globPatterns = [outputTarget.serviceWorker.globPatterns];
        }
        else if (typeof outputTarget.serviceWorker.globPatterns !== 'string') {
            outputTarget.serviceWorker.globPatterns = [DEFAULT_GLOB_PATTERNS];
        }
    }
    if (typeof outputTarget.serviceWorker.globDirectory !== 'string') {
        outputTarget.serviceWorker.globDirectory = outputTarget.dir;
    }
    if (typeof outputTarget.serviceWorker.globIgnores === 'string') {
        outputTarget.serviceWorker.globIgnores = [outputTarget.serviceWorker.globIgnores];
    }
    outputTarget.serviceWorker.globIgnores = outputTarget.serviceWorker.globIgnores || [];
    addGlobIgnores(config, outputTarget.serviceWorker.globIgnores);
    if (!outputTarget.serviceWorker.swDest) {
        outputTarget.serviceWorker.swDest = config.sys.path.join(outputTarget.dir, DEFAULT_FILENAME);
    }
    if (!config.sys.path.isAbsolute(outputTarget.serviceWorker.swDest)) {
        outputTarget.serviceWorker.swDest = config.sys.path.join(outputTarget.dir, outputTarget.serviceWorker.swDest);
    }
}
function addGlobIgnores(config, globIgnores) {
    const appRegistry = `**/${getRegistryFileName(config)}`;
    globIgnores.push(appRegistry);
    const appGlobal = `**/${getGlobalFileName(config)}`;
    globIgnores.push(appGlobal);
    const hostConfigJson = `**/${HOST_CONFIG_FILENAME}`;
    globIgnores.push(hostConfigJson);
}
const DEFAULT_GLOB_PATTERNS = '**/*.{js,css,json,html,ico,png,svg}';
const DEFAULT_FILENAME = 'sw.js';

function validateStats(config) {
    if (config.flags.stats) {
        const hasOutputTarget = config.outputTargets.some(o => o.type === 'stats');
        if (!hasOutputTarget) {
            config.outputTargets.push({
                type: 'stats'
            });
        }
    }
    const outputTargets = config.outputTargets.filter(o => o.type === 'stats');
    outputTargets.forEach(outputTarget => {
        validateStatsOutputTarget(config, outputTarget);
    });
}
function validateStatsOutputTarget(config, outputTarget) {
    if (!outputTarget.file) {
        outputTarget.file = DEFAULT_JSON_FILE_NAME;
    }
    if (!config.sys.path.isAbsolute(outputTarget.file)) {
        outputTarget.file = pathJoin(config, config.rootDir, outputTarget.file);
    }
}
const DEFAULT_JSON_FILE_NAME = 'stencil-stats.json';

/**
 * DEPRECATED "config" generateWWW, wwwDir, emptyWWW, generateDistribution, distDir, emptyDist
 * since 0.7.0, 2018-03-02
 */
function _deprecatedToMultipleTarget(config) {
    const deprecatedConfigs = [];
    if (config.generateWWW !== undefined) {
        deprecatedConfigs.push('generateWWW');
        if (config.generateWWW) {
            config.outputTargets = config.outputTargets || [];
            let o = config.outputTargets.find(o => o.type === 'www');
            if (!o) {
                o = { type: 'www' };
                config.outputTargets.push(o);
            }
        }
        delete config.generateWWW;
    }
    if (config.emptyWWW !== undefined) {
        deprecatedConfigs.push('emptyWWW');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.empty = !!config.emptyWWW;
        delete config.emptyWWW;
    }
    if (config.wwwDir !== undefined) {
        deprecatedConfigs.push('wwwDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.dir = config.wwwDir;
        delete config.wwwDir;
    }
    if (config.buildDir !== undefined) {
        deprecatedConfigs.push('buildDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.buildDir = config.buildDir;
        delete config.buildDir;
    }
    if (config.wwwIndexHtml !== undefined) {
        deprecatedConfigs.push('wwwIndexHtml');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.indexHtml = config.wwwIndexHtml;
        delete config.wwwIndexHtml;
    }
    if (config.generateDistribution !== undefined) {
        deprecatedConfigs.push('generateDistribution');
        if (config.generateDistribution) {
            config.outputTargets = config.outputTargets || [];
            let o = config.outputTargets.find(o => o.type === 'dist');
            if (!o) {
                o = { type: 'dist' };
                config.outputTargets.push(o);
            }
        }
        delete config.generateDistribution;
    }
    if (config.distDir !== undefined) {
        deprecatedConfigs.push('distDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.distDir;
        delete config.distDir;
    }
    if (config.emptyDist !== undefined) {
        deprecatedConfigs.push('emptyDist');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.empty = !!config.emptyDist;
        delete config.emptyDist;
    }
    if (config.collectionDir !== undefined) {
        deprecatedConfigs.push('collectionDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.collectionDir;
        delete config.collectionDir;
    }
    if (config.typesDir !== undefined) {
        deprecatedConfigs.push('typesDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.typesDir;
        delete config.typesDir;
    }
    if (config.publicPath !== undefined) {
        deprecatedConfigs.push('publicPath');
        config.outputTargets = config.outputTargets || [];
        const www = config.outputTargets.find(o => o.type === 'www');
        if (www) {
            www.resourcesUrl = config.publicPath;
        }
        delete config.publicPath;
    }
    if (config.serviceWorker !== undefined) {
        deprecatedConfigs.push('serviceWorker');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www', serviceWorker: config.serviceWorker };
            config.outputTargets.push(o);
        }
        else {
            o.serviceWorker = config.serviceWorker;
        }
        delete config.serviceWorker;
    }
    if (config.prerender !== undefined) {
        deprecatedConfigs.push('prerender');
        delete config.prerender;
    }
    if (deprecatedConfigs.length > 0) {
        const warningMsg = [
            `As of v0.7.0, the config `,
            deprecatedConfigs.length > 1 ? `properties ` : `property `,
            `"${deprecatedConfigs.join(', ')}" `,
            deprecatedConfigs.length > 1 ? `have ` : `has `,
            `been deprecated in favor of a multiple output target configuration. `,
            `Please use the "outputTargets" config which `,
            `is an array of output targets. `,
            `Note that not having an "outputTarget" config will default `,
            `to have an { type: "www" } output target. `,
            `More information aobut the new format can be found here: https://stenciljs.com/docs/config`
        ];
        config.logger.warn(warningMsg.join(''));
    }
    return deprecatedConfigs;
}

function validateOutputTargets(config) {
    // setup outputTargets from deprecated config properties
    _deprecatedToMultipleTarget(config);
    if (Array.isArray(config.outputTargets)) {
        config.outputTargets.forEach(outputTarget => {
            if (typeof outputTarget.type !== 'string') {
                outputTarget.type = 'www';
            }
            outputTarget.type = outputTarget.type.trim().toLowerCase();
            if (!VALID_TYPES.includes(outputTarget.type)) {
                throw new Error(`invalid outputTarget type "${outputTarget.type}". Valid target types: ${VALID_TYPES.join(', ')}`);
            }
        });
    }
    validateOutputTargetWww(config);
    validateOutputTargetDist(config);
    validateOutputTargetAngular(config);
    validateDocs(config);
    validateStats(config);
    if (!config.outputTargets || config.outputTargets.length === 0) {
        throw new Error(`outputTarget required`);
    }
    config.outputTargets.forEach(outputTarget => {
        validateResourcesUrl(outputTarget);
        validateServiceWorker(config, outputTarget);
    });
}
const VALID_TYPES = ['angular', 'dist', 'docs', 'stats', 'www'];

function validatePaths(config) {
    const path$$1 = config.sys.path;
    if (typeof config.global === 'string') {
        // deprecated: 2017-12-12
        config.logger.warn(`stencil config property "global" has been renamed to "globalScript"`);
        config.globalScript = config.global;
    }
    if (typeof config.globalScript === 'string' && !path$$1.isAbsolute(config.globalScript)) {
        config.globalScript = normalizePath(path$$1.join(config.rootDir, config.globalScript));
    }
    if (typeof config.globalStyle === 'string') {
        config.globalStyle = [config.globalStyle];
    }
    if (Array.isArray(config.globalStyle)) {
        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === 'string');
        config.globalStyle = config.globalStyle.map(globalStyle => {
            if (path$$1.isAbsolute(globalStyle)) {
                return normalizePath(globalStyle);
            }
            return normalizePath(path$$1.join(config.rootDir, globalStyle));
        });
    }
    setStringConfig(config, 'srcDir', DEFAULT_SRC_DIR);
    if (!path$$1.isAbsolute(config.srcDir)) {
        config.srcDir = normalizePath(path$$1.join(config.rootDir, config.srcDir));
    }
    setStringConfig(config, 'tsconfig', DEFAULT_TSCONFIG);
    if (!path$$1.isAbsolute(config.tsconfig)) {
        config.tsconfig = normalizePath(path$$1.join(config.rootDir, config.tsconfig));
    }
    setStringConfig(config, 'srcIndexHtml', normalizePath(path$$1.join(config.srcDir, DEFAULT_INDEX_HTML$1)));
    if (!path$$1.isAbsolute(config.srcIndexHtml)) {
        config.srcIndexHtml = normalizePath(path$$1.join(config.rootDir, config.srcIndexHtml));
    }
    if (config.writeLog) {
        setStringConfig(config, 'buildLogFilePath', DEFAULT_BUILD_LOG_FILE_NAME);
        if (!path$$1.isAbsolute(config.buildLogFilePath)) {
            config.buildLogFilePath = normalizePath(path$$1.join(config.rootDir, config.buildLogFilePath));
        }
        config.logger.buildLogFilePath = config.buildLogFilePath;
    }
}
const DEFAULT_INDEX_HTML$1 = 'index.html';
const DEFAULT_SRC_DIR = 'src';
const DEFAULT_TSCONFIG = 'tsconfig.json';
const DEFAULT_BUILD_LOG_FILE_NAME = 'stencil-build.log';

function validatePlugins(config) {
    config.plugins = (config.plugins || []).filter(p => !!p);
}

/**
 * DEPRECATED "config.collections" since 0.6.0, 2018-02-13
 */
function _deprecatedValidateConfigCollections(config) {
    if (Array.isArray(config.collections)) {
        config._deprecatedCollections = config.collections;
    }
    else {
        config._deprecatedCollections = [];
    }
    config._deprecatedCollections = config._deprecatedCollections.map(_deprecatedValidateConfigCollection);
    if (config._deprecatedCollections.length > 0) {
        const warningMsg = [
            `As of v0.6.0, "config.collections" has been deprecated in favor of standard ES module imports. `,
            `Instead of listing collections within the stencil config, collections should now be `,
            `imported by the app's root component or module. The benefit of this is to not only simplify `,
            `the config by using a standards approach for imports, but to also automatically import the `,
            `collection's types to improve development. Please remove "config.collections" `,
            `from the "stencil.config.js" file, and add `,
            config._deprecatedCollections.length === 1 ? `this import ` : `these imports `,
            `to your root component or root module:  `
        ];
        config._deprecatedCollections.forEach(collection => {
            warningMsg.push(`import '${collection.name}';  `);
        });
        config.logger.warn(warningMsg.join(''));
    }
}
function _deprecatedValidateConfigCollection(userInput) {
    if (!userInput || Array.isArray(userInput) || typeof userInput === 'number' || typeof userInput === 'boolean') {
        throw new Error(`invalid collection: ${userInput}`);
    }
    let configCollection;
    if (typeof userInput === 'string') {
        configCollection = {
            name: userInput
        };
    }
    else {
        configCollection = userInput;
    }
    if (!configCollection.name || typeof configCollection.name !== 'string' || configCollection.name.trim() === '') {
        throw new Error(`missing collection name`);
    }
    configCollection.name = configCollection.name.trim();
    return configCollection;
}

function validateConfig(config, setEnvVariables) {
    if (!config) {
        throw new Error(`invalid build config`);
    }
    if (config._isValidated) {
        // don't bother if we've already validated this config
        return config;
    }
    if (!config.logger) {
        throw new Error(`config.logger required`);
    }
    if (!config.rootDir) {
        throw new Error('config.rootDir required');
    }
    if (!config.sys) {
        throw new Error('config.sys required');
    }
    config.flags = config.flags || {};
    if (config.flags.debug) {
        config.logLevel = 'debug';
    }
    else if (config.flags.logLevel) {
        config.logLevel = config.flags.logLevel;
    }
    else if (typeof config.logLevel !== 'string') {
        config.logLevel = 'info';
    }
    config.logger.level = config.logLevel;
    setBooleanConfig(config, 'writeLog', 'log', false);
    setBooleanConfig(config, 'buildAppCore', null, true);
    // default devMode false
    if (config.flags.prod) {
        config.devMode = false;
    }
    else if (config.flags.dev) {
        config.devMode = true;
    }
    else {
        setBooleanConfig(config, 'devMode', null, DEFAULT_DEV_MODE);
    }
    // get a good namespace
    validateNamespace$1(config);
    // figure out all of the config paths and absolute paths
    validatePaths(config);
    // setup the outputTargets
    validateOutputTargets(config);
    // default devInspector to whatever devMode is
    setBooleanConfig(config, 'devInspector', null, config.devMode);
    // default watch false
    setBooleanConfig(config, 'watch', 'watch', false);
    setBooleanConfig(config, 'minifyCss', null, !config.devMode);
    setBooleanConfig(config, 'minifyJs', null, !config.devMode);
    config.logger.debug(`minifyJs: ${config.minifyJs}, minifyCss: ${config.minifyCss}`);
    setBooleanConfig(config, 'buildEs5', 'es5', !config.devMode);
    setBooleanConfig(config, 'hashFileNames', null, !(config.devMode || config.watch));
    setNumberConfig(config, 'hashedFileNameLength', null, DEFAULT_HASHED_FILENAME_LENTH);
    if (config.hashFileNames) {
        if (config.hashedFileNameLength < MIN_HASHED_FILENAME_LENTH) {
            throw new Error(`config.hashedFileNameLength must be at least ${MIN_HASHED_FILENAME_LENTH} characters`);
        }
        if (config.hashedFileNameLength > MAX_HASHED_FILENAME_LENTH) {
            throw new Error(`config.hashedFileNameLength cannot be more than ${MAX_HASHED_FILENAME_LENTH} characters`);
        }
    }
    config.logger.debug(`hashFileNames: ${config.hashFileNames}, hashedFileNameLength: ${config.hashedFileNameLength}`);
    validateCopy(config);
    validatePlugins(config);
    validateAssetVerioning(config);
    if (!config.watchIgnoredRegex) {
        config.watchIgnoredRegex = DEFAULT_WATCH_IGNORED_REGEX;
    }
    setStringConfig(config, 'hydratedCssClass', DEFAULT_HYDRATED_CSS_CLASS);
    setBooleanConfig(config, 'generateDocs', 'docs', false);
    setBooleanConfig(config, 'enableCache', 'cache', true);
    if (!Array.isArray(config.includeSrc)) {
        config.includeSrc = DEFAULT_INCLUDES.map(include => {
            return config.sys.path.join(config.srcDir, include);
        });
    }
    if (!Array.isArray(config.excludeSrc)) {
        config.excludeSrc = DEFAULT_EXCLUDES.slice();
    }
    /**
     * DEPRECATED "config.collections" since 0.6.0, 2018-02-13
     */
    _deprecatedValidateConfigCollections(config);
    setArrayConfig(config, 'plugins');
    setArrayConfig(config, 'bundles');
    // set to true so it doesn't bother going through all this again on rebuilds
    config._isValidated = true;
    config.logger.debug(`validated build config`);
    if (setEnvVariables !== false) {
        setProcessEnvironment(config);
    }
    return config;
}
function setProcessEnvironment(config) {
    process.env.NODE_ENV = config.devMode ? 'development' : 'production';
}
const DEFAULT_DEV_MODE = false;
const DEFAULT_HASHED_FILENAME_LENTH = 8;
const MIN_HASHED_FILENAME_LENTH = 4;
const MAX_HASHED_FILENAME_LENTH = 32;
const DEFAULT_INCLUDES = ['**/*.ts', '**/*.tsx'];
const DEFAULT_EXCLUDES = ['**/test/**', '**/*.spec.*'];
const DEFAULT_WATCH_IGNORED_REGEX = /(?:^|[\\\/])(\.(?!\.)[^\\\/]+)$/i;
const DEFAULT_HYDRATED_CSS_CLASS = 'hydrated';

function configFileReload(config, compilerCtx) {
    config.logger.debug(`reload config file: ${config.configPath}`);
    try {
        const updatedConfig = config.sys.loadConfigFile(config.configPath);
        // empty it out cuz we're gonna use the same object
        // but don't remove our keepers, we still need them
        for (const key in config) {
            if (!CONFIG_RELOAD_KEEPER_KEYS.includes(key)) {
                delete config[key];
            }
        }
        // fill it up with the newly loaded config
        // but don't touch our "keepers"
        for (const key in updatedConfig) {
            if (!CONFIG_RELOAD_KEEPER_KEYS.includes(key)) {
                config[key] = updatedConfig[key];
            }
        }
        // validate our new config data
        validateConfig(config);
        // reset the compiler context cache
        resetCompilerCtx(compilerCtx);
    }
    catch (e) {
        config.logger.error(e);
    }
}
// stuff that should be constant between config updates
// implementing the Config interface to make sure we're
// using the correct keys, but the value doesn't matter here
const CONFIG_RELOAD_KEEPERS = {
    sys: null,
    logger: null,
    devMode: null,
    watch: null,
    outputTargets: null
};
const CONFIG_RELOAD_KEEPER_KEYS = Object.keys(CONFIG_RELOAD_KEEPERS);

function rebuild(config, compilerCtx, watcher) {
    // print out a pretty message about the changed files
    printWatcherMessage(config, watcher);
    if (watcher.configUpdated) {
        configFileReload(config, compilerCtx);
    }
    // kick off the rebuild
    return build(config, compilerCtx, watcher);
}
function printWatcherMessage(config, watcherResults) {
    const changedFiles = watcherResults.filesChanged;
    const totalChangedFiles = changedFiles.length;
    let msg = null;
    if (totalChangedFiles > 6) {
        const trimmedChangedFiles = changedFiles.slice(0, 5);
        const otherFilesTotal = totalChangedFiles - trimmedChangedFiles.length;
        msg = `changed files: ${trimmedChangedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
        if (otherFilesTotal > 0) {
            msg += `, +${otherFilesTotal} other${otherFilesTotal > 1 ? 's' : ''}`;
        }
    }
    else if (totalChangedFiles > 1) {
        msg = `changed files: ${changedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    else if (totalChangedFiles > 0) {
        msg = `changed file: ${changedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    else if (watcherResults.dirsAdded.length > 1) {
        msg = `added directories: ${watcherResults.dirsAdded.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    else if (watcherResults.dirsAdded.length > 0) {
        msg = `added directory: ${watcherResults.dirsAdded.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    else if (watcherResults.dirsDeleted.length > 1) {
        msg = `deleted directories: ${watcherResults.dirsAdded.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    else if (watcherResults.dirsDeleted.length > 0) {
        msg = `deleted directory: ${watcherResults.dirsAdded.map(f => config.sys.path.basename(f)).join(', ')}`;
    }
    if (msg != null) {
        config.logger.info(config.logger.cyan(msg));
    }
}

var __awaiter$14 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class WatcherListener {
    constructor(config, compilerCtx) {
        this.config = config;
        this.compilerCtx = compilerCtx;
        this.configUpdated = false;
        this.recentChanges = [];
        this.resetWatcher();
    }
    subscribe() {
        this.compilerCtx.events.subscribe('fileUpdate', this.fileUpdate.bind(this));
        this.compilerCtx.events.subscribe('fileAdd', this.fileAdd.bind(this));
        this.compilerCtx.events.subscribe('fileDelete', this.fileDelete.bind(this));
        this.compilerCtx.events.subscribe('dirAdd', this.dirAdd.bind(this));
        this.compilerCtx.events.subscribe('dirDelete', this.dirDelete.bind(this));
    }
    fileUpdate(path$$1) {
        return __awaiter$14(this, void 0, void 0, function* () {
            try {
                path$$1 = normalizePath(path$$1);
                this.config.logger.debug(`watcher, fileUpdate: ${path$$1}, ${Date.now()}`);
                if (path$$1 === this.config.configPath) {
                    // the actual stencil config file changed
                    // this is a big deal, so do a full rebuild
                    this.configUpdated = true;
                    if (!this.filesUpdated.includes(path$$1)) {
                        this.filesUpdated.push(path$$1);
                    }
                    this.queue(path$$1);
                }
                else if (isCopyTaskFile(this.config, path$$1)) {
                    this.queueCopyTasks();
                }
                if (isWebDevFileToWatch(path$$1)) {
                    // read the file, but without using
                    // the cache so we get the latest change
                    yield this.compilerCtx.fs.readFile(path$$1, { useCache: false });
                    // web dev file was updaed
                    // queue change build
                    if (!this.filesUpdated.includes(path$$1)) {
                        this.filesUpdated.push(path$$1);
                    }
                    this.queue(path$$1);
                }
                else {
                    // always clear the cache if it wasn't a web dev file
                    this.compilerCtx.fs.clearFileCache(path$$1);
                    this.config.logger.debug(`clear file cache: ${path$$1}`);
                }
            }
            catch (e) {
                this.config.logger.error(`watcher, fileUpdate`, e);
            }
        });
    }
    fileAdd(path$$1) {
        return __awaiter$14(this, void 0, void 0, function* () {
            try {
                path$$1 = normalizePath(path$$1);
                this.config.logger.debug(`watcher, fileAdd: ${path$$1}, ${Date.now()}`);
                if (isCopyTaskFile(this.config, path$$1)) {
                    this.queueCopyTasks();
                }
                if (isWebDevFileToWatch(path$$1)) {
                    // read the file, but without using
                    // the cache so we get the latest change
                    yield this.compilerCtx.fs.readFile(path$$1, { useCache: false });
                    // new web dev file was added
                    if (!this.filesAdded.includes(path$$1)) {
                        this.filesAdded.push(path$$1);
                    }
                    this.queue(path$$1);
                }
                else {
                    // always clear the cache if it wasn't a web dev file
                    this.compilerCtx.fs.clearFileCache(path$$1);
                    this.config.logger.debug(`clear file cache: ${path$$1}`);
                }
            }
            catch (e) {
                this.config.logger.error(`watcher, fileAdd`, e);
            }
        });
    }
    fileDelete(path$$1) {
        try {
            path$$1 = normalizePath(path$$1);
            this.config.logger.debug(`watcher, fileDelete: ${path$$1}, ${Date.now()}`);
            // clear this file's cache
            this.compilerCtx.fs.clearFileCache(path$$1);
            if (isCopyTaskFile(this.config, path$$1)) {
                this.queueCopyTasks();
            }
            if (isWebDevFileToWatch(path$$1)) {
                // web dev file was delete
                if (!this.filesDeleted.includes(path$$1)) {
                    this.filesDeleted.push(path$$1);
                }
                this.queue(path$$1);
            }
        }
        catch (e) {
            this.config.logger.error(`watcher, fileDelete`, e);
        }
    }
    dirAdd(path$$1) {
        return __awaiter$14(this, void 0, void 0, function* () {
            try {
                path$$1 = normalizePath(path$$1);
                this.config.logger.debug(`watcher, dirAdd: ${path$$1}, ${Date.now()}`);
                // clear this directory's cache for good measure
                this.compilerCtx.fs.clearDirCache(path$$1);
                if (isCopyTaskFile(this.config, path$$1)) {
                    this.queueCopyTasks();
                }
                else {
                    // recursively drill down and get all of the
                    // files paths that were just added
                    const addedItems = yield this.compilerCtx.fs.readdir(path$$1, { recursive: true });
                    addedItems.forEach(item => {
                        if (!this.filesAdded.includes(item.absPath)) {
                            this.filesAdded.push(item.absPath);
                        }
                    });
                    this.dirsAdded.push(path$$1);
                    this.queue(path$$1);
                }
            }
            catch (e) {
                this.config.logger.error(`watcher, dirAdd`, e);
            }
        });
    }
    dirDelete(path$$1) {
        return __awaiter$14(this, void 0, void 0, function* () {
            try {
                path$$1 = normalizePath(path$$1);
                this.config.logger.debug(`watcher, dirDelete: ${path$$1}, ${Date.now()}`);
                // clear this directory's cache
                this.compilerCtx.fs.clearDirCache(path$$1);
                if (isCopyTaskFile(this.config, path$$1)) {
                    this.queueCopyTasks();
                }
                else {
                    if (!this.dirsDeleted.includes(path$$1)) {
                        this.dirsDeleted.push(path$$1);
                    }
                    this.queue(path$$1);
                }
            }
            catch (e) {
                this.config.logger.error(`watcher, dirDelete`, e);
            }
        });
    }
    startRebuild() {
        try {
            // create a copy of all that we've learned today
            const watcher = this.generateWatcherResults();
            // reset the watcher data for next time
            this.resetWatcher();
            if (shouldRebuild(watcher)) {
                // kick off the rebuild
                rebuild(this.config, this.compilerCtx, watcher);
            }
        }
        catch (e) {
            this.config.logger.error(`watcher, startRebuild`, e);
        }
    }
    generateWatcherResults() {
        const watcher = {
            dirsAdded: this.dirsAdded.slice(),
            dirsDeleted: this.dirsDeleted.slice(),
            filesAdded: this.filesAdded.slice(),
            filesDeleted: this.filesDeleted.slice(),
            filesUpdated: this.filesUpdated.slice(),
            filesChanged: this.filesUpdated.concat(this.filesAdded, this.filesDeleted),
            configUpdated: this.configUpdated
        };
        return watcher;
    }
    queue(path$$1) {
        this.recentChanges = this.recentChanges.filter(rc => {
            // only keep changes that happened in the last XX milliseconds
            return (Date.now() - 2000) < rc.timestamp;
        });
        if (this.recentChanges.some(rc => rc.filePath === path$$1)) {
            // we already kicked off a build for this path
            // within the last XX milliseconds, let's just ignore the subsequent changes
            this.config.logger.debug(`skipping recent subsequent file change: ${path$$1}`);
            return;
        }
        // debounce builds
        clearTimeout(this.watchTmr);
        this.recentChanges.push({
            filePath: path$$1,
            timestamp: Date.now()
        });
        this.watchTmr = setTimeout(() => {
            this.startRebuild();
        }, 20);
    }
    queueCopyTasks() {
        clearTimeout(this.copyTaskTmr);
        this.copyTaskTmr = setTimeout(() => __awaiter$14(this, void 0, void 0, function* () {
            yield copyTasks(this.config, this.compilerCtx, [], true);
        }), 100);
    }
    resetWatcher() {
        this.dirsAdded = [];
        this.dirsDeleted = [];
        this.filesAdded = [];
        this.filesDeleted = [];
        this.filesUpdated = [];
        this.configUpdated = false;
    }
}
function shouldRebuild(watcher) {
    return watcher.configUpdated ||
        watcher.dirsAdded.length > 0 ||
        watcher.dirsDeleted.length > 0 ||
        watcher.filesAdded.length > 0 ||
        watcher.filesDeleted.length > 0 ||
        watcher.filesUpdated.length > 0;
}
function isWebDevFileToWatch(filePath) {
    // ts, tsx, css, scss, js, html
    // but don't worry about jpg, png, gif, svgs
    // also don't bother rebuilds when the components.d.ts file gets updated
    return isWebDevFile(filePath) || (isDtsFile(filePath) && filePath.indexOf(COMPONENTS_DTS) === -1);
}

function initWatcher(config, compilerCtx) {
    // only create the watcher if this is a watch build
    // and we haven't created a watch listener already
    if (compilerCtx.hasWatcher || !config.watch) {
        return false;
    }
    config.logger.debug(`initWatcher: ${config.srcDir}`);
    const watcherListener = new WatcherListener(config, compilerCtx);
    watcherListener.subscribe();
    compilerCtx.hasWatcher = true;
    if (config.sys.createWatcher) {
        const watcher = config.sys.createWatcher(compilerCtx.events, config.srcDir, {
            ignored: config.watchIgnoredRegex,
            ignoreInitial: true
        });
        if (watcher && config.configPath) {
            config.configPath = normalizePath(config.configPath);
            config.logger.debug(`watch configPath: ${config.configPath}`);
            watcher.add(config.configPath);
        }
    }
    return true;
}

var __awaiter$15 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getBuildContext(config, compilerCtx, watcher) {
    // do a full build if there is no watcher
    // or the watcher said the config has updated
    // or we've never had a successful build yet
    const requiresFullBuild = !watcher || watcher.configUpdated || !compilerCtx.hasSuccessfulBuild;
    const isRebuild = !!watcher;
    compilerCtx.isRebuild = isRebuild;
    const msg = `${isRebuild ? 'rebuild' : 'build'}, ${config.fsNamespace}, ${config.devMode ? 'dev' : 'prod'} mode, started`;
    // increment the active build id
    compilerCtx.activeBuildId++;
    // data for one build
    const buildCtx = {
        requiresFullBuild: requiresFullBuild,
        buildId: compilerCtx.activeBuildId,
        componentRefs: [],
        collections: [],
        moduleGraphs: [],
        diagnostics: [],
        entryPoints: [],
        entryModules: [],
        components: [],
        data: {},
        transpileBuildCount: 0,
        bundleBuildCount: 0,
        appFileBuildCount: 0,
        indexBuildCount: 0,
        aborted: false,
        startTime: Date.now(),
        timeSpan: config.logger.createTimeSpan(msg),
        hasChangedJsText: false,
        filesWritten: [],
        filesChanged: watcher ? watcher.filesChanged : [],
        filesUpdated: watcher ? watcher.filesUpdated : [],
        filesAdded: watcher ? watcher.filesAdded : [],
        filesDeleted: watcher ? watcher.filesDeleted : [],
        dirsDeleted: watcher ? watcher.dirsDeleted : [],
        dirsAdded: watcher ? watcher.dirsAdded : []
    };
    buildCtx.shouldAbort = () => {
        return shouldAbort(compilerCtx, buildCtx);
    };
    buildCtx.finish = () => __awaiter$15(this, void 0, void 0, function* () {
        try {
            // setup watcher if need be
            initWatcher(config, compilerCtx);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        return finishBuild(config, compilerCtx, buildCtx);
    });
    if (watcher) {
        Object.keys(watcher).forEach(key => {
            watcher[key] = {};
        });
    }
    return buildCtx;
}
function finishBuild(config, compilerCtx, buildCtx) {
    return __awaiter$15(this, void 0, void 0, function* () {
        const buildResults = generateBuildResults(config, compilerCtx, buildCtx);
        // log any errors/warnings
        config.logger.printDiagnostics(buildResults.diagnostics);
        // create a nice pretty message stating what happend
        const buildText = compilerCtx.isRebuild ? 'rebuild' : 'build';
        let watchText = config.watch ? ', watching for changes...' : '';
        let buildStatus = 'finished';
        let statusColor = 'green';
        let bold = true;
        if (buildResults.hasError) {
            compilerCtx.lastBuildHadError = true;
            buildStatus = 'failed';
            statusColor = 'red';
        }
        else if (buildResults.aborted) {
            buildStatus = 'aborted';
            watchText = '';
            statusColor = 'dim';
            bold = false;
        }
        else {
            compilerCtx.hasSuccessfulBuild = true;
            compilerCtx.lastBuildHadError = false;
        }
        // print out the time it took to build
        // and add the duration to the build results
        buildCtx.timeSpan.finish(`${buildText} ${buildStatus}${watchText}`, statusColor, bold, true);
        // write the build stats
        yield generateBuildStats(config, compilerCtx, buildCtx, buildResults);
        // clear it all out for good measure
        for (const k in buildCtx) {
            buildCtx[k] = null;
        }
        // write all of our logs to disk if config'd to do so
        config.logger.writeLogs(compilerCtx.isRebuild);
        // emit a build event, which happens for inital build and rebuilds
        compilerCtx.events.emit('build', buildResults);
        if (compilerCtx.isRebuild) {
            // emit a rebuild event, which happens only for rebuilds
            compilerCtx.events.emit('rebuild', buildResults);
        }
        return buildResults;
    });
}
function shouldAbort(ctx, buildCtx) {
    if (ctx.activeBuildId > buildCtx.buildId || buildCtx.aborted) {
        buildCtx.aborted = true;
        return true;
    }
    if (hasError(buildCtx.diagnostics)) {
        // remember if the last build had an error or not
        // this is useful if the next build should do a full build or not
        ctx.lastBuildHadError = true;
        buildCtx.aborted = true;
        return true;
    }
    return false;
}

var __awaiter$16 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getUserTsConfig(config, compilerCtx) {
    return __awaiter$16(this, void 0, void 0, function* () {
        let compilerOptions = Object.assign({}, DEFAULT_COMPILER_OPTIONS);
        try {
            const normalizedConfigPath = normalizePath(config.tsconfig);
            const sourceText = yield compilerCtx.fs.readFile(normalizedConfigPath);
            try {
                const sourceJson = JSON.parse(sourceText);
                const parsedCompilerOptions = ts.convertCompilerOptionsFromJson(sourceJson.compilerOptions, '.').options;
                compilerOptions = Object.assign({}, compilerOptions, parsedCompilerOptions);
            }
            catch (e) {
                config.logger.warn('tsconfig.json is malformed, using default settings');
            }
        }
        catch (e) { }
        if (config._isTesting) {
            compilerOptions.module = ts.ModuleKind.CommonJS;
        }
        // apply user config to tsconfig
        compilerOptions.rootDir = config.srcDir;
        const collectionOutputTarget = config.outputTargets.find(o => !!o.collectionDir);
        if (collectionOutputTarget) {
            compilerOptions.outDir = collectionOutputTarget.collectionDir;
        }
        else {
            compilerOptions.outDir = pathJoin(config, config.rootDir, IN_MEMORY_DIR);
        }
        // generate .d.ts files when generating a distribution and in prod mode
        const typesOutputTarget = config.outputTargets.find(o => !!o.typesDir);
        if (typesOutputTarget) {
            compilerOptions.declaration = true;
            compilerOptions.declarationDir = typesOutputTarget.typesDir;
        }
        else {
            compilerOptions.declaration = false;
        }
        validateCompilerOptions(compilerOptions);
        return compilerOptions;
    });
}
function validateCompilerOptions(compilerOptions) {
    if (compilerOptions.allowJs && compilerOptions.declaration) {
        compilerOptions.allowJs = false;
    }
    // triple stamp a double stamp we've got the required settings
    compilerOptions.jsx = DEFAULT_COMPILER_OPTIONS.jsx;
    compilerOptions.jsxFactory = DEFAULT_COMPILER_OPTIONS.jsxFactory;
    compilerOptions.experimentalDecorators = DEFAULT_COMPILER_OPTIONS.experimentalDecorators;
    compilerOptions.noEmitOnError = DEFAULT_COMPILER_OPTIONS.noEmit;
    compilerOptions.suppressOutputPathCheck = DEFAULT_COMPILER_OPTIONS.suppressOutputPathCheck;
    compilerOptions.module = DEFAULT_COMPILER_OPTIONS.module;
    compilerOptions.moduleResolution = DEFAULT_COMPILER_OPTIONS.moduleResolution;
    if (compilerOptions.target === ts.ScriptTarget.ES3 || compilerOptions.target === ts.ScriptTarget.ES5) {
        compilerOptions.target = DEFAULT_COMPILER_OPTIONS.target;
    }
}
const DEFAULT_COMPILER_OPTIONS = {
    // to allow jsx to work
    jsx: ts.JsxEmit.React,
    // the factory function to use
    jsxFactory: 'h',
    // transpileModule does not write anything to disk so there is no need
    // to verify that there are no conflicts between input and output paths.
    suppressOutputPathCheck: true,
    // // Clear out other settings that would not be used in transpiling this module
    lib: [
        'lib.dom.d.ts',
        'lib.es5.d.ts',
        'lib.es2015.d.ts',
        'lib.es2016.d.ts',
        'lib.es2017.d.ts'
    ],
    // We are not doing a full typecheck, we are not resolving the whole context,
    // so pass --noResolve to avoid reporting missing file errors.
    // noResolve: true,
    allowSyntheticDefaultImports: true,
    // must always allow decorators
    experimentalDecorators: true,
    // transpile down to es2017
    target: ts.ScriptTarget.ES2017,
    // create es2015 modules
    module: ts.ModuleKind.ESNext,
    // resolve using NodeJs style
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    // ensure that we do emit something
    noEmitOnError: false
};

var __awaiter$17 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Check if class has component decorator
 * @param classNode
 */
function isComponentClass(classNode) {
    if (!Array.isArray(classNode.decorators)) {
        return false;
    }
    const componentDecoratorIndex = classNode.decorators.findIndex(dec => (ts.isCallExpression(dec.expression) && ts.isIdentifier(dec.expression.expression) && dec.expression.expression.text === 'Component'));
    return (componentDecoratorIndex !== -1);
}
function isInstanceOfObjectMap(object) {
    return (!object.hasOwnProperty('kind') &&
        !object.hasOwnProperty('flags') &&
        !object.hasOwnProperty('pos') &&
        !object.hasOwnProperty('end'));
}
function getTextOfPropertyName(name) {
    switch (name.kind) {
        case ts.SyntaxKind.Identifier:
            return name.text;
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.NumericLiteral:
            return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
            const expression = name.expression;
            if (ts.isStringLiteral(expression) || ts.isNumericLiteral(expression)) {
                return name.expression.text;
            }
    }
    return undefined;
}
function objectLiteralToObjectMap(objectLiteral) {
    const attrs = objectLiteral.properties;
    return attrs.reduce((final, attr) => {
        const name = getTextOfPropertyName(attr.name);
        let val;
        switch (attr.initializer.kind) {
            case ts.SyntaxKind.ObjectLiteralExpression:
                val = objectLiteralToObjectMap(attr.initializer);
                break;
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.Identifier:
            case ts.SyntaxKind.PropertyAccessExpression:
            default:
                val = attr.initializer;
        }
        final[name] = val;
        return final;
    }, {});
}
function objectMapToObjectLiteral(objMap) {
    const newProperties = Object.keys(objMap).map((key) => {
        const value = objMap[key];
        if (!ts.isIdentifier(value) && isInstanceOfObjectMap(value)) {
            return ts.createPropertyAssignment(ts.createLiteral(key), objectMapToObjectLiteral(value));
        }
        return ts.createPropertyAssignment(ts.createLiteral(key), value);
    });
    return ts.createObjectLiteral(newProperties);
}
/**
 * Convert a js value into typescript AST
 * @param val array, object, string, boolean, or number
 * @returns Typescript Object Literal, Array Literal, String Literal, Boolean Literal, Numeric Literal
 */
function convertValueToLiteral(val) {
    if (val === String) {
        return ts.createIdentifier('String');
    }
    if (val === Number) {
        return ts.createIdentifier('Number');
    }
    if (val === Boolean) {
        return ts.createIdentifier('Boolean');
    }
    if (Array.isArray(val)) {
        return arrayToArrayLiteral(val);
    }
    if (typeof val === 'object') {
        return objectToObjectLiteral(val);
    }
    return ts.createLiteral(val);
}
/**
 * Convert a js object into typescript AST
 * @param obj key value object
 * @returns Typescript Object Literal Expression
 */
function objectToObjectLiteral(obj) {
    if (Object.keys(obj).length === 0) {
        return ts.createObjectLiteral([]);
    }
    const newProperties = Object.keys(obj).map((key) => {
        return ts.createPropertyAssignment(ts.createLiteral(key), convertValueToLiteral(obj[key]));
    });
    return ts.createObjectLiteral(newProperties, true);
}
/**
 * Convert a js array into typescript AST
 * @param list array
 * @returns Typescript Array Literal Expression
 */
function arrayToArrayLiteral(list) {
    const newList = list.map(convertValueToLiteral);
    return ts.createArrayLiteral(newList);
}
/**
 * Execute an array of transforms over a string containing typescript source
 * @param sourceText Typescript source as a string
 * @param transformers Array of transforms to run agains the source string
 * @returns a string
 */
function transformSourceString(fileName, sourceText, transformers) {
    return __awaiter$17(this, void 0, void 0, function* () {
        const transformed = ts.transform(ts.createSourceFile(fileName, sourceText, ts.ScriptTarget.ES2017), transformers);
        const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed }, {
            onEmitNode: transformed.emitNodeWithNotification,
            substituteNode: transformed.substituteNode
        });
        const result = printer.printBundle(ts.createBundle(transformed.transformed));
        transformed.dispose();
        return result;
    });
}

function addComponentMetadata(moduleFiles) {
    return (transformContext) => {
        function visitClass(classNode, cmpMeta) {
            const staticMembers = addStaticMeta(cmpMeta);
            const newMembers = Object.keys(staticMembers).map(memberName => {
                return createGetter(memberName, staticMembers[memberName]);
            });
            return ts.updateClassDeclaration(classNode, classNode.decorators, classNode.modifiers, classNode.name, classNode.typeParameters, classNode.heritageClauses, [...classNode.members, ...newMembers]);
        }
        function visit(node, cmpMeta) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    return visitClass(node, cmpMeta);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node, cmpMeta);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            const moduleFile = moduleFiles[tsSourceFile.fileName];
            if (moduleFile && moduleFile.cmpMeta) {
                return visit(tsSourceFile, moduleFile.cmpMeta);
            }
            return tsSourceFile;
        };
    };
}
function addStaticMeta(cmpMeta) {
    const staticMembers = {};
    staticMembers.is = convertValueToLiteral(cmpMeta.tagNameMeta);
    const encapsulation = formatConstructorEncapsulation(cmpMeta.encapsulation);
    if (encapsulation) {
        staticMembers.encapsulation = convertValueToLiteral(encapsulation);
    }
    if (cmpMeta.hostMeta && Object.keys(cmpMeta.hostMeta).length > 0) {
        staticMembers.host = convertValueToLiteral(cmpMeta.hostMeta);
    }
    const propertiesMeta = formatComponentConstructorProperties(cmpMeta.membersMeta);
    if (propertiesMeta && Object.keys(propertiesMeta).length > 0) {
        staticMembers.properties = convertValueToLiteral(propertiesMeta);
    }
    const eventsMeta = formatComponentConstructorEvents(cmpMeta.eventsMeta);
    if (eventsMeta && eventsMeta.length > 0) {
        staticMembers.events = convertValueToLiteral(eventsMeta);
    }
    const listenerMeta = formatComponentConstructorListeners(cmpMeta.listenersMeta);
    if (listenerMeta && listenerMeta.length > 0) {
        staticMembers.listeners = convertValueToLiteral(listenerMeta);
    }
    if (cmpMeta.stylesMeta) {
        const styleModes = Object.keys(cmpMeta.stylesMeta);
        if (styleModes.length > 0) {
            // awesome, we know we've got styles!
            // let's add the placeholder which we'll use later
            // after we generate the css
            staticMembers.style = convertValueToLiteral(getStylePlaceholder(cmpMeta.tagNameMeta));
            if (!cmpMeta.stylesMeta[DEFAULT_STYLE_MODE]) {
                // if there's only one style, then there's no need for styleId
                // but if there are numerous style modes, then we'll need to add this
                staticMembers.styleMode = convertValueToLiteral(getStyleIdPlaceholder(cmpMeta.tagNameMeta));
            }
        }
    }
    return staticMembers;
}
function createGetter(name, returnExpression) {
    return ts.createGetAccessor(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], name, undefined, undefined, ts.createBlock([
        ts.createReturn(returnExpression)
    ]));
}

function buildConditionalsTransform(coreBuild) {
    return (transformContext) => {
        function visitPropertyAccessExpression(node) {
            let variableName = node.getText();
            if (!variableName.startsWith('Build.')) {
                return node;
            }
            variableName = variableName.split('.')[1];
            if (!variableName) {
                return node;
            }
            if (coreBuild[variableName]) {
                return ts.createTrue();
            }
            return ts.createFalse();
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.PropertyAccessExpression:
                    return visitPropertyAccessExpression(node);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

function componentDependencies(compilerCtx, buildCtx) {
    return (transformContext) => {
        function visit(node, filePath) {
            if (node.kind === ts.SyntaxKind.CallExpression) {
                callExpression(buildCtx, filePath, node);
            }
            else if (node.kind === ts.SyntaxKind.StringLiteral) {
                stringLiteral(buildCtx, filePath, node);
            }
            return ts.visitEachChild(node, (node) => {
                return visit(node, filePath);
            }, transformContext);
        }
        return (tsSourceFile) => {
            const filePath = normalizePath(tsSourceFile.fileName);
            addPropConnects(compilerCtx, buildCtx.componentRefs, filePath);
            return visit(tsSourceFile, filePath);
        };
    };
}
function addPropConnects(compilerCtx, sourceStrings, filePath) {
    const moduleFile = compilerCtx.moduleFiles[filePath];
    const cmpMeta = (moduleFile && moduleFile.cmpMeta);
    if (!cmpMeta) {
        return;
    }
    if (cmpMeta.membersMeta) {
        Object.keys(cmpMeta.membersMeta).forEach(memberName => {
            const memberMeta = cmpMeta.membersMeta[memberName];
            if (memberMeta.memberType === 4 /* PropConnect */) {
                addPropConnect(compilerCtx, sourceStrings, filePath, memberMeta.ctrlId);
            }
        });
    }
}
function addPropConnect(compilerCtx, sourceStrings, filePath, tag) {
    sourceStrings.push({
        tag: tag,
        filePath: filePath
    });
    compilerCtx.collections.forEach(collection => {
        collection.bundles.forEach(bundle => {
            if (bundle.components.includes(tag)) {
                bundle.components.forEach(bundleTag => {
                    if (bundleTag !== tag) {
                        sourceStrings.push({
                            tag: bundleTag,
                            filePath: filePath
                        });
                    }
                });
            }
        });
    });
}
function callExpression(buildCtx, filePath, node) {
    if (node.arguments && node.arguments[0]) {
        if (node.expression.kind === ts.SyntaxKind.Identifier) {
            // h('tag')
            callExpressionArg(buildCtx, filePath, node.expression, node.arguments);
        }
        else if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {
            // document.createElement('tag')
            if (node.expression.name) {
                // const
                callExpressionArg(buildCtx, filePath, node.expression.name, node.arguments);
            }
        }
    }
}
function callExpressionArg(buildCtx, filePath, callExpressionName, args) {
    if (TAG_CALL_EXPRESSIONS.includes(callExpressionName.escapedText)) {
        if (args[0].kind === ts.SyntaxKind.StringLiteral) {
            const tag = args[0].text;
            if (typeof tag === 'string') {
                buildCtx.componentRefs.push({
                    tag: tag,
                    filePath: filePath
                });
            }
        }
    }
}
function stringLiteral(buildCtx, filePath, node) {
    if (typeof node.text === 'string' && node.text.includes('<')) {
        buildCtx.componentRefs.push({
            html: node.text,
            filePath: filePath
        });
    }
}
const TAG_CALL_EXPRESSIONS = [
    'h',
    'createElement',
    'createElementNS'
];

var __awaiter$18 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function angularDirectiveProxyOutputs(config, compilerCtx, cmpRegistry) {
    const angularOuputTargets = config.outputTargets
        .filter(o => o.type === 'angular' && o.directivesProxyFile);
    return Promise.all(angularOuputTargets.map(angularOuputTarget => {
        return angularDirectiveProxyOutput(config, compilerCtx, angularOuputTarget, cmpRegistry);
    }));
}
function getComponents(excludeComponents, cmpRegistry) {
    return Object.keys(cmpRegistry)
        .map(key => cmpRegistry[key])
        .filter(c => !excludeComponents.includes(c.tagNameMeta))
        .sort((a, b) => {
        if (a.componentClass < b.componentClass)
            return -1;
        if (a.componentClass > b.componentClass)
            return 1;
        return 0;
    });
}
function angularDirectiveProxyOutput(config, compilerCtx, outputTarget, cmpRegistry) {
    return __awaiter$18(this, void 0, void 0, function* () {
        const components = getComponents(outputTarget.excludeComponents, cmpRegistry);
        const { hasDirectives, hasOutputs, proxies } = generateProxies(components);
        const auxFunctions = [
            inputsAuxFunction(),
            outputsAuxFunction(),
            methodsAuxFunction()
        ];
        const angularImports = [
            'ElementRef'
        ];
        if (hasDirectives) {
            angularImports.push('Directive');
        }
        if (hasOutputs) {
            angularImports.push('EventEmitter');
        }
        const imports = `import { ${angularImports.sort().join(', ')} } from '@angular/core';`;
        const final = [
            '/* auto-generated angular directive proxies */',
            imports,
            auxFunctions.join('\n'),
            proxies,
        ];
        const finalText = final.join('\n') + '\n';
        yield compilerCtx.fs.writeFile(outputTarget.directivesProxyFile, finalText);
        if (outputTarget.directivesArrayFile) {
            const proxyPath = relativeImport(outputTarget.directivesArrayFile, outputTarget.directivesProxyFile);
            const a = angularArray(components, proxyPath);
            yield compilerCtx.fs.writeFile(outputTarget.directivesArrayFile, a);
        }
        config.logger.debug(`generated angular directives: ${outputTarget.directivesProxyFile}`);
    });
}
function inputsAuxFunction() {
    return `
export function proxyInputs(instance: any, el: ElementRef, props: string[]) {
  props.forEach(propName => {
    Object.defineProperty(instance, propName, {
      get: () => el.nativeElement[propName], set: (val: any) => el.nativeElement[propName] = val
    });
  });
}`;
}
function outputsAuxFunction() {
    return `
export function proxyOutputs(instance: any, events: string[]) {
  events.forEach(eventName => instance[eventName] = new EventEmitter());
}`;
}
function methodsAuxFunction() {
    return `
export function proxyMethods(instance: any, ref: ElementRef, methods: string[]) {
  const el = ref.nativeElement;
  methods.forEach(methodName => {
    Object.defineProperty(instance, methodName, {
      get: function() {
        return function() {
          const args = arguments;
          return el.componentOnReady().then((el: any) => el[methodName].apply(el, args));
        };
      }
    });
  });
}
`;
}
function generateProxies(components) {
    let hasDirectives = false;
    let hasMethods = false;
    let hasOutputs = false;
    let hasInputs = false;
    const lines = components.map(cmpMeta => {
        const proxy = generateProxy(cmpMeta);
        hasDirectives = true;
        if (proxy.hasInputs) {
            hasInputs = true;
        }
        if (proxy.hasMethods) {
            hasMethods = true;
        }
        if (proxy.hasOutputs) {
            hasOutputs = true;
        }
        return proxy.text;
    });
    return {
        proxies: lines.join('\n'),
        hasDirectives,
        hasInputs,
        hasMethods,
        hasOutputs
    };
}
function generateProxy(cmpMeta) {
    // Collect component meta
    const inputs = getInputs(cmpMeta);
    const outputs = getOutputs(cmpMeta);
    const methods = getMethods(cmpMeta);
    // Process meta
    const hasInputs = inputs.length > 0;
    const hasOutputs = outputs.length > 0;
    const hasMethods = methods.length > 0;
    const hasContructor = hasInputs || hasOutputs || hasMethods;
    // Generate Angular @Directive
    const directiveOpts = [
        `selector: \'${cmpMeta.tagNameMeta}\'`
    ];
    if (inputs.length > 0) {
        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
    }
    if (outputs.length > 0) {
        directiveOpts.push(`outputs: ['${outputs.join(`', '`)}']`);
    }
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagNameMeta);
    const lines = [`
export declare interface ${cmpMeta.componentClass} extends StencilComponents.${tagNameAsPascal} {}
@Directive({${directiveOpts.join(', ')}})
export class ${cmpMeta.componentClass} {`];
    // Generate outputs
    outputs.forEach(output => {
        lines.push(`  ${output}: EventEmitter<any>;`);
    });
    // Generate component constructor
    if (hasMethods || hasInputs) {
        lines.push(`  constructor(r: ElementRef) {`);
    }
    else if (hasOutputs) {
        lines.push(`  constructor() {`);
    }
    if (hasMethods) {
        lines.push(`    proxyMethods(this, r, ['${methods.join(`', '`)}']);`);
    }
    if (hasInputs) {
        lines.push(`    proxyInputs(this, r, ['${inputs.join(`', '`)}']);`);
    }
    if (hasOutputs) {
        lines.push(`    proxyOutputs(this, ['${outputs.join(`', '`)}']);`);
    }
    if (hasContructor) {
        lines.push(`  }`);
    }
    lines.push(`}`);
    return {
        text: lines.join('\n'),
        hasInputs,
        hasMethods,
        hasOutputs
    };
}
function getInputs(cmpMeta) {
    return Object.keys(cmpMeta.membersMeta).filter(memberName => {
        const m = cmpMeta.membersMeta[memberName];
        return m.memberType === 1 /* Prop */ || m.memberType === 2 /* PropMutable */;
    });
}
function getOutputs(cmpMeta) {
    return cmpMeta.eventsMeta.map(eventMeta => eventMeta.eventName);
}
function getMethods(cmpMeta) {
    return Object.keys(cmpMeta.membersMeta).filter(memberName => {
        const m = cmpMeta.membersMeta[memberName];
        return m.memberType === 6 /* Method */;
    });
}
function relativeImport(pathFrom, pathTo) {
    let relativePath = path.relative(path.dirname(pathFrom), path.dirname(pathTo));
    relativePath = relativePath === '' ? '.' : relativePath;
    return `${relativePath}/${path.basename(pathTo, '.ts')}`;
}
function angularArray(components, proxyPath) {
    const directives = components.map(cmpMeta => `d.${cmpMeta.componentClass}`).join(',\n  ');
    return `
import * as d from '${proxyPath}';

export const DIRECTIVES = [
  ${directives}
];
`;
}

var __awaiter$19 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function writeAppCollections(config, compilerCtx, buildCtx) {
    return __awaiter$19(this, void 0, void 0, function* () {
        return Promise.all(config.outputTargets.map(outputTarget => {
            return writeAppCollection(config, compilerCtx, buildCtx, outputTarget);
        }));
    });
}
// this maps the json data to our internal data structure
// apping is so that the internal data structure "could"
// change, but the external user data will always use the same api
// over the top lame mapping functions is basically so we can loosly
// couple core component meta data between specific versions of the compiler
function writeAppCollection(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$19(this, void 0, void 0, function* () {
        if (!outputTarget.collectionDir) {
            return Promise.resolve();
        }
        // get the absolute path to the directory where the collection will be saved
        const collectionDir = normalizePath(outputTarget.collectionDir);
        // create an absolute file path to the actual collection json file
        const collectionFilePath = normalizePath(config.sys.path.join(collectionDir, COLLECTION_MANIFEST_FILE_NAME));
        config.logger.debug(`collection, serialize: ${collectionFilePath}`);
        // serialize the collection into a json string and
        // add it to the list of files we need to write when we're ready
        const collectionData = serializeAppCollection(config, compilerCtx, collectionDir, buildCtx.entryModules, buildCtx.global);
        // don't bother serializing/writing the collection if we're not creating a distribution
        yield compilerCtx.fs.writeFile(collectionFilePath, JSON.stringify(collectionData, null, 2));
        return collectionData;
    });
}
function serializeAppCollection(config, compilerCtx, collectionDir, entryModules, globalModule) {
    // create the single collection we're going to fill up with data
    const collectionData = {
        components: [],
        collections: serializeCollectionDependencies(compilerCtx),
        compiler: {
            name: config.sys.compiler.name,
            version: config.sys.compiler.version,
            typescriptVersion: config.sys.compiler.typescriptVersion
        },
        bundles: []
    };
    // add component data for each of the collection files
    entryModules.forEach(entryModule => {
        entryModule.moduleFiles.forEach(moduleFile => {
            const cmpData = serializeComponent(config, collectionDir, moduleFile);
            if (cmpData) {
                collectionData.components.push(cmpData);
            }
        });
    });
    // sort it alphabetically, cuz
    collectionData.components.sort((a, b) => {
        if (a.tag < b.tag)
            return -1;
        if (a.tag > b.tag)
            return 1;
        return 0;
    });
    // set the global path if it exists
    serializeAppGlobal(config, collectionDir, collectionData, globalModule);
    serializeBundles(config, collectionData);
    // success!
    return collectionData;
}
function serializeCollectionDependencies(compilerCtx) {
    const collectionDeps = compilerCtx.collections.map(c => {
        const collectionDeps = {
            name: c.collectionName,
            tags: c.moduleFiles.filter(m => {
                return !!m.cmpMeta;
            }).map(m => m.cmpMeta.tagNameMeta).sort()
        };
        return collectionDeps;
    });
    return collectionDeps.sort((a, b) => {
        if (a.name < b.name)
            return -1;
        if (a.name > b.name)
            return 1;
        return 0;
    });
}
function parseCollectionData(config, collectionName, collectionDir, collectionJsonStr) {
    const collectionData = JSON.parse(collectionJsonStr);
    const collection = {
        collectionName: collectionName,
        dependencies: parseCollectionDependencies(collectionData),
        compiler: {
            name: collectionData.compiler.name,
            version: collectionData.compiler.version,
            typescriptVersion: collectionData.compiler.typescriptVersion
        },
        bundles: []
    };
    parseComponents(config, collectionDir, collectionData, collection);
    parseGlobal(config, collectionDir, collectionData, collection);
    parseBundles(collectionData, collection);
    return collection;
}
function parseComponents(config, collectionDir, collectionData, collection) {
    const componentsData = collectionData.components;
    if (!componentsData || !Array.isArray(componentsData)) {
        collection.moduleFiles = [];
        return;
    }
    collection.moduleFiles = componentsData.map(cmpData => {
        return parseComponentDataToModuleFile(config, collection, collectionDir, cmpData);
    });
}
function parseCollectionDependencies(collectionData) {
    const dependencies = [];
    if (Array.isArray(collectionData.collections)) {
        collectionData.collections.forEach(c => {
            dependencies.push(c.name);
        });
    }
    return dependencies;
}
function excludeFromCollection(config, cmpData) {
    // this is a component from a collection dependency
    // however, this project may also become a collection
    // for example, "ionicons" is a dependency of "ionic"
    // and "ionic" is it's own stand-alone collection, so within
    // ionic's collection we want ionicons to just work
    // cmpData is a component from a collection dependency
    // if this component is listed in this config's bundles
    // then we'll need to ensure it also becomes apart of this collection
    const isInBundle = config.bundles && config.bundles.some(bundle => {
        return bundle.components && bundle.components.some(tag => tag === cmpData.tag);
    });
    // if it's not in the config bundle then it's safe to exclude
    // this component from going into this build's collection
    return !isInBundle;
}
function serializeComponent(config, collectionDir, moduleFile) {
    if (!moduleFile || !moduleFile.cmpMeta || moduleFile.isCollectionDependency || moduleFile.excludeFromCollection) {
        return null;
    }
    const cmpData = {};
    const cmpMeta = moduleFile.cmpMeta;
    // get the absolute path to the compiled component's output javascript file
    const compiledComponentAbsoluteFilePath = normalizePath(moduleFile.jsFilePath);
    // create a relative path from the collection file to the compiled component's output javascript file
    const compiledComponentRelativeFilePath = normalizePath(config.sys.path.relative(collectionDir, compiledComponentAbsoluteFilePath));
    // create a relative path to the directory where the compiled component's output javascript is sitting in
    const compiledComponentRelativeDirPath = normalizePath(config.sys.path.dirname(compiledComponentRelativeFilePath));
    serializeTag(cmpData, cmpMeta);
    serializeComponentDependencies(cmpData, cmpMeta);
    serializeComponentClass(cmpData, cmpMeta);
    serializeComponentPath(config, collectionDir, compiledComponentAbsoluteFilePath, cmpData);
    serializeStyles(config, compiledComponentRelativeDirPath, cmpData, cmpMeta);
    serializeAssetsDir(config, compiledComponentRelativeDirPath, cmpData, cmpMeta);
    serializeProps(cmpData, cmpMeta);
    serializeStates(cmpData, cmpMeta);
    serializeListeners(cmpData, cmpMeta);
    serializeMethods(cmpData, cmpMeta);
    serializeContextMember(cmpData, cmpMeta);
    serializeConnectMember(cmpData, cmpMeta);
    serializeHostElementMember(cmpData, cmpMeta);
    serializeEvents(cmpData, cmpMeta);
    serializeHost(cmpData, cmpMeta);
    serializeEncapsulation(cmpData, cmpMeta);
    return cmpData;
}
function parseComponentDataToModuleFile(config, collection, collectionDir, cmpData) {
    const moduleFile = {
        cmpMeta: {},
        isCollectionDependency: true,
        excludeFromCollection: excludeFromCollection(config, cmpData)
    };
    const cmpMeta = moduleFile.cmpMeta;
    parseTag(cmpData, cmpMeta);
    parseComponentDependencies(cmpData, cmpMeta);
    parseComponentClass(cmpData, cmpMeta);
    parseModuleJsFilePath(config, collectionDir, cmpData, moduleFile);
    parseStyles(config, collectionDir, cmpData, cmpMeta);
    parseAssetsDir(config, collectionDir, cmpData, cmpMeta);
    parseProps(config, collection, cmpData, cmpMeta);
    parseStates(cmpData, cmpMeta);
    parseListeners(cmpData, cmpMeta);
    parseMethods(cmpData, cmpMeta);
    parseContextMember(cmpData, cmpMeta);
    parseConnectMember(cmpData, cmpMeta);
    parseHostElementMember(cmpData, cmpMeta);
    parseEvents(cmpData, cmpMeta);
    parseHost(cmpData, cmpMeta);
    parseEncapsulation(cmpData, cmpMeta);
    // DEPRECATED: 2017-12-27
    parseWillChangeDeprecated(cmpData, cmpMeta);
    parseDidChangeDeprecated(cmpData, cmpMeta);
    return moduleFile;
}
function serializeTag(cmpData, cmpMeta) {
    cmpData.tag = cmpMeta.tagNameMeta;
}
function parseTag(cmpData, cmpMeta) {
    cmpMeta.tagNameMeta = cmpData.tag;
}
function serializeComponentPath(config, collectionDir, compiledComponentAbsoluteFilePath, cmpData) {
    // convert absolute path into a path that's relative to the collection file
    cmpData.componentPath = normalizePath(config.sys.path.relative(collectionDir, compiledComponentAbsoluteFilePath));
}
function parseModuleJsFilePath(config, collectionDir, cmpData, moduleFile) {
    // convert the path that's relative to the collection file
    // into an absolute path to the component's js file path
    if (typeof cmpData.componentPath !== 'string') {
        throw new Error(`parseModuleJsFilePath, "componentPath" missing on cmpData: ${cmpData.tag}`);
    }
    moduleFile.jsFilePath = normalizePath(config.sys.path.join(collectionDir, cmpData.componentPath));
    // remember the original component path from its collection
    moduleFile.originalCollectionComponentPath = cmpData.componentPath;
}
function serializeComponentDependencies(cmpData, cmpMeta) {
    cmpData.dependencies = (cmpMeta.dependencies || []).sort();
}
function parseComponentDependencies(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.dependencies)) {
        cmpMeta.dependencies = [];
    }
    else {
        cmpMeta.dependencies = cmpData.dependencies.sort();
    }
}
function serializeComponentClass(cmpData, cmpMeta) {
    cmpData.componentClass = cmpMeta.componentClass;
}
function parseComponentClass(cmpData, cmpMeta) {
    cmpMeta.componentClass = cmpData.componentClass;
}
function serializeStyles(config, compiledComponentRelativeDirPath, cmpData, cmpMeta) {
    if (cmpMeta.stylesMeta) {
        cmpData.styles = {};
        const modeNames = Object.keys(cmpMeta.stylesMeta).map(m => m.toLowerCase()).sort();
        modeNames.forEach(modeName => {
            cmpData.styles[modeName] = serializeStyle(config, compiledComponentRelativeDirPath, cmpMeta.stylesMeta[modeName]);
        });
    }
}
function parseStyles(config, collectionDir, cmpData, cmpMeta) {
    const stylesData = cmpData.styles;
    cmpMeta.stylesMeta = {};
    if (stylesData) {
        Object.keys(stylesData).forEach(modeName => {
            modeName = modeName.toLowerCase();
            cmpMeta.stylesMeta[modeName] = parseStyle(config, collectionDir, cmpData, stylesData[modeName]);
        });
    }
}
function serializeStyle(config, compiledComponentRelativeDirPath, modeStyleMeta) {
    const modeStyleData = {};
    if (modeStyleMeta.externalStyles && modeStyleMeta.externalStyles.length > 0) {
        modeStyleData.stylePaths = modeStyleMeta.externalStyles.map(externalStyle => {
            // convert style paths which are relative to the component file
            // to be style paths that are relative to the collection file
            // we've already figured out the component's relative path from the collection file
            // use the value we already created in serializeComponentPath()
            // create a relative path from the collection file to the style path
            return normalizePath(config.sys.path.join(compiledComponentRelativeDirPath, externalStyle.cmpRelativePath));
        });
        modeStyleData.stylePaths.sort();
    }
    if (typeof modeStyleMeta.styleStr === 'string') {
        modeStyleData.style = modeStyleMeta.styleStr;
    }
    return modeStyleData;
}
function parseStyle(config, collectionDir, cmpData, modeStyleData) {
    const modeStyle = {
        styleStr: modeStyleData.style
    };
    if (modeStyleData.stylePaths) {
        modeStyle.externalStyles = modeStyleData.stylePaths.map(stylePath => {
            const externalStyle = {};
            externalStyle.absolutePath = normalizePath(config.sys.path.join(collectionDir, stylePath));
            externalStyle.cmpRelativePath = normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), stylePath));
            externalStyle.originalCollectionPath = normalizePath(stylePath);
            return externalStyle;
        });
    }
    return modeStyle;
}
function serializeAssetsDir(config, compiledComponentRelativeDirPath, cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.assetsDirsMeta)) {
        return;
    }
    // convert asset paths which are relative to the component file
    // to be asset paths that are relative to the collection file
    // we've already figured out the component's relative path from the collection file
    // use the value we already created in serializeComponentPath()
    // create a relative path from the collection file to the asset path
    cmpData.assetPaths = cmpMeta.assetsDirsMeta.map(assetMeta => {
        return normalizePath(config.sys.path.join(compiledComponentRelativeDirPath, assetMeta.cmpRelativePath));
    }).sort();
}
function parseAssetsDir(config, collectionDir, cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.assetPaths)) {
        return;
    }
    cmpMeta.assetsDirsMeta = cmpData.assetPaths.map(assetsPath => {
        const assetsMeta = {
            absolutePath: normalizePath(config.sys.path.join(collectionDir, assetsPath)),
            cmpRelativePath: normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), assetsPath)),
            originalCollectionPath: normalizePath(assetsPath)
        };
        return assetsMeta;
    }).sort((a, b) => {
        if (a.cmpRelativePath < b.cmpRelativePath)
            return -1;
        if (a.cmpRelativePath > b.cmpRelativePath)
            return 1;
        return 0;
    });
}
function serializeProps(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const memberMeta = cmpMeta.membersMeta[memberName];
        if (memberMeta.memberType === 1 /* Prop */ || memberMeta.memberType === 2 /* PropMutable */) {
            cmpData.props = cmpData.props || [];
            const propData = {
                name: memberName
            };
            if (memberMeta.propType === 3 /* Boolean */) {
                propData.type = BOOLEAN_KEY;
            }
            else if (memberMeta.propType === 4 /* Number */) {
                propData.type = NUMBER_KEY;
            }
            else if (memberMeta.propType === 2 /* String */) {
                propData.type = STRING_KEY;
            }
            else if (memberMeta.propType === 1 /* Any */) {
                propData.type = ANY_KEY;
            }
            if (memberMeta.memberType === 2 /* PropMutable */) {
                propData.mutable = true;
            }
            if (typeof memberMeta.attribName === 'string') {
                propData.attr = memberMeta.attribName;
            }
            if (memberMeta.watchCallbacks && memberMeta.watchCallbacks.length) {
                propData.watch = memberMeta.watchCallbacks.slice();
            }
            cmpData.props.push(propData);
        }
    });
}
function parseProps(config, collection, cmpData, cmpMeta) {
    const propsData = cmpData.props;
    if (invalidArrayData(propsData)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    propsData.forEach(propData => {
        cmpMeta.membersMeta[propData.name] = {};
        if (propData.mutable) {
            cmpMeta.membersMeta[propData.name].memberType = 2 /* PropMutable */;
        }
        else {
            cmpMeta.membersMeta[propData.name].memberType = 1 /* Prop */;
        }
        // the standard is the first character of the type is capitalized
        // however, lowercase and normalize for good measure
        const type = typeof propData.type === 'string' ? propData.type.toLowerCase().trim() : null;
        if (type === BOOLEAN_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 3 /* Boolean */;
        }
        else if (type === NUMBER_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 4 /* Number */;
        }
        else if (type === STRING_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 2 /* String */;
        }
        else if (type === ANY_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        else if (!collection.compiler || !collection.compiler.version || config.sys.semver.lt(collection.compiler.version, '0.0.6-23')) {
            // older compilers didn't remember "any" type
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        if (cmpMeta.membersMeta[propData.name].propType) {
            // deprecated 0.7.3, 2018-03-19
            cmpMeta.membersMeta[propData.name].attribName = propData.name;
        }
        if (typeof propData.attr === 'string') {
            cmpMeta.membersMeta[propData.name].attribName = propData.attr;
        }
        if (!invalidArrayData(propData.watch)) {
            cmpMeta.membersMeta[propData.name].watchCallbacks = propData.watch.slice().sort();
        }
    });
}
function parseWillChangeDeprecated(cmpData, cmpMeta) {
    // DEPRECATED: 2017-12-27
    // previous way of storing change, 0.1.0 and below
    const propWillChangeData = cmpData.propsWillChange;
    if (invalidArrayData(propWillChangeData)) {
        return;
    }
    propWillChangeData.forEach((willChangeData) => {
        const propName = willChangeData.name;
        const methodName = willChangeData.method;
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta[propName] = cmpMeta.membersMeta[propName] || {};
        cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
        cmpMeta.membersMeta[propName].watchCallbacks.push(methodName);
    });
}
function parseDidChangeDeprecated(cmpData, cmpMeta) {
    // DEPRECATED: 2017-12-27
    // previous way of storing change, 0.1.0 and below
    const propDidChangeData = cmpData.propsDidChange;
    if (invalidArrayData(propDidChangeData)) {
        return;
    }
    propDidChangeData.forEach((didChangeData) => {
        const propName = didChangeData.name;
        const methodName = didChangeData.method;
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta[propName] = cmpMeta.membersMeta[propName] || {};
        cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
        cmpMeta.membersMeta[propName].watchCallbacks.push(methodName);
    });
}
function serializeStates(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 5 /* State */) {
            cmpData.states = cmpData.states || [];
            cmpData.states.push({
                name: memberName
            });
        }
    });
}
function parseStates(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.states)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.states.forEach(stateData => {
        cmpMeta.membersMeta[stateData.name] = {
            memberType: 5 /* State */
        };
    });
}
function serializeListeners(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.listenersMeta)) {
        return;
    }
    cmpData.listeners = cmpMeta.listenersMeta.map(listenerMeta => {
        const listenerData = {
            event: listenerMeta.eventName,
            method: listenerMeta.eventMethodName
        };
        if (listenerMeta.eventPassive === false) {
            listenerData.passive = false;
        }
        if (listenerMeta.eventDisabled === true) {
            listenerData.enabled = false;
        }
        if (listenerMeta.eventCapture === false) {
            listenerData.capture = false;
        }
        return listenerData;
    }).sort((a, b) => {
        if (a.event.toLowerCase() < b.event.toLowerCase())
            return -1;
        if (a.event.toLowerCase() > b.event.toLowerCase())
            return 1;
        return 0;
    });
}
function parseListeners(cmpData, cmpMeta) {
    const listenersData = cmpData.listeners;
    if (invalidArrayData(listenersData)) {
        return;
    }
    cmpMeta.listenersMeta = listenersData.map(listenerData => {
        const listener = {
            eventName: listenerData.event,
            eventMethodName: listenerData.method,
            eventPassive: (listenerData.passive !== false),
            eventDisabled: (listenerData.enabled === false),
            eventCapture: (listenerData.capture !== false)
        };
        return listener;
    });
}
function serializeMethods(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 6 /* Method */) {
            cmpData.methods = cmpData.methods || [];
            cmpData.methods.push({
                name: memberName
            });
        }
    });
}
function parseMethods(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.methods)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.methods.forEach(methodData => {
        cmpMeta.membersMeta[methodData.name] = {
            memberType: 6 /* Method */
        };
    });
}
function serializeContextMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.ctrlId && member.memberType === 3 /* PropContext */) {
            cmpData.context = cmpData.context || [];
            cmpData.context.push({
                name: memberName,
                id: member.ctrlId
            });
        }
    });
}
function parseContextMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.context)) {
        return;
    }
    cmpData.context.forEach(methodData => {
        if (methodData.id) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 3 /* PropContext */,
                ctrlId: methodData.id
            };
        }
    });
}
function serializeConnectMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.ctrlId && member.memberType === 4 /* PropConnect */) {
            cmpData.connect = cmpData.connect || [];
            cmpData.connect.push({
                name: memberName,
                tag: member.ctrlId
            });
        }
    });
}
function parseConnectMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.connect)) {
        return;
    }
    cmpData.connect.forEach(methodData => {
        if (methodData.tag) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 4 /* PropConnect */,
                ctrlId: methodData.tag
            };
        }
    });
}
function serializeHostElementMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 7 /* Element */) {
            cmpData.hostElement = {
                name: memberName
            };
        }
    });
}
function parseHostElementMember(cmpData, cmpMeta) {
    if (!cmpData.hostElement) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpMeta.membersMeta[cmpData.hostElement.name] = {
        memberType: 7 /* Element */
    };
}
function serializeEvents(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.eventsMeta)) {
        return;
    }
    cmpData.events = cmpMeta.eventsMeta.map(eventMeta => {
        const eventData = {
            event: eventMeta.eventName
        };
        if (eventMeta.eventMethodName !== eventMeta.eventName) {
            eventData.method = eventMeta.eventMethodName;
        }
        if (eventMeta.eventBubbles === false) {
            eventData.bubbles = false;
        }
        if (eventMeta.eventCancelable === false) {
            eventData.cancelable = false;
        }
        if (eventMeta.eventComposed === false) {
            eventData.composed = false;
        }
        return eventData;
    }).sort((a, b) => {
        if (a.event.toLowerCase() < b.event.toLowerCase())
            return -1;
        if (a.event.toLowerCase() > b.event.toLowerCase())
            return 1;
        return 0;
    });
}
function parseEvents(cmpData, cmpMeta) {
    const eventsData = cmpData.events;
    if (invalidArrayData(eventsData)) {
        return;
    }
    cmpMeta.eventsMeta = eventsData.map(eventData => ({
        eventName: eventData.event,
        eventMethodName: (eventData.method) ? eventData.method : eventData.event,
        eventBubbles: (eventData.bubbles !== false),
        eventCancelable: (eventData.cancelable !== false),
        eventComposed: (eventData.composed !== false)
    }));
}
function serializeHost(cmpData, cmpMeta) {
    if (!cmpMeta.hostMeta || Array.isArray(cmpMeta.hostMeta) || !Object.keys(cmpMeta.hostMeta).length) {
        return;
    }
    cmpData.host = cmpMeta.hostMeta;
}
function parseHost(cmpData, cmpMeta) {
    if (!cmpData.host) {
        return;
    }
    cmpMeta.hostMeta = cmpData.host;
}
function serializeEncapsulation(cmpData, cmpMeta) {
    if (cmpMeta.encapsulation === 1 /* ShadowDom */) {
        cmpData.shadow = true;
    }
    else if (cmpMeta.encapsulation === 2 /* ScopedCss */) {
        cmpData.scoped = true;
    }
}
function parseEncapsulation(cmpData, cmpMeta) {
    if (cmpData.shadow === true) {
        cmpMeta.encapsulation = 1 /* ShadowDom */;
    }
    else if (cmpData.scoped === true) {
        cmpMeta.encapsulation = 2 /* ScopedCss */;
    }
    else {
        cmpMeta.encapsulation = 0 /* NoEncapsulation */;
    }
}
function serializeAppGlobal(config, collectionDir, collectionData, globalModule) {
    if (!globalModule) {
        return;
    }
    collectionData.global = normalizePath(config.sys.path.relative(collectionDir, globalModule.jsFilePath));
}
function parseGlobal(config, collectionDir, collectionData, collection) {
    if (typeof collectionData.global !== 'string')
        return;
    collection.global = {
        jsFilePath: normalizePath(config.sys.path.join(collectionDir, collectionData.global))
    };
}
function serializeBundles(config, collectionData) {
    collectionData.bundles = config.bundles.map(b => {
        return {
            components: b.components.slice().sort()
        };
    });
}
function parseBundles(collectionData, collection) {
    if (invalidArrayData(collectionData.bundles)) {
        collection.bundles = [];
        return;
    }
    collection.bundles = collectionData.bundles.map(b => {
        return {
            components: b.components.slice().sort()
        };
    });
}
function invalidArrayData(arr) {
    return (!arr || !Array.isArray(arr) || arr.length === 0);
}
function nameSort(a, b) {
    if (a.toLowerCase() < b.toLowerCase())
        return -1;
    if (a.toLowerCase() > b.toLowerCase())
        return 1;
    return 0;
}
const BOOLEAN_KEY = 'Boolean';
const NUMBER_KEY = 'Number';
const STRING_KEY = 'String';
const ANY_KEY = 'Any';

function parseCollectionModule(config, compilerCtx, pkgJsonFilePath, pkgData) {
    // note this MUST be synchronous because this is used during transpile
    const collectionName = pkgData.name;
    let collection = compilerCtx.collections.find(c => c.collectionName === collectionName);
    if (collection) {
        // we've already cached the collection, no need for another resolve/readFile/parse
        // thought being that /node_modules/ isn't changing between watch builds
        return collection;
    }
    // get the root directory of the dependency
    const collectionPackageRootDir = config.sys.path.dirname(pkgJsonFilePath);
    // figure out the full path to the collection collection file
    const collectionFilePath = pathJoin(config, collectionPackageRootDir, pkgData.collection);
    config.logger.debug(`load collection: ${collectionFilePath}`);
    // we haven't cached the collection yet, let's read this file
    // sync on purpose :(
    const collectionJsonStr = compilerCtx.fs.readFileSync(collectionFilePath);
    // get the directory where the collection collection file is sitting
    const collectionDir = normalizePath(config.sys.path.dirname(collectionFilePath));
    // parse the json string into our collection data
    collection = parseCollectionData(config, collectionName, collectionDir, collectionJsonStr);
    if (pkgData.module && pkgData.module !== pkgData.main) {
        collection.hasExports = true;
    }
    // remember the source of this collection node_module
    collection.moduleDir = collectionPackageRootDir;
    // append any collection data
    collection.moduleFiles.forEach(collectionModuleFile => {
        if (!compilerCtx.moduleFiles[collectionModuleFile.jsFilePath]) {
            compilerCtx.moduleFiles[collectionModuleFile.jsFilePath] = collectionModuleFile;
        }
    });
    // cache it for later yo
    compilerCtx.collections.push(collection);
    return collection;
}

function getCollections(config, compilerCtx, collections, importNode) {
    if (!importNode.moduleSpecifier || !compilerCtx || !collections) {
        return;
    }
    const moduleId = importNode.moduleSpecifier.text;
    if (moduleId.startsWith('.') || moduleId.startsWith('/')) {
        // not a node module import, so don't bother
        return;
    }
    if (compilerCtx.resolvedCollections.includes(moduleId)) {
        // we've already handled this collection moduleId before
        return;
    }
    // cache that we've already parsed this
    compilerCtx.resolvedCollections.push(moduleId);
    // see if we can add this collection dependency
    addCollection(config, compilerCtx, collections, config.rootDir, moduleId);
}
function addCollection(config, compilerCtx, collections, resolveFromDir, moduleId) {
    let pkgJsonFilePath;
    try {
        // get the full package.json file path
        pkgJsonFilePath = config.sys.resolveModule(resolveFromDir, moduleId);
    }
    catch (e) {
        // it's someone else's job to handle unresolvable paths
        return;
    }
    if (pkgJsonFilePath === 'package.json') {
        // the resolved package is actually this very same package, so whatever
        return;
    }
    // open up and parse the package.json
    // sync on purpose :(
    const pkgJsonStr = compilerCtx.fs.readFileSync(pkgJsonFilePath);
    const pkgData = JSON.parse(pkgJsonStr);
    if (!pkgData.collection || !pkgData.types) {
        // this import is not a stencil collection
        return;
    }
    // this import is a stencil collection
    // let's parse it and gather all the module data about it
    // internally it'll cached collection data if we've already done this
    const collection = parseCollectionModule(config, compilerCtx, pkgJsonFilePath, pkgData);
    // check if we already added this collection to the build context
    const alreadyHasCollection = collections.some(c => {
        return c.collectionName === collection.collectionName;
    });
    if (alreadyHasCollection) {
        // we already have this collection in our build context
        return;
    }
    // let's add the collection to the build context
    collections.push(collection);
    if (Array.isArray(collection.dependencies)) {
        // this collection has more collections
        // let's keep digging down and discover all of them
        collection.dependencies.forEach(dependencyModuleId => {
            const resolveFromDir = config.sys.path.dirname(pkgJsonFilePath);
            addCollection(config, compilerCtx, collections, resolveFromDir, dependencyModuleId);
        });
    }
}

function evalText(text) {
    const fnStr = `return ${text};`;
    return new Function(fnStr)();
}
const getDeclarationParameters = (decorator) => {
    if (!ts.isCallExpression(decorator.expression)) {
        return [];
    }
    return decorator.expression.arguments.map((arg) => {
        return evalText(arg.getText().trim());
    });
};
function isDecoratorNamed(name) {
    return (dec) => {
        return (ts.isCallExpression(dec.expression) && dec.expression.expression.getText() === name);
    };
}
function isPropertyWithDecorators(member) {
    return ts.isPropertyDeclaration(member)
        && Array.isArray(member.decorators)
        && member.decorators.length > 0;
}
function isMethodWithDecorators(member) {
    return ts.isMethodDeclaration(member)
        && Array.isArray(member.decorators)
        && member.decorators.length > 0;
}
function serializeSymbol(checker, symbol) {
    return {
        name: symbol.getName(),
        documentation: ts.displayPartsToString(symbol.getDocumentationComment(checker)),
        type: checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration))
    };
}
function isMethod(member, methodName) {
    if (ts.isMethodDeclaration(member)) {
        return member.getFirstToken().getText() === methodName;
    }
    return false;
}
function getAttributeTypeInfo(baseNode, sourceFile) {
    return getAllTypeReferences(baseNode)
        .reduce((allReferences, rt) => {
        allReferences[rt] = getTypeReferenceLocation(rt, sourceFile);
        return allReferences;
    }, {});
}
function getAllTypeReferences(node) {
    const referencedTypes = [];
    function visit(node) {
        switch (node.kind) {
            case ts.SyntaxKind.TypeReference:
                const typeNode = node;
                if (ts.isIdentifier(typeNode.typeName)) {
                    const name = typeNode.typeName;
                    referencedTypes.push(name.escapedText.toString());
                }
                if (typeNode.typeArguments) {
                    typeNode.typeArguments
                        .filter(ta => ts.isTypeReferenceNode(ta))
                        .forEach((tr) => {
                        const name = tr.typeName;
                        referencedTypes.push(name.escapedText.toString());
                    });
                }
            /* tslint:disable */
            default:
                return ts.forEachChild(node, (node) => {
                    return visit(node);
                });
        }
        /* tslint:enable */
    }
    visit(node);
    return referencedTypes;
}
function getTypeReferenceLocation(typeName, sourceFile) {
    const sourceFileObj = sourceFile.getSourceFile();
    // Loop through all top level imports to find any reference to the type for 'import' reference location
    const importTypeDeclaration = sourceFileObj.statements.find(st => {
        const statement = ts.isImportDeclaration(st) &&
            ts.isImportClause(st.importClause) &&
            st.importClause.namedBindings && ts.isNamedImports(st.importClause.namedBindings) &&
            Array.isArray(st.importClause.namedBindings.elements) &&
            st.importClause.namedBindings.elements.find(nbe => nbe.name.getText() === typeName);
        if (!statement) {
            return false;
        }
        return true;
    });
    if (importTypeDeclaration) {
        const localImportPath = importTypeDeclaration.moduleSpecifier.text;
        return {
            referenceLocation: 'import',
            importReferenceLocation: localImportPath
        };
    }
    // Loop through all top level exports to find if any reference to the type for 'local' reference location
    const isExported = sourceFileObj.statements.some(st => {
        // Is the interface defined in the file and exported
        const isInterfaceDeclarationExported = ((ts.isInterfaceDeclaration(st) &&
            st.name.getText() === typeName) &&
            Array.isArray(st.modifiers) &&
            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
        // Is the interface exported through a named export
        const isTypeInExportDeclaration = ts.isExportDeclaration(st) &&
            ts.isNamedExports(st.exportClause) &&
            st.exportClause.elements.some(nee => nee.name.getText() === typeName);
        return isInterfaceDeclarationExported || isTypeInExportDeclaration;
    });
    if (isExported) {
        return {
            referenceLocation: 'local'
        };
    }
    // This is most likely a global type, if it is a local that is not exported then typescript will inform the dev
    return {
        referenceLocation: 'global',
    };
}

function getComponentDecoratorMeta(diagnostics, checker, node) {
    if (!node.decorators) {
        return undefined;
    }
    const componentDecorator = node.decorators.find(isDecoratorNamed('Component'));
    if (!componentDecorator) {
        return undefined;
    }
    const [componentOptions] = getDeclarationParameters(componentDecorator);
    if (!componentOptions.tag || componentOptions.tag.trim() === '') {
        throw new Error(`tag missing in component decorator: ${JSON.stringify(componentOptions, null, 2)}`);
    }
    const symbol = checker.getSymbolAtLocation(node.name);
    const cmpMeta = {
        tagNameMeta: componentOptions.tag,
        stylesMeta: {},
        assetsDirsMeta: [],
        hostMeta: getHostMeta(diagnostics, componentOptions.host),
        dependencies: [],
        jsdoc: serializeSymbol(checker, symbol)
    };
    // normalizeEncapsulation
    cmpMeta.encapsulation =
        componentOptions.shadow ? 1 /* ShadowDom */ :
            componentOptions.scoped ? 2 /* ScopedCss */ :
                0 /* NoEncapsulation */;
    // styles: 'div { padding: 10px }'
    if (typeof componentOptions.styles === 'string') {
        componentOptions.styles = componentOptions.styles.trim();
        if (componentOptions.styles.length > 0) {
            cmpMeta.stylesMeta = {
                [DEFAULT_STYLE_MODE]: {
                    styleStr: componentOptions.styles
                }
            };
        }
    }
    // styleUrl: 'my-styles.css'
    if (typeof componentOptions.styleUrl === 'string' && componentOptions.styleUrl.trim()) {
        cmpMeta.stylesMeta = {
            [DEFAULT_STYLE_MODE]: {
                externalStyles: [{
                        originalComponentPath: componentOptions.styleUrl.trim()
                    }]
            }
        };
        // styleUrls: ['my-styles.css', 'my-other-styles']
    }
    else if (Array.isArray(componentOptions.styleUrls)) {
        cmpMeta.stylesMeta = {
            [DEFAULT_STYLE_MODE]: {
                externalStyles: componentOptions.styleUrls.map(styleUrl => {
                    const externalStyle = {
                        originalComponentPath: styleUrl.trim()
                    };
                    return externalStyle;
                })
            }
        };
        // styleUrls: {
        //   ios: 'badge.ios.css',
        //   md: 'badge.md.css',
        //   wp: 'badge.wp.css'
        // }
    }
    else {
        Object.keys(componentOptions.styleUrls || {}).reduce((stylesMeta, styleType) => {
            const styleUrls = componentOptions.styleUrls;
            const sUrls = [].concat(styleUrls[styleType]);
            stylesMeta[styleType] = {
                externalStyles: sUrls.map(sUrl => {
                    const externalStyle = {
                        originalComponentPath: sUrl
                    };
                    return externalStyle;
                })
            };
            return stylesMeta;
        }, cmpMeta.stylesMeta);
    }
    // assetsDir: './somedir'
    if (componentOptions.assetsDir) {
        const assetsMeta = {
            originalComponentPath: componentOptions.assetsDir
        };
        cmpMeta.assetsDirsMeta.push(assetsMeta);
    }
    // assetsDirs: ['./somedir', '../someotherdir']
    if (Array.isArray(componentOptions.assetsDirs)) {
        cmpMeta.assetsDirsMeta = cmpMeta.assetsDirsMeta.concat(componentOptions.assetsDirs.map(assetDir => ({ originalComponentPath: assetDir })));
    }
    return cmpMeta;
}
function getHostMeta(diagnostics, hostData) {
    hostData = hostData || {};
    Object.keys(hostData).forEach(key => {
        const type = typeof hostData[key];
        if (type !== 'string' && type !== 'number' && type !== 'boolean') {
            // invalid data
            delete hostData[key];
            let itsType = 'object';
            if (type === 'function') {
                itsType = 'function';
            }
            else if (Array.isArray(hostData[key])) {
                itsType = 'Array';
            }
            const diagnostic = buildWarn(diagnostics);
            diagnostic.messageText = [
                `The @Component decorator's host property "${key}" has a type of "${itsType}". `,
                `However, a @Component decorator's "host" can only take static data, `,
                `such as a string, number or boolean. `,
                `Please use the "hostData()" method instead `,
                `if attributes or properties need to be dynamically added to `,
                `the host element.`
            ].join('');
        }
    });
    return hostData;
}

function getElementDecoratorMeta(checker, classNode) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('Element'));
        if (elementDecorator) {
            membersMeta[member.name.getText()] = {
                memberType: 7 /* Element */
            };
        }
        return membersMeta;
    }, {});
}

function getEventDecoratorMeta(diagnostics, checker, classNode, sourceFile) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('Event'));
        if (elementDecorator == null) {
            return membersMeta;
        }
        const [eventOptions] = getDeclarationParameters(elementDecorator);
        const metadata = convertOptionsToMeta(diagnostics, eventOptions, member.name.getText());
        if (member.type) {
            const genericType = gatherEventEmitterGeneric(member.type);
            if (genericType) {
                metadata.eventType = {
                    text: genericType.getText()
                };
                if (ts.isTypeReferenceNode(genericType)) {
                    metadata.eventType.typeReferences = getAttributeTypeInfo(member, sourceFile);
                }
            }
        }
        if (metadata) {
            const symbol = checker.getSymbolAtLocation(member.name);
            metadata.jsdoc = serializeSymbol(checker, symbol);
            metadata.jsdoc.name = metadata.eventName;
            membersMeta.push(metadata);
        }
        return membersMeta;
    }, []);
}
function convertOptionsToMeta(diagnostics, rawEventOpts = {}, memberName) {
    if (!memberName) {
        return null;
    }
    return {
        eventMethodName: memberName,
        eventName: getEventName$1(diagnostics, rawEventOpts, memberName),
        eventBubbles: typeof rawEventOpts.bubbles === 'boolean' ? rawEventOpts.bubbles : true,
        eventCancelable: typeof rawEventOpts.cancelable === 'boolean' ? rawEventOpts.cancelable : true,
        eventComposed: typeof rawEventOpts.composed === 'boolean' ? rawEventOpts.composed : true
    };
}
function getEventName$1(diagnostics, rawEventOpts, memberName) {
    if (typeof rawEventOpts.eventName === 'string' && rawEventOpts.eventName.trim().length > 0) {
        // always use the event name if given
        return rawEventOpts.eventName.trim();
    }
    // event name wasn't provided
    // so let's default to use the member name
    validateEventEmitterMemeberName(diagnostics, memberName);
    return memberName;
}
function validateEventEmitterMemeberName(diagnostics, memberName) {
    const firstChar = memberName.charAt(0);
    if (/[A-Z]/.test(firstChar)) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = [
            `In order to be compatible with all event listeners on elements, the `,
            `@Event() "${memberName}" cannot start with a capital letter. `,
            `Please lowercase the first character for the event to best work with all listeners.`
        ].join('');
    }
}
function gatherEventEmitterGeneric(type) {
    if (ts.isTypeReferenceNode(type) &&
        ts.isIdentifier(type.typeName) &&
        type.typeName.text === 'EventEmitter' &&
        type.typeArguments &&
        type.typeArguments.length > 0) {
        const eeGen = type.typeArguments[0];
        return eeGen;
    }
    return null;
}

function getListenDecoratorMeta(checker, classNode) {
    const listeners = [];
    classNode.members
        .filter(isMethodWithDecorators)
        .forEach(member => {
        member.decorators
            .filter(isDecoratorNamed('Listen'))
            .map(dec => getDeclarationParameters(dec))
            .forEach(([listenText, listenOptions]) => {
            listenText.split(',').forEach(eventName => {
                const symbol = checker.getSymbolAtLocation(member.name);
                const jsdoc = serializeSymbol(checker, symbol);
                listeners.push(Object.assign({}, validateListener(eventName.trim(), listenOptions, member.name.getText()), { jsdoc }));
            });
        });
    });
    return listeners;
}
function validateListener(eventName, rawListenOpts = {}, methodName) {
    let rawEventName = eventName;
    let splt = eventName.split(':');
    if (splt.length > 2) {
        throw new Error(`@Listen can only contain one colon: ${eventName}`);
    }
    if (splt.length > 1) {
        const prefix = splt[0].toLowerCase().trim();
        if (!isValidElementRefPrefix(prefix)) {
            throw new Error(`invalid @Listen prefix "${prefix}" for "${eventName}"`);
        }
        rawEventName = splt[1].toLowerCase().trim();
    }
    splt = rawEventName.split('.');
    if (splt.length > 2) {
        throw new Error(`@Listen can only contain one period: ${eventName}`);
    }
    if (splt.length > 1) {
        const suffix = splt[1].toLowerCase().trim();
        if (!isValidKeycodeSuffix(suffix)) {
            throw new Error(`invalid @Listen suffix "${suffix}" for "${eventName}"`);
        }
        rawEventName = splt[0].toLowerCase().trim();
    }
    const listenMeta = {
        eventName: eventName,
        eventMethodName: methodName
    };
    listenMeta.eventCapture = (typeof rawListenOpts.capture === 'boolean') ? rawListenOpts.capture : false;
    listenMeta.eventPassive = (typeof rawListenOpts.passive === 'boolean') ? rawListenOpts.passive :
        // if the event name is kown to be a passive event then set it to true
        (PASSIVE_TRUE_DEFAULTS.indexOf(rawEventName.toLowerCase()) > -1);
    // default to enabled=true if it wasn't provided
    listenMeta.eventDisabled = (rawListenOpts.enabled === false);
    return listenMeta;
}
function isValidElementRefPrefix(prefix) {
    return (VALID_ELEMENT_REF_PREFIXES.indexOf(prefix) > -1);
}
function isValidKeycodeSuffix(prefix) {
    return (VALID_KEYCODE_SUFFIX.indexOf(prefix) > -1);
}
const PASSIVE_TRUE_DEFAULTS = [
    'dragstart', 'drag', 'dragend', 'dragenter', 'dragover', 'dragleave', 'drop',
    'mouseenter', 'mouseover', 'mousemove', 'mousedown', 'mouseup', 'mouseleave', 'mouseout', 'mousewheel',
    'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave',
    'resize',
    'scroll',
    'touchstart', 'touchmove', 'touchend', 'touchenter', 'touchleave', 'touchcancel',
    'wheel',
];
const VALID_ELEMENT_REF_PREFIXES = [
    'child', 'parent', 'body', 'document', 'window'
];
const VALID_KEYCODE_SUFFIX = [
    'enter', 'escape', 'space', 'tab', 'up', 'right', 'down', 'left'
];

function validatePublicName(diagnostics, componentClass, memberName, decorator, memberType) {
    if (isReservedMember(memberName)) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = [
            `The ${decorator} name "${memberName}" used within the "${componentClass}" class is a reserved public name. `,
            `Please rename the "${memberName}" ${memberType} so it does not conflict with an existing standardized prototype member. `,
            `Reusing ${memberType} names that are already defined on the element's prototype may cause `,
            `unexpected runtime errors or user-interface issues on various browsers, so it's best to avoid them entirely.`
        ].join('');
    }
}
const READ_ONLY_PROPERTIES = [
    'attributes',
    'baseURI',
    'childElementCount',
    'childNodes',
    'children',
    'classList',
    'clientHeight',
    'clientLeft',
    'clientTop',
    'clientWidth',
    'contentEditable',
    'dataset',
    'firstChild',
    'firstElementChild',
    'host',
    'isConnected',
    'isContentEditable',
    'lastChild',
    'lastElementChild',
    'localName',
    'namespaceURI',
    'nextElementSibling',
    'nextSibling',
    'nodeName',
    'nodePrincipal',
    'nodeType',
    'nodeValue',
    'offsetHeight',
    'offsetLeft',
    'offsetParent',
    'offsetTop',
    'offsetWidth',
    'ownerDocument',
    'parentElement',
    'parentNode',
    'prefix',
    'previousElementSibling',
    'previousSibling',
    'rootNode',
    'runtimeStyle',
    'scrollHeight',
    'scrollLeft',
    'scrollLeftMax',
    'scrollTop',
    'scrollTopMax',
    'scrollWidth',
    'shadowRoot',
    'slot',
    'tagName',
    'title',
];
const METHODS = [
    'addEventListener',
    'after',
    'animate',
    'append',
    'appendChild',
    'attachEvent',
    'attachShadow',
    'before',
    'blur',
    'click',
    'cloneNode',
    'closest',
    'compareDocumentPosition',
    'contains',
    'detachEvent',
    'dispatchEvent',
    'fireEvent',
    'focus',
    'getAttribute',
    'getAttributeNames',
    'getAttributeNode',
    'getAttributeNodeNS',
    'getAttributeNS',
    'getBoundingClientRect',
    'getClientRects',
    'getElementsByClassName',
    'getElementsByTagName',
    'getElementsByTagNameNS',
    'getRootNode',
    'getUserData',
    'hasAttribute',
    'hasAttributeNS',
    'hasAttributes',
    'hasChildNodes',
    'insertAdjacentElement',
    'insertAdjacentHTML',
    'insertAdjacentText',
    'insertBefore',
    'isDefaultNamespace',
    'isEqualNode',
    'isSameNode',
    'isSupported',
    'lookupNamespaceURI',
    'lookupPrefix',
    'matches',
    'normalize',
    'prepend',
    'querySelector',
    'querySelectorAll',
    'querySelectorAll',
    'releasePointerCapture',
    'removeChild',
    'remove',
    'removeAttribute',
    'removeAttributeNode',
    'removeAttributeNS',
    'removeEventListener',
    'replaceChild',
    'replaceWith',
    'requestFullscreen',
    'requestPointerLock',
    'scrollIntoView',
    'scrollIntoViewIfNeeded',
    'setAttribute',
    'setAttributeNode',
    'setAttributeNodeNS',
    'setAttributeNS',
    'setCapture',
    'setPointerCapture',
];
const EVENT_HANDLERS = [
    'onabort',
    'onanimationend',
    'onanimationendcapture',
    'onanimationiteration',
    'onanimationiterationcapture',
    'onanimationstart',
    'onanimationstartcapture',
    'onauxclick',
    'onbeforecopy',
    'onbeforecut',
    'onbeforepaste',
    'onblur',
    'onblurcapture',
    'oncancel',
    'oncanplaythrough',
    'onchange',
    'onchangecapture',
    'onclick',
    'onclickcapture',
    'onclose',
    'oncompositionend',
    'oncompositionendcapture',
    'oncompositionstart',
    'oncompositionstartcapture',
    'oncompositionupdate',
    'oncompositionupdatecapture',
    'oncontextmenu',
    'oncontextmenucapture',
    'oncopy',
    'oncopycapture',
    'oncuechange',
    'oncut',
    'oncutcapture',
    'ondblclick',
    'ondblclickcapture',
    'ondrag',
    'ondragcapture',
    'ondragend',
    'ondragendcapture',
    'ondragenter',
    'ondragentercapture',
    'ondragexit',
    'ondragexitcapture',
    'ondragleave',
    'ondragleavecapture',
    'ondragover',
    'ondragovercapture',
    'ondragstart',
    'ondragstartcapture',
    'ondrop',
    'ondropcapture',
    'ondurationchange',
    'onemptied',
    'onended',
    'onerror',
    'onerrorcapture',
    'onfocus',
    'onfocuscapture',
    'onfullscreenchange',
    'onfullscreenerror',
    'ongotpointercapture',
    'oninput',
    'oninputcapture',
    'oninvalid',
    'oninvalidcapture',
    'onkeydown',
    'onkeydowncapture',
    'onkeypress',
    'onkeypresscapture',
    'onkeyup',
    'onkeyupcapture',
    'onload',
    'onloadcapture',
    'onloadeddata',
    'onloadedmetadata',
    'onloadstart',
    'onlostpointercapture',
    'onmousedown',
    'onmousedowncapture',
    'onmouseenter',
    'onmouseleave',
    'onmousemove',
    'onmousemovecapture',
    'onmouseout',
    'onmouseoutcapture',
    'onmouseover',
    'onmouseovercapture',
    'onmouseup',
    'onmouseupcapture',
    'onpaste',
    'onpastecapture',
    'onpause',
    'onplay',
    'onplaying',
    'onpointercancel',
    'onpointerdown',
    'onpointerenter',
    'onpointerleave',
    'onpointermove',
    'onpointerout',
    'onpointerover',
    'onpointerup',
    'onprogress',
    'onratechange',
    'onreset',
    'onresetcapture',
    'onresize',
    'onscroll',
    'onscrollcapture',
    'onsearch',
    'onseeked',
    'onseeking',
    'onselectstart',
    'onstalled',
    'onsubmit',
    'onsubmitcapture',
    'onsuspend',
    'ontimeupdate',
    'ontoggle',
    'ontouchcancel',
    'ontouchcancelcapture',
    'ontouchend',
    'ontouchendcapture',
    'ontouchmove',
    'ontouchmovecapture',
    'ontouchstart',
    'ontouchstartcapture',
    'ontransitionend',
    'ontransitionendcapture',
    'onvolumechange',
    'onwaiting',
    'onwebkitfullscreenchange',
    'onwebkitfullscreenerror',
    'onwheel',
    'onwheelcapture',
];
const RESERVED_PUBLIC_MEMBERS = [
    ...READ_ONLY_PROPERTIES,
    ...METHODS,
    ...EVENT_HANDLERS
].map(p => p.toLowerCase());
function isReservedMember(memberName) {
    memberName = memberName.toLowerCase();
    return RESERVED_PUBLIC_MEMBERS.includes(memberName);
}

function getMethodDecoratorMeta(diagnostics, checker, classNode, sourceFile, componentClass) {
    return classNode.members
        .filter(isMethodWithDecorators)
        .reduce((membersMeta, member) => {
        const methodDecorator = member.decorators.find(isDecoratorNamed('Method'));
        if (methodDecorator == null) {
            return membersMeta;
        }
        const symbol = checker.getSymbolAtLocation(member.name);
        const methodName = member.name.getText();
        const methodSignature = checker.getSignatureFromDeclaration(member);
        const returnType = checker.getReturnTypeOfSignature(methodSignature);
        const typeString = checker.signatureToString(methodSignature, undefined, ts.TypeFormatFlags.WriteArrowStyleSignature, ts.SignatureKind.Call);
        let methodReturnTypes = {};
        const returnTypeNode = checker.typeToTypeNode(returnType);
        if (returnTypeNode) {
            methodReturnTypes = getAttributeTypeInfo(returnTypeNode, sourceFile);
        }
        validatePublicName(diagnostics, componentClass, methodName, '@Method()', 'method');
        membersMeta[methodName] = {
            memberType: 6 /* Method */,
            attribType: {
                text: typeString,
                typeReferences: Object.assign({}, methodReturnTypes, getAttributeTypeInfo(member, sourceFile))
            },
            jsdoc: serializeSymbol(checker, symbol)
        };
        return membersMeta;
    }, {});
}

function getPropDecoratorMeta(diagnostics, checker, classNode, sourceFile, componentClass) {
    return classNode.members
        .filter(member => Array.isArray(member.decorators) && member.decorators.length > 0)
        .reduce((allMembers, prop) => {
        const memberData = {};
        const propDecorator = prop.decorators.find(isDecoratorNamed('Prop'));
        if (propDecorator == null) {
            return allMembers;
        }
        const propOptions = getPropOptions(propDecorator, diagnostics);
        const memberName = prop.name.text;
        const symbol = checker.getSymbolAtLocation(prop.name);
        if (propOptions && typeof propOptions.connect === 'string') {
            // @Prop({ connect: 'ion-alert-controller' })
            memberData.memberType = 4 /* PropConnect */;
            memberData.ctrlId = propOptions.connect;
        }
        else if (propOptions && typeof propOptions.context === 'string') {
            // @Prop({ context: 'config' })
            memberData.memberType = 3 /* PropContext */;
            memberData.ctrlId = propOptions.context;
        }
        else {
            // @Prop()
            const type = checker.getTypeAtLocation(prop);
            validatePublicName(diagnostics, componentClass, memberName, '@Prop()', 'property');
            memberData.memberType = getMemberType(propOptions);
            memberData.attribName = getAttributeName(propOptions, memberName);
            memberData.attribType = getAttribType(diagnostics, sourceFile, prop);
            memberData.reflectToAttrib = getReflectToAttr(propOptions);
            memberData.propType = propTypeFromTSType(type, memberData.attribType.text);
            memberData.jsdoc = serializeSymbol(checker, symbol);
        }
        allMembers[memberName] = memberData;
        return allMembers;
    }, {});
}
function getPropOptions(propDecorator, diagnostics) {
    const suppliedOptions = propDecorator.expression.arguments
        .map(arg => {
        try {
            const fnStr = `return ${arg.getText()};`;
            return new Function(fnStr)();
        }
        catch (e) {
            const d = catchError(diagnostics, e);
            d.messageText = `parse prop options: ${e}`;
        }
    });
    const propOptions = suppliedOptions[0];
    return propOptions;
}
function getMemberType(propOptions) {
    if (propOptions && propOptions.mutable === true) {
        return 2 /* PropMutable */;
    }
    return 1 /* Prop */;
}
function getAttributeName(propOptions, memberName) {
    if (propOptions && typeof propOptions.attr === 'string' && propOptions.attr.trim().length > 0) {
        return propOptions.attr.trim();
    }
    return toDashCase(memberName);
}
function getReflectToAttr(propOptions) {
    if (propOptions && propOptions.reflectToAttr === true) {
        return true;
    }
    return false;
}
function getAttribType(diagnostics, sourceFile, prop) {
    let attribType;
    // If the @Prop() attribute does not have a defined type then infer it
    if (!prop.type) {
        let attribTypeText = inferPropType(prop.initializer);
        if (!attribTypeText) {
            attribTypeText = 'any';
            const diagnostic = buildWarn(diagnostics);
            diagnostic.messageText = `Prop type provided is not supported, defaulting to any: '${prop.getFullText()}'`;
        }
        attribType = {
            text: attribTypeText,
        };
    }
    else {
        attribType = {
            text: prop.type.getText(),
            typeReferences: getAttributeTypeInfo(prop.type, sourceFile)
        };
    }
    return attribType;
}
function inferPropType(expression) {
    if (expression == null) {
        return undefined;
    }
    if (ts.isStringLiteral(expression)) {
        return 'string';
    }
    if (ts.isNumericLiteral(expression)) {
        return 'number';
    }
    if ([ts.SyntaxKind.BooleanKeyword, ts.SyntaxKind.TrueKeyword, ts.SyntaxKind.FalseKeyword].indexOf(expression.kind) !== -1) {
        return 'boolean';
    }
    if ((ts.SyntaxKind.NullKeyword === expression.kind) ||
        (ts.SyntaxKind.UndefinedKeyword === expression.kind) ||
        (ts.isRegularExpressionLiteral(expression)) ||
        (ts.isArrayLiteralExpression(expression)) ||
        (ts.isObjectLiteralExpression(expression))) {
        return 'any';
    }
    return undefined;
}
function propTypeFromTSType(type, text) {
    const isStr = checkType(type, isString);
    const isNu = checkType(type, isNumber);
    const isBool = checkType(type, isBoolean);
    // if type is more than a primitive type at the same time, we mark it as any
    if (Number(isStr) + Number(isNu) + Number(isBool) > 1) {
        return 1 /* Any */;
    }
    // at this point we know the prop's type is NOT the mix of primitive types
    if (isStr) {
        return 2 /* String */;
    }
    if (isNu) {
        return 4 /* Number */;
    }
    if (isBool) {
        return 3 /* Boolean */;
    }
    if (text === 'any') {
        return 1 /* Any */;
    }
    return 0 /* Unknown */;
}
function checkType(type, check) {
    if (type.flags & ts.TypeFlags.Union) {
        const union = type;
        if (union.types.some(type => checkType(type, check))) {
            return true;
        }
    }
    return check(type);
}
function isBoolean(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLike | ts.TypeFlags.BooleanLike));
    }
    return false;
}
function isNumber(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral));
    }
    return false;
}
function isString(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral));
    }
    return false;
}

function getStateDecoratorMeta(classNode) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('State'));
        if (elementDecorator) {
            membersMeta[member.name.getText()] = {
                memberType: 5 /* State */
            };
        }
        return membersMeta;
    }, {});
}

function getWatchDecoratorMeta(diagnostics, classNode, cmpMeta) {
    const methods = classNode.members.filter(isMethodWithDecorators);
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'Watch');
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'PropWillChange');
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'PropDidChange');
}
function getChangeMetaByName(diagnostics, methods, cmpMeta, decoratorName) {
    methods.forEach(({ decorators, name }) => {
        decorators
            .filter(isDecoratorNamed(decoratorName))
            .forEach(propChangeDecorator => {
            const [propName] = getDeclarationParameters(propChangeDecorator);
            if (propName) {
                updateWatchCallback(diagnostics, cmpMeta, propName, name, decoratorName);
            }
        });
    });
}
function updateWatchCallback(diagnostics, cmpMeta, propName, decoratorData, decoratorName) {
    if (!isPropWatchable(cmpMeta, propName)) {
        const error = buildError(diagnostics);
        error.messageText = `@Watch('${propName}') is trying to watch for changes in a property that does not exist.
Make sure only properties decorated with @State() or @Prop() are watched.`;
        return;
    }
    cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
    cmpMeta.membersMeta[propName].watchCallbacks.push(decoratorData.getText());
    if (decoratorName === 'PropWillChange' || decoratorName === 'PropDidChange') {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = `@${decoratorName}('${propName}') decorator within "${cmpMeta.tagNameMeta}" component has been deprecated. Please update to @Watch('${propName}').`;
    }
}
function isPropWatchable(cmpMeta, propName) {
    const membersMeta = cmpMeta.membersMeta;
    if (!membersMeta) {
        return false;
    }
    const member = membersMeta[propName];
    if (!member) {
        return false;
    }
    const type = member.memberType;
    return type === 5 /* State */ || type === 1 /* Prop */ || type === 2 /* PropMutable */;
}

function validateComponentClass(diagnostics, cmpMeta, classNode) {
    requiresReturnStatement(diagnostics, cmpMeta, classNode, 'hostData');
    requiresReturnStatement(diagnostics, cmpMeta, classNode, 'render');
}
function requiresReturnStatement(diagnostics, cmpMeta, classNode, methodName) {
    const classElm = classNode.members.find(m => isMethod(m, methodName));
    if (!classElm)
        return;
    let hasReturn = false;
    function visitNode(node) {
        if (node.kind === ts.SyntaxKind.ReturnStatement) {
            hasReturn = true;
        }
        ts.forEachChild(node, visitNode);
    }
    ts.forEachChild(classElm, visitNode);
    if (!hasReturn) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = `The "${methodName}()" method within the "${cmpMeta.tagNameMeta}" component is missing a "return" statement.`;
    }
}

function gatherMetadata(config, compilerCtx, diagnostics, collections, typechecker, sourceFileList) {
    const componentMetaList = {};
    const visitFile = visitFactory(config, diagnostics, compilerCtx, collections, typechecker, componentMetaList);
    // Visit every sourceFile in the program
    for (const sourceFile of sourceFileList) {
        ts.forEachChild(sourceFile, (node) => {
            visitFile(node, node);
        });
    }
    return componentMetaList;
}
function visitFactory(config, diagnostics, compilerCtx, collections, checker, componentMetaList) {
    return function visit(node, sourceFile) {
        if (node.kind === ts.SyntaxKind.ImportDeclaration) {
            getCollections(config, compilerCtx, collections, node);
        }
        if (ts.isClassDeclaration(node)) {
            const cmpMeta = visitClass(diagnostics, checker, node, sourceFile);
            if (cmpMeta) {
                const tsFilePath = normalizePath(sourceFile.getSourceFile().fileName);
                componentMetaList[tsFilePath] = cmpMeta;
            }
        }
        ts.forEachChild(node, (node) => {
            visit(node, sourceFile);
        });
    };
}
function visitClass(diagnostics, checker, classNode, sourceFile) {
    let cmpMeta = getComponentDecoratorMeta(diagnostics, checker, classNode);
    if (!cmpMeta) {
        return undefined;
    }
    const componentClass = classNode.name.getText().trim();
    cmpMeta = Object.assign({}, cmpMeta, { componentClass: componentClass, membersMeta: Object.assign({}, getElementDecoratorMeta(checker, classNode), getMethodDecoratorMeta(diagnostics, checker, classNode, sourceFile, componentClass), getStateDecoratorMeta(classNode), getPropDecoratorMeta(diagnostics, checker, classNode, sourceFile, componentClass)), eventsMeta: getEventDecoratorMeta(diagnostics, checker, classNode, sourceFile), listenersMeta: getListenDecoratorMeta(checker, classNode) });
    // watch meta collection MUST happen after prop/state decorator meta collection
    getWatchDecoratorMeta(diagnostics, classNode, cmpMeta);
    // validate the user's component class for any common errors
    validateComponentClass(diagnostics, cmpMeta, classNode);
    // Return Class Declaration with Decorator removed and as default export
    return cmpMeta;
}

function normalizeAssetsDir(config, componentFilePath, assetsMetas) {
    return assetsMetas.map((assetMeta) => {
        return Object.assign({}, assetMeta, normalizeAssetDir(config, componentFilePath, assetMeta.originalComponentPath));
    });
}
function normalizeAssetDir(config, componentFilePath, assetsDir) {
    const assetsMeta = {};
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(componentFilePath));
    // get the relative path from the component file to the assets directory
    assetsDir = normalizePath(assetsDir.trim());
    if (config.sys.path.isAbsolute(assetsDir)) {
        // this path is absolute already!
        // add as the absolute path
        assetsMeta.absolutePath = assetsDir;
        // if this is an absolute path already, let's convert it to be relative
        assetsMeta.cmpRelativePath = config.sys.path.relative(componentDir, assetsDir);
    }
    else {
        // this path is relative to the component
        assetsMeta.cmpRelativePath = assetsDir;
        // create the absolute path to the asset dir
        assetsMeta.absolutePath = pathJoin(config, componentDir, assetsDir);
    }
    return assetsMeta;
}

function normalizeStyles(config, componentFilePath, stylesMeta) {
    const newStylesMeta = {};
    Object.keys(stylesMeta).forEach((modeName) => {
        newStylesMeta[modeName] = {
            externalStyles: []
        };
        const externalStyles = stylesMeta[modeName].externalStyles || [];
        newStylesMeta[modeName].externalStyles = externalStyles.map(externalStyle => {
            const { cmpRelativePath, absolutePath } = normalizeModeStylePaths(config, componentFilePath, externalStyle.originalComponentPath);
            const normalizedExternalStyles = {
                absolutePath: absolutePath,
                cmpRelativePath: cmpRelativePath,
                originalComponentPath: externalStyle.originalComponentPath,
                originalCollectionPath: externalStyle.originalCollectionPath
            };
            return normalizedExternalStyles;
        });
        if (typeof stylesMeta[modeName].styleStr === 'string') {
            newStylesMeta[modeName].styleStr = stylesMeta[modeName].styleStr;
        }
    });
    return newStylesMeta;
}
function normalizeModeStylePaths(config, componentFilePath, stylePath) {
    let cmpRelativePath;
    let absolutePath;
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(componentFilePath));
    // get the relative path from the component file to the style
    let componentRelativeStylePath = normalizePath(stylePath.trim());
    if (config.sys.path.isAbsolute(componentRelativeStylePath)) {
        // this path is absolute already!
        // add to our list of style absolute paths
        absolutePath = componentRelativeStylePath;
        // if this is an absolute path already, let's convert it to be relative
        componentRelativeStylePath = config.sys.path.relative(componentDir, componentRelativeStylePath);
        // add to our list of style relative paths
        cmpRelativePath = componentRelativeStylePath;
    }
    else {
        // this path is relative to the component
        // add to our list of style relative paths
        cmpRelativePath = componentRelativeStylePath;
        // create the absolute path to the style file
        const absoluteStylePath = normalizePath(config.sys.path.join(componentDir, componentRelativeStylePath));
        // add to our list of style absolute paths
        absolutePath = absoluteStylePath;
    }
    return {
        cmpRelativePath,
        absolutePath
    };
}

var __awaiter$20 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateComponentTypes(config, compilerCtx, buildCtx, tsOptions, tsHost, tsFilePaths, componentsDtsSrcFilePath) {
    return __awaiter$20(this, void 0, void 0, function* () {
        // get all of the ts files paths to transpile
        // ensure the components.d.ts file is always excluded from this transpile program
        const checkProgramTsFiles = tsFilePaths.filter(filePath => filePath !== componentsDtsSrcFilePath);
        // keep track of how many files we transpiled (great for debugging/testing)
        buildCtx.transpileBuildCount = checkProgramTsFiles.length;
        // run the first program that only does the checking
        const checkProgram = ts.createProgram(checkProgramTsFiles, tsOptions, tsHost);
        // program's source files also include imported files.
        // let's filter them, we only want to gather metadata from .ts/.tsx files in project's src
        const sourceFiles = checkProgram.getSourceFiles().filter(sf => checkProgramTsFiles.includes(sf.fileName));
        // gather component metadata and type info
        const metadata = gatherMetadata(config, compilerCtx, buildCtx.diagnostics, buildCtx.collections, checkProgram.getTypeChecker(), sourceFiles);
        // create angular directive proxy outputs
        angularDirectiveProxyOutputs(config, compilerCtx, metadata);
        Object.keys(metadata).forEach(key => {
            const tsFilePath = normalizePath(key);
            const fileMetadata = metadata[tsFilePath];
            // normalize metadata
            fileMetadata.stylesMeta = normalizeStyles(config, tsFilePath, fileMetadata.stylesMeta);
            fileMetadata.assetsDirsMeta = normalizeAssetsDir(config, tsFilePath, fileMetadata.assetsDirsMeta);
            // assign metadata to module files
            if (!compilerCtx.moduleFiles[tsFilePath]) {
                compilerCtx.moduleFiles[tsFilePath] = {};
            }
            compilerCtx.moduleFiles[tsFilePath].cmpMeta = fileMetadata;
        });
        // Generate d.ts files for component types
        let componentTypesFileContent = yield generateComponentTypesFile(config, compilerCtx, metadata);
        // get all the output targets that require types
        const typesOutputTargets = config.outputTargets.filter(o => !!o.typesDir);
        if (typesOutputTargets.length > 0) {
            // we're building a dist output target(s)
            // so let's also add the types for the defineCustomElements
            componentTypesFileContent = appendDefineCustomElementsType(componentTypesFileContent);
        }
        // queue the components.d.ts async file write and put it into memory
        yield compilerCtx.fs.writeFile(componentsDtsSrcFilePath, componentTypesFileContent, { immediateWrite: true });
        yield Promise.all(typesOutputTargets.map((outputTarget) => __awaiter$20(this, void 0, void 0, function* () {
            const typesFile = getComponentsDtsTypesFilePath(config, outputTarget);
            yield compilerCtx.fs.writeFile(typesFile, componentTypesFileContent);
        })));
        return checkProgram;
    });
}
/**
 * Generate the component.d.ts file that contains types for all components
 * @param config the project build configuration
 * @param options compiler options from tsconfig
 */
function generateComponentTypesFile(config, compilerCtx, cmpList) {
    return __awaiter$20(this, void 0, void 0, function* () {
        let typeImportData = {};
        const allTypes = {};
        let componentsFileContent = `/**
 * This is an autogenerated file created by the Stencil build process.
 * It contains typing information for all components that exist in this project
 * and imports for stencil collections that might be configured in your stencil.config.js file
 */

import '@stencil/core';

declare global {
  namespace JSX {
    interface Element {}
    export interface IntrinsicElements {}
  }
  namespace JSXElements {}

  interface HTMLStencilElement extends HTMLElement {
    componentOnReady(): Promise<this>;
    componentOnReady(done: (ele?: this) => void): void;

    forceUpdate(): void;
  }

  interface HTMLAttributes {}
}\n\n`;
        const collectionTypesImports = yield getCollectionsTypeImports(config, compilerCtx);
        componentsFileContent += collectionTypesImports;
        const componentFileString = Object.keys(cmpList)
            .filter(moduleFileName => cmpList[moduleFileName] != null)
            .sort()
            .reduce((finalString, moduleFileName) => {
            const cmpMeta = cmpList[moduleFileName];
            const importPath = normalizePath(config.sys.path.relative(config.srcDir, moduleFileName)
                .replace(/\.(tsx|ts)$/, ''));
            typeImportData = updateReferenceTypeImports(config, typeImportData, allTypes, cmpMeta, moduleFileName);
            finalString +=
                `${createTypesAsString(cmpMeta, importPath)}\n`;
            return finalString;
        }, '');
        const typeImportString = Object.keys(typeImportData).reduce((finalString, filePath) => {
            const typeData = typeImportData[filePath];
            let importFilePath;
            if (config.sys.path.isAbsolute(filePath)) {
                importFilePath = normalizePath('./' +
                    config.sys.path.relative(config.srcDir, filePath)).replace(/\.(tsx|ts)$/, '');
            }
            else {
                importFilePath = filePath;
            }
            finalString +=
                `import {
${typeData.sort(sortImportNames).map(td => {
                    if (td.localName === td.importName) {
                        return `  ${td.importName},`;
                    }
                    else {
                        return `  ${td.localName} as ${td.importName},`;
                    }
                }).join('\n')}
} from '${importFilePath}';\n`;
            return finalString;
        }, '');
        componentsFileContent += typeImportString + componentFileString;
        if (componentFileString.includes('namespace JSX')) {
            componentsFileContent += `declare global { namespace JSX { interface StencilJSX {} } }\n`;
        }
        return componentsFileContent;
    });
}
function sortImportNames(a, b) {
    const aName = a.localName.toLowerCase();
    const bName = b.localName.toLowerCase();
    if (aName < bName)
        return -1;
    if (aName > bName)
        return 1;
    if (a.localName < b.localName)
        return -1;
    if (a.localName > b.localName)
        return 1;
    return 0;
}
/**
 * Find all referenced types by a component and add them to the importDataObj and return the newly
 * updated importDataObj
 *
 * @param importDataObj key/value of type import file, each value is an array of imported types
 * @param cmpMeta the metadata for the component that is referencing the types
 * @param filePath the path of the component file
 * @param config general config that all of stencil uses
 */
function updateReferenceTypeImports(config, importDataObj, allTypes, cmpMeta, filePath) {
    const updateImportReferences = updateImportReferenceFactory(config, allTypes, filePath);
    importDataObj = Object.keys(cmpMeta.membersMeta)
        .filter((memberName) => {
        const member = cmpMeta.membersMeta[memberName];
        return [1 /* Prop */, 2 /* PropMutable */, 6 /* Method */].indexOf(member.memberType) !== -1 &&
            member.attribType.typeReferences;
    })
        .reduce((obj, memberName) => {
        const member = cmpMeta.membersMeta[memberName];
        return updateImportReferences(obj, member.attribType.typeReferences);
    }, importDataObj);
    cmpMeta.eventsMeta
        .filter((meta) => {
        return meta.eventType && meta.eventType.typeReferences;
    })
        .reduce((obj, meta) => {
        return updateImportReferences(obj, meta.eventType.typeReferences);
    }, importDataObj);
    return importDataObj;
}
function updateImportReferenceFactory(config, allTypes, filePath) {
    function getIncrememntTypeName(name) {
        if (allTypes[name] == null) {
            allTypes[name] = 1;
            return name;
        }
        allTypes[name] += 1;
        return `${name}${allTypes[name]}`;
    }
    return (obj, typeReferences) => {
        Object.keys(typeReferences).map(typeName => {
            return [typeName, typeReferences[typeName]];
        }).forEach(([typeName, type]) => {
            let importFileLocation;
            // If global then there is no import statement needed
            if (type.referenceLocation === 'global') {
                return;
                // If local then import location is the current file
            }
            else if (type.referenceLocation === 'local') {
                importFileLocation = filePath;
            }
            else if (type.referenceLocation === 'import') {
                importFileLocation = type.importReferenceLocation;
            }
            // If this is a relative path make it absolute
            if (importFileLocation.startsWith('.')) {
                importFileLocation =
                    config.sys.path.resolve(config.sys.path.dirname(filePath), importFileLocation);
            }
            obj[importFileLocation] = obj[importFileLocation] || [];
            // If this file already has a reference to this type move on
            if (obj[importFileLocation].find(df => df.localName === typeName)) {
                return;
            }
            const newTypeName = getIncrememntTypeName(typeName);
            obj[importFileLocation].push({
                localName: typeName,
                importName: newTypeName
            });
        });
        return obj;
    };
}
/**
 * Generate a string based on the types that are defined within a component.
 *
 * @param cmpMeta the metadata for the component that a type definition string is generated for
 * @param importPath the path of the component file
 */
function createTypesAsString(cmpMeta, _importPath) {
    const tagName = cmpMeta.tagNameMeta;
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagNameMeta);
    const interfaceName = `HTML${tagNameAsPascal}Element`;
    const jsxInterfaceName = `${tagNameAsPascal}Attributes`;
    const propAttributes = membersToPropAttributes(cmpMeta.membersMeta);
    const methodAttributes = membersToMethodAttributes(cmpMeta.membersMeta);
    const eventAttributes = membersToEventAttributes(cmpMeta.eventsMeta);
    return `
declare global {

  namespace StencilComponents {
    interface ${tagNameAsPascal} {
${attributesToMultiLineString(Object.assign({}, propAttributes, methodAttributes), false, '      ')}
    }
  }

  interface ${interfaceName} extends StencilComponents.${tagNameAsPascal}, HTMLStencilElement {}

  var ${interfaceName}: {
    prototype: ${interfaceName};
    new (): ${interfaceName};
  };
  interface HTMLElementTagNameMap {
    '${tagName}': ${interfaceName};
  }
  interface ElementTagNameMap {
    '${tagName}': ${interfaceName};
  }
  namespace JSX {
    interface IntrinsicElements {
      '${tagName}': JSXElements.${jsxInterfaceName};
    }
  }
  namespace JSXElements {
    export interface ${jsxInterfaceName} extends HTMLAttributes {
${attributesToMultiLineString(Object.assign({}, propAttributes, eventAttributes), true, '      ')}
    }
  }
}
`;
}
function attributesToMultiLineString(attributes, optional = true, paddingString) {
    return Object.keys(attributes)
        .sort()
        .reduce((fullList, key) => {
        if (attributes[key].jsdoc) {
            fullList.push(`/**`);
            fullList.push(` * ${attributes[key].jsdoc.replace(/\r?\n|\r/g, ' ')}`);
            fullList.push(` */`);
        }
        fullList.push(`'${key}'${optional ? '?' : ''}: ${attributes[key].type};`);
        return fullList;
    }, [])
        .map(item => `${paddingString}${item}`)
        .join(`\n`);
}
function membersToPropAttributes(membersMeta) {
    const interfaceData = Object.keys(membersMeta)
        .filter((memberName) => {
        return [1 /* Prop */, 2 /* PropMutable */].indexOf(membersMeta[memberName].memberType) !== -1;
    })
        .reduce((obj, memberName) => {
        const member = membersMeta[memberName];
        obj[memberName] = {
            type: member.attribType.text,
        };
        if (member.jsdoc) {
            obj[memberName].jsdoc = member.jsdoc.documentation;
        }
        return obj;
    }, {});
    return interfaceData;
}
function membersToMethodAttributes(membersMeta) {
    const interfaceData = Object.keys(membersMeta)
        .filter((memberName) => {
        return [6 /* Method */].indexOf(membersMeta[memberName].memberType) !== -1;
    })
        .reduce((obj, memberName) => {
        const member = membersMeta[memberName];
        obj[memberName] = {
            type: member.attribType.text,
        };
        if (member.jsdoc) {
            obj[memberName].jsdoc = member.jsdoc.documentation;
        }
        return obj;
    }, {});
    return interfaceData;
}
function membersToEventAttributes(eventMetaList) {
    const interfaceData = eventMetaList
        .reduce((obj, eventMetaObj) => {
        const memberName = `on${captializeFirstLetter(eventMetaObj.eventName)}`;
        const eventType = (eventMetaObj.eventType) ? `CustomEvent<${eventMetaObj.eventType.text}>` : `CustomEvent`;
        obj[memberName] = {
            type: `(event: ${eventType}) => void`,
        };
        if (eventMetaObj.jsdoc) {
            obj[memberName].jsdoc = eventMetaObj.jsdoc.documentation;
        }
        return obj;
    }, {});
    return interfaceData;
}
function getCollectionsTypeImports(config, compilerCtx) {
    return __awaiter$20(this, void 0, void 0, function* () {
        const collections = compilerCtx.collections.map(collection => {
            return getCollectionTypesImport(config, compilerCtx, collection);
        });
        const collectionTypes = yield Promise.all(collections);
        if (collectionTypes.length > 0) {
            return `${collectionTypes.join('\n')}\n\n`;
        }
        return '';
    });
}
function getCollectionTypesImport(config, compilerCtx, collection) {
    return __awaiter$20(this, void 0, void 0, function* () {
        let typeImport = '';
        try {
            const collectionDir = collection.moduleDir;
            const collectionPkgJson = config.sys.path.join(collectionDir, 'package.json');
            const pkgJsonStr = yield compilerCtx.fs.readFile(collectionPkgJson);
            const pkgData = JSON.parse(pkgJsonStr);
            if (pkgData.types && pkgData.collection) {
                typeImport = `import '${pkgData.name}';`;
            }
        }
        catch (e) {
            config.logger.debug(`getCollectionTypesImport: ${e}`);
        }
        if (typeImport === '') {
            config.logger.debug(`unabled to find "${collection.collectionName}" collection types`);
        }
        return typeImport;
    });
}

function getTsHost(config, ctx, writeQueue, tsCompilerOptions) {
    const tsHost = ts.createCompilerHost(tsCompilerOptions);
    tsHost.directoryExists = (dirPath) => {
        dirPath = normalizePath(dirPath);
        try {
            const stat = ctx.fs.statSync(dirPath);
            return stat && stat.isDirectory;
        }
        catch (e) {
            return false;
        }
    };
    tsHost.getSourceFile = (filePath) => {
        filePath = normalizePath(filePath);
        let tsSourceFile = null;
        try {
            let content = ctx.fs.readFileSync(filePath);
            if (isDtsFile(filePath)) {
                if (content.includes('namespace JSX {') && !content.includes('StencilJSX')) {
                    // we currently have what seems to be an unsolvable problem where any third-party
                    // package can provide their own global JSX types, while stencil also
                    // provides them as a global in order for typescript to understand and use JSX
                    // types. So we're renaming any "other" imported global JSX namespaces so there
                    // are no collisions with the same global JSX interfaces stencil already has
                    // we're totally up for better ideas  ¯\_(ツ)_/¯
                    content = content.replace('namespace JSX {', `namespace JSX_NO_COLLISION_${Math.round(Math.random() * 99999999)} {`);
                    config.logger.debug(`renamed global JSX namespace collision: ${filePath}`);
                }
            }
            tsSourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.ES2017);
        }
        catch (e) {
            config.logger.error(`tsHost.getSourceFile unable to find: ${filePath}`, e);
        }
        return tsSourceFile;
    };
    tsHost.fileExists = (filePath) => {
        return ctx.fs.accessSync(filePath);
    },
        tsHost.readFile = (filePath) => {
            let sourceText = null;
            try {
                sourceText = ctx.fs.readFileSync(filePath);
            }
            catch (e) { }
            return sourceText;
        },
        tsHost.writeFile = (outputFilePath, outputText, _writeByteOrderMark, _onError, sourceFiles) => {
            sourceFiles.forEach(sourceFile => {
                writeQueue.push(writeFileInMemory(config, ctx, sourceFile, outputFilePath, outputText));
            });
        };
    return tsHost;
}
function writeFileInMemory(config, ctx, sourceFile, distFilePath, outputText) {
    let tsFilePath = normalizePath(sourceFile.fileName);
    if (!config.sys.path.isAbsolute(tsFilePath)) {
        tsFilePath = normalizePath(config.sys.path.join(config.rootDir, tsFilePath));
    }
    distFilePath = normalizePath(distFilePath);
    // get or create the ctx module file object
    if (!ctx.moduleFiles[tsFilePath]) {
        // we don't have this module in the ctx yet
        ctx.moduleFiles[tsFilePath] = {};
    }
    // figure out which file type this is
    if (isJsFile(distFilePath)) {
        // transpiled file is a js file
        ctx.moduleFiles[tsFilePath].jsFilePath = distFilePath;
    }
    else if (isDtsFile(distFilePath)) {
        // transpiled file is a .d.ts file
        ctx.moduleFiles[tsFilePath].dtsFilePath = distFilePath;
    }
    else {
        // idk, this shouldn't happen
        config.logger.debug(`unknown transpiled output: ${distFilePath}`);
    }
    // if this build is also building a distribution then we
    // actually want to eventually write the files to disk
    // otherwise we still want to put these files in our file system but
    // only as in-memory files and never are actually written to disk
    const isInMemoryOnly = distFilePath.includes(IN_MEMORY_DIR);
    // let's write the beast to our internal in-memory file system
    // the distFilePath is only written to disk when a distribution
    // is being created. But if we're not generating a distribution
    // like just a website, we still need to write it to our file system
    // so it can be read later, but it only needs to be in memory
    return ctx.fs.writeFile(distFilePath, outputText, { inMemoryOnly: isInMemoryOnly });
}

/**
 * Ported from highlight.js
 * Syntax highlighting with language autodetection.
 * https://highlightjs.org/
 * Copyright (c) 2006, Ivan Sagalaev
 * https://github.com/isagalaev/highlight.js/blob/master/LICENSE
 */
var hljs = {};
// Convenience variables for build-in objects
var objectKeys = Object.keys;
// Global internal variables used within the highlight.js library.
var languages = {}, aliases = {};
var spanEndTag = '</span>';
// Global options used when within external APIs. This is modified when
// calling the `hljs.configure` function.
var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
};
// Object map that is used to escape some common HTML characters.
var escapeRegexMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
/* Utility functions */
function escape(value) {
    return value.replace(/[&<>]/gm, function (character) {
        return escapeRegexMap[character];
    });
}
function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
}
function inherit(parent, obj) {
    var key;
    var result = {};
    for (key in parent)
        result[key] = parent[key];
    if (obj)
        for (key in obj)
            result[key] = obj[key];
    return result;
}
/* Initialization */
function compileLanguage(language) {
    function reStr(re) {
        return (re && re.source) || re;
    }
    function langRe(value, global) {
        return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }
    function compileMode(mode, parent) {
        if (mode.compiled)
            return;
        mode.compiled = true;
        mode.keywords = mode.keywords || mode.beginKeywords;
        if (mode.keywords) {
            var compiled_keywords = {};
            var flatten = function (className, str) {
                if (language.case_insensitive) {
                    str = str.toLowerCase();
                }
                str.split(' ').forEach(function (kw) {
                    var pair = kw.split('|');
                    compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
                });
            };
            if (typeof mode.keywords === 'string') { // string
                flatten('keyword', mode.keywords);
            }
            else {
                objectKeys(mode.keywords).forEach(function (className) {
                    flatten(className, mode.keywords[className]);
                });
            }
            mode.keywords = compiled_keywords;
        }
        mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);
        if (parent) {
            if (mode.beginKeywords) {
                mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
            }
            if (!mode.begin)
                mode.begin = /\B|\b/;
            mode.beginRe = langRe(mode.begin);
            if (!mode.end && !mode.endsWithParent)
                mode.end = /\B|\b/;
            if (mode.end)
                mode.endRe = langRe(mode.end);
            mode.terminator_end = reStr(mode.end) || '';
            if (mode.endsWithParent && parent.terminator_end)
                mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
        }
        if (mode.illegal)
            mode.illegalRe = langRe(mode.illegal);
        if (mode.relevance == null)
            mode.relevance = 1;
        if (!mode.contains) {
            mode.contains = [];
        }
        var expanded_contains = [];
        mode.contains.forEach(function (c) {
            if (c.variants) {
                c.variants.forEach(function (v) { expanded_contains.push(inherit(c, v)); });
            }
            else {
                expanded_contains.push(c === 'self' ? mode : c);
            }
        });
        mode.contains = expanded_contains;
        mode.contains.forEach(function (c) { compileMode(c, mode); });
        if (mode.starts) {
            compileMode(mode.starts, parent);
        }
        var terminators = mode.contains.map(function (c) {
            return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
        })
            .concat([mode.terminator_end, mode.illegal])
            .map(reStr)
            .filter(Boolean);
        mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function ( /*s*/) { return null; } };
    }
    compileMode(language);
}
/*
Core highlighting function. Accepts a language name, or an alias, and a
string with the code to highlight. Returns an object with the following
properties:

- relevance (int)
- value (an HTML string with highlighting markup)

*/
function highlight(name, value, ignore_illegals, continuation) {
    function subMode(lexeme, mode) {
        var i, length;
        for (i = 0, length = mode.contains.length; i < length; i++) {
            if (testRe(mode.contains[i].beginRe, lexeme)) {
                return mode.contains[i];
            }
        }
    }
    function endOfMode(mode, lexeme) {
        if (testRe(mode.endRe, lexeme)) {
            while (mode.endsParent && mode.parent) {
                mode = mode.parent;
            }
            return mode;
        }
        if (mode.endsWithParent) {
            return endOfMode(mode.parent, lexeme);
        }
    }
    function isIllegal(lexeme, mode) {
        return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }
    function keywordMatch(mode, match) {
        var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
        return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }
    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
        var classPrefix = noPrefix ? '' : options.classPrefix, openSpan = '<span class="' + classPrefix, closeSpan = leaveOpen ? '' : spanEndTag;
        openSpan += classname + '">';
        return openSpan + insideSpan + closeSpan;
    }
    function processKeywords() {
        var keyword_match, last_index, match, result;
        if (!top.keywords)
            return escape(mode_buffer);
        result = '';
        last_index = 0;
        top.lexemesRe.lastIndex = 0;
        match = top.lexemesRe.exec(mode_buffer);
        while (match) {
            result += escape(mode_buffer.substr(last_index, match.index - last_index));
            keyword_match = keywordMatch(top, match);
            if (keyword_match) {
                relevance += keyword_match[1];
                result += buildSpan(keyword_match[0], escape(match[0]));
            }
            else {
                result += escape(match[0]);
            }
            last_index = top.lexemesRe.lastIndex;
            match = top.lexemesRe.exec(mode_buffer);
        }
        return result + escape(mode_buffer.substr(last_index));
    }
    function processSubLanguage() {
        var explicit = typeof top.subLanguage === 'string';
        if (explicit && !languages[top.subLanguage]) {
            return escape(mode_buffer);
        }
        var result = explicit ?
            highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) :
            highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);
        // Counting embedded language score towards the host language may be disabled
        // with zeroing the containing mode relevance. Usecase in point is Markdown that
        // allows XML everywhere and makes every XML snippet to have a much larger Markdown
        // score.
        if (top.relevance > 0) {
            relevance += result.relevance;
        }
        if (explicit) {
            continuations[top.subLanguage] = result.top;
        }
        return buildSpan(result.language, result.value, false, true);
    }
    function processBuffer() {
        result += (top.subLanguage != null ? processSubLanguage() : processKeywords());
        mode_buffer = '';
    }
    function startNewMode(mode) {
        result += mode.className ? buildSpan(mode.className, '', true) : '';
        top = Object.create(mode, { parent: { value: top } });
    }
    function processLexeme(buffer, lexeme) {
        mode_buffer += buffer;
        if (lexeme == null) {
            processBuffer();
            return 0;
        }
        var new_mode = subMode(lexeme, top);
        if (new_mode) {
            if (new_mode.skip) {
                mode_buffer += lexeme;
            }
            else {
                if (new_mode.excludeBegin) {
                    mode_buffer += lexeme;
                }
                processBuffer();
                if (!new_mode.returnBegin && !new_mode.excludeBegin) {
                    mode_buffer = lexeme;
                }
            }
            startNewMode(new_mode);
            return new_mode.returnBegin ? 0 : lexeme.length;
        }
        var end_mode = endOfMode(top, lexeme);
        if (end_mode) {
            var origin = top;
            if (origin.skip) {
                mode_buffer += lexeme;
            }
            else {
                if (!(origin.returnEnd || origin.excludeEnd)) {
                    mode_buffer += lexeme;
                }
                processBuffer();
                if (origin.excludeEnd) {
                    mode_buffer = lexeme;
                }
            }
            do {
                if (top.className) {
                    result += spanEndTag;
                }
                if (!top.skip) {
                    relevance += top.relevance;
                }
                top = top.parent;
            } while (top !== end_mode.parent);
            if (end_mode.starts) {
                startNewMode(end_mode.starts);
            }
            return origin.returnEnd ? 0 : lexeme.length;
        }
        if (isIllegal(lexeme, top))
            throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
        /*
        Parser should not reach this point as all types of lexemes should be caught
        earlier, but if it does due to some bug make sure it advances at least one
        character forward to prevent infinite looping.
        */
        mode_buffer += lexeme;
        return lexeme.length || 1;
    }
    var language = getLanguage(name);
    if (!language) {
        throw new Error('Unknown language: "' + name + '"');
    }
    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '', current;
    for (current = top; current !== language; current = current.parent) {
        if (current.className) {
            result = buildSpan(current.className, '', true) + result;
        }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
        var match, count, index = 0;
        while (true) {
            top.terminators.lastIndex = index;
            match = top.terminators.exec(value);
            if (!match)
                break;
            count = processLexeme(value.substr(index, match.index - index), match[0]);
            index = match.index + count;
        }
        processLexeme(value.substr(index));
        for (current = top; current.parent; current = current.parent) { // close dangling modes
            if (current.className) {
                result += spanEndTag;
            }
        }
        return {
            relevance: relevance,
            value: result,
            language: name,
            top: top
        };
    }
    catch (e) {
        if (e.message && e.message.indexOf('Illegal') !== -1) {
            return {
                relevance: 0,
                value: escape(value)
            };
        }
        else {
            throw e;
        }
    }
}
/*
Highlighting with language detection. Accepts a string with the code to
highlight. Returns an object with the following properties:

- language (detected language)
- relevance (int)
- value (an HTML string with highlighting markup)
- second_best (object with the same structure for second-best heuristically
  detected language, may be absent)

*/
function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
        relevance: 0,
        value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
        var current = highlight(name, text, false);
        current.language = name;
        if (current.relevance > second_best.relevance) {
            second_best = current;
        }
        if (current.relevance > result.relevance) {
            second_best = result;
            result = current;
        }
    });
    if (second_best.language) {
        result.second_best = second_best;
    }
    return result;
}
/*
Updates highlight.js global options with values passed in the form of an object.
*/
function configure(user_options) {
    options = inherit(options, user_options);
}
function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
        lang.aliases.forEach(function (alias) { aliases[alias] = name; });
    }
}
function listLanguages() {
    return objectKeys(languages);
}
function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
}
/* Interface definition */
hljs.highlight = highlight;
hljs.highlightAuto = highlightAuto;
hljs.configure = configure;
hljs.registerLanguage = registerLanguage;
hljs.listLanguages = listLanguages;
hljs.getLanguage = getLanguage;
hljs.inherit = inherit;
// Common regexps
hljs.IDENT_RE = '[a-zA-Z]\\w*';
hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
// Common modes
hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
};
hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
};
hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
};
hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/
};
hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
        className: 'comment',
        begin: begin, end: end,
        contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
        className: 'doctag',
        begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
        relevance: 0
    });
    return mode;
};
hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
};
hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
};
hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
};
hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' +
        '%|em|ex|ch|rem' +
        '|vw|vh|vmin|vmax' +
        '|cm|mm|in|pt|pc|px' +
        '|deg|grad|rad|turn' +
        '|s|ms' +
        '|Hz|kHz' +
        '|dpi|dpcm|dppx' +
        ')?',
    relevance: 0
};
hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
        hljs.BACKSLASH_ESCAPE,
        {
            begin: /\[/, end: /\]/,
            relevance: 0,
            contains: [hljs.BACKSLASH_ESCAPE]
        }
    ]
};
hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
};
hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
};
hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
};
hljs.registerLanguage('typescript', typescript);
function typescript(hljs) {
    var KEYWORDS = {
        keyword: 'in if for while finally var new function do return void else break catch ' +
            'instanceof with throw case default try this switch continue typeof delete ' +
            'let yield const class public private protected get set super ' +
            'static implements enum export import declare type namespace abstract',
        literal: 'true false null undefined NaN Infinity',
        built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' +
            'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' +
            'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' +
            'TypeError URIError Number Math Date String RegExp Array Float32Array ' +
            'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' +
            'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' +
            'module console window document any number boolean string void'
    };
    return {
        aliases: ['ts'],
        keywords: KEYWORDS,
        contains: [
            {
                className: 'meta',
                begin: /^\s*['"]use strict['"]/
            },
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            {
                className: 'string',
                begin: '`', end: '`',
                contains: [
                    hljs.BACKSLASH_ESCAPE,
                    {
                        className: 'subst',
                        begin: '\\$\\{', end: '\\}'
                    }
                ]
            },
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            {
                className: 'number',
                variants: [
                    { begin: '\\b(0[bB][01]+)' },
                    { begin: '\\b(0[oO][0-7]+)' },
                    { begin: hljs.C_NUMBER_RE }
                ],
                relevance: 0
            },
            {
                begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                keywords: 'return throw case',
                contains: [
                    hljs.C_LINE_COMMENT_MODE,
                    hljs.C_BLOCK_COMMENT_MODE,
                    hljs.REGEXP_MODE
                ],
                relevance: 0
            },
            {
                className: 'function',
                begin: 'function', end: /[\{;]/, excludeEnd: true,
                keywords: KEYWORDS,
                contains: [
                    'self',
                    hljs.inherit(hljs.TITLE_MODE, { begin: /[A-Za-z$_][0-9A-Za-z$_]*/ }),
                    {
                        className: 'params',
                        begin: /\(/, end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS,
                        contains: [
                            hljs.C_LINE_COMMENT_MODE,
                            hljs.C_BLOCK_COMMENT_MODE
                        ],
                        illegal: /["'\(]/
                    }
                ],
                illegal: /%/,
                relevance: 0 // () => {} is more typical in TypeScript
            },
            {
                beginKeywords: 'constructor', end: /\{/, excludeEnd: true
            },
            {
                begin: /module\./,
                keywords: { built_in: 'module' },
                relevance: 0
            },
            {
                beginKeywords: 'module', end: /\{/, excludeEnd: true
            },
            {
                beginKeywords: 'interface', end: /\{/, excludeEnd: true,
                keywords: 'interface extends'
            },
            {
                begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
            },
            {
                begin: '\\.' + hljs.IDENT_RE, relevance: 0 // hack: prevents detection of keywords after dots
            }
        ]
    };
}
hljs.registerLanguage('scss', scss);
function scss(hljs) {
    var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
    var VARIABLE = {
        className: 'variable',
        begin: '(\\$' + IDENT_RE + ')\\b'
    };
    var HEXCOLOR = {
        className: 'number', begin: '#[0-9A-Fa-f]+'
    };
    // var DEF_INTERNALS = {
    //   className: 'attribute',
    //   begin: '[A-Z\\_\\.\\-]+', end: ':',
    //   excludeEnd: true,
    //   illegal: '[^\\s]',
    //   starts: {
    //     endsWithParent: true, excludeEnd: true,
    //     contains: [
    //       HEXCOLOR,
    //       hljs.CSS_NUMBER_MODE,
    //       hljs.QUOTE_STRING_MODE,
    //       hljs.APOS_STRING_MODE,
    //       hljs.C_BLOCK_COMMENT_MODE,
    //       {
    //         className: 'meta', begin: '!important'
    //       }
    //     ]
    //   }
    // };
    return {
        case_insensitive: true,
        illegal: '[=/|\']',
        contains: [
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            {
                className: 'selector-id', begin: '\\#[A-Za-z0-9_-]+',
                relevance: 0
            },
            {
                className: 'selector-class', begin: '\\.[A-Za-z0-9_-]+',
                relevance: 0
            },
            {
                className: 'selector-attr', begin: '\\[', end: '\\]',
                illegal: '$'
            },
            {
                className: 'selector-tag',
                begin: '\\b(a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|command|datalist|dd|del|details|dfn|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|map|mark|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|rp|rt|ruby|samp|script|section|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)\\b',
                relevance: 0
            },
            {
                begin: ':(visited|valid|root|right|required|read-write|read-only|out-range|optional|only-of-type|only-child|nth-of-type|nth-last-of-type|nth-last-child|nth-child|not|link|left|last-of-type|last-child|lang|invalid|indeterminate|in-range|hover|focus|first-of-type|first-line|first-letter|first-child|first|enabled|empty|disabled|default|checked|before|after|active)'
            },
            {
                begin: '::(after|before|choices|first-letter|first-line|repeat-index|repeat-item|selection|value)'
            },
            VARIABLE,
            {
                className: 'attribute',
                begin: '\\b(z-index|word-wrap|word-spacing|word-break|width|widows|white-space|visibility|vertical-align|unicode-bidi|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform-style|transform-origin|transform|top|text-underline-position|text-transform|text-shadow|text-rendering|text-overflow|text-indent|text-decoration-style|text-decoration-line|text-decoration-color|text-decoration|text-align-last|text-align|tab-size|table-layout|right|resize|quotes|position|pointer-events|perspective-origin|perspective|page-break-inside|page-break-before|page-break-after|padding-top|padding-right|padding-left|padding-bottom|padding|overflow-y|overflow-x|overflow-wrap|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|object-position|object-fit|normal|none|nav-up|nav-right|nav-left|nav-index|nav-down|min-width|min-height|max-width|max-height|mask|marks|margin-top|margin-right|margin-left|margin-bottom|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|letter-spacing|left|justify-content|initial|inherit|ime-mode|image-orientation|image-resolution|image-rendering|icon|hyphens|height|font-weight|font-variant-ligatures|font-variant|font-style|font-stretch|font-size-adjust|font-size|font-language-override|font-kerning|font-feature-settings|font-family|font|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|empty-cells|display|direction|cursor|counter-reset|counter-increment|content|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|columns|color|clip-path|clip|clear|caption-side|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-attachment|background-blend-mode|background|backface-visibility|auto|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation|align-self|align-items|align-content)\\b',
                illegal: '[^\\s]'
            },
            {
                begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b'
            },
            {
                begin: ':', end: ';',
                contains: [
                    VARIABLE,
                    HEXCOLOR,
                    hljs.CSS_NUMBER_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.APOS_STRING_MODE,
                    {
                        className: 'meta', begin: '!important'
                    }
                ]
            },
            {
                begin: '@', end: '[{;]',
                keywords: 'mixin include extend for if else each while charset import debug media page content font-face namespace warn',
                contains: [
                    VARIABLE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.APOS_STRING_MODE,
                    HEXCOLOR,
                    hljs.CSS_NUMBER_MODE,
                    {
                        begin: '\\s[A-Za-z0-9_.-]+',
                        relevance: 0
                    }
                ]
            }
        ]
    };
}
hljs.registerLanguage('xml', xml);
function xml(hljs) {
    var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
    var TAG_INTERNALS = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
            {
                className: 'attr',
                begin: XML_IDENT_RE,
                relevance: 0
            },
            {
                begin: /=\s*/,
                relevance: 0,
                contains: [
                    {
                        className: 'string',
                        endsParent: true,
                        variants: [
                            { begin: /"/, end: /"/ },
                            { begin: /'/, end: /'/ },
                            { begin: /[^\s"'=<>`]+/ }
                        ]
                    }
                ]
            }
        ]
    };
    return {
        aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
        case_insensitive: true,
        contains: [
            {
                className: 'meta',
                begin: '<!DOCTYPE', end: '>',
                relevance: 10,
                contains: [{ begin: '\\[', end: '\\]' }]
            },
            hljs.COMMENT('<!--', '-->', {
                relevance: 10
            }),
            {
                begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
                relevance: 10
            },
            {
                begin: /<\?(php)?/, end: /\?>/,
                subLanguage: 'php',
                contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
            },
            {
                className: 'tag',
                /*
                The lookahead pattern (?=...) ensures that 'begin' only matches
                '<style' as a single word, followed by a whitespace or an
                ending braket. The '$' is needed for the lexeme to be recognized
                by hljs.subMode() that tests lexemes outside the stream.
                */
                begin: '<style(?=\\s|>|$)', end: '>',
                keywords: { name: 'style' },
                contains: [TAG_INTERNALS],
                starts: {
                    end: '</style>', returnEnd: true,
                    subLanguage: ['css', 'xml']
                }
            },
            {
                className: 'tag',
                // See the comment in the <style tag about the lookahead pattern
                begin: '<script(?=\\s|>|$)', end: '>',
                keywords: { name: 'script' },
                contains: [TAG_INTERNALS],
                starts: {
                    end: '\<\/script\>', returnEnd: true,
                    subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
                }
            },
            {
                className: 'meta',
                variants: [
                    { begin: /<\?xml/, end: /\?>/, relevance: 10 },
                    { begin: /<\?\w+/, end: /\?>/ }
                ]
            },
            {
                className: 'tag',
                begin: '</?', end: '/?>',
                contains: [
                    {
                        className: 'name', begin: /[^\/><\s]+/, relevance: 0
                    },
                    TAG_INTERNALS
                ]
            }
        ]
    };
}

/**
 * Ok, so formatting overkill, we know. But whatever, it makes for great
 * error reporting within a terminal. So, yeah, let's code it up, shall we?
 */
function loadTypeScriptDiagnostics(rootDir, resultsDiagnostics, tsDiagnostics) {
    const maxErrors = Math.min(tsDiagnostics.length, MAX_ERRORS);
    for (var i = 0; i < maxErrors; i++) {
        resultsDiagnostics.push(loadDiagnostic(rootDir, tsDiagnostics[i]));
    }
}
function loadDiagnostic(rootDir, tsDiagnostic) {
    const d = {
        level: 'error',
        type: 'typescript',
        language: 'typescript',
        header: 'typescript error',
        code: tsDiagnostic.code.toString(),
        messageText: ts.flattenDiagnosticMessageText(tsDiagnostic.messageText, '\n'),
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (tsDiagnostic.file) {
        d.absFilePath = tsDiagnostic.file.fileName;
        d.relFilePath = formatFileName(rootDir, d.absFilePath);
        const sourceText = tsDiagnostic.file.getText();
        const srcLines = splitLineBreaks(sourceText);
        let htmlLines = srcLines;
        try {
            htmlLines = splitLineBreaks(highlight(d.language, sourceText, true).value);
        }
        catch (e) { }
        const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
        const errorLine = {
            lineIndex: posData.line,
            lineNumber: posData.line + 1,
            text: srcLines[posData.line],
            html: htmlLines[posData.line],
            errorCharStart: posData.character,
            errorLength: Math.max(tsDiagnostic.length, 1)
        };
        if (errorLine.html && errorLine.html.indexOf('class="hljs') === -1) {
            try {
                errorLine.html = highlight(d.language, errorLine.text, true).value;
            }
            catch (e) { }
        }
        d.lines.push(errorLine);
        if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
            errorLine.errorLength = 1;
            errorLine.errorCharStart--;
        }
        d.header = formatHeader('typescript', tsDiagnostic.file.fileName, rootDir, errorLine.lineNumber);
        if (errorLine.lineIndex > 0) {
            const previousLine = {
                lineIndex: errorLine.lineIndex - 1,
                lineNumber: errorLine.lineNumber - 1,
                text: srcLines[errorLine.lineIndex - 1],
                html: htmlLines[errorLine.lineIndex - 1],
                errorCharStart: -1,
                errorLength: -1
            };
            if (previousLine.html && previousLine.html.indexOf('class="hljs') === -1) {
                try {
                    previousLine.html = highlight(d.language, previousLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.unshift(previousLine);
        }
        if (errorLine.lineIndex + 1 < srcLines.length) {
            const nextLine = {
                lineIndex: errorLine.lineIndex + 1,
                lineNumber: errorLine.lineNumber + 1,
                text: srcLines[errorLine.lineIndex + 1],
                html: htmlLines[errorLine.lineIndex + 1],
                errorCharStart: -1,
                errorLength: -1
            };
            if (nextLine.html && nextLine.html.indexOf('class="hljs') === -1) {
                try {
                    nextLine.html = highlight(d.language, nextLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.push(nextLine);
        }
    }
    return d;
}

function moduleGraph(config, buildCtx) {
    return (transformContext) => {
        function visitImport(moduleGraph, dirPath, importNode) {
            if (importNode.moduleSpecifier) {
                let importPath = importNode.moduleSpecifier.getText().replace(/\'|\"|\`/g, '');
                if (importPath.startsWith('.') || importPath.startsWith('/')) {
                    importPath = pathJoin(config, dirPath, importPath);
                }
                moduleGraph.importPaths.push(importPath);
            }
            return importNode;
        }
        function visit(moduleGraph, dirPath, node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(moduleGraph, dirPath, node);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(moduleGraph, dirPath, node);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            const moduleGraph = {
                filePath: normalizePath(tsSourceFile.fileName),
                importPaths: []
            };
            const dirPath = config.sys.path.dirname(tsSourceFile.fileName);
            buildCtx.moduleGraphs.push(moduleGraph);
            return visit(moduleGraph, dirPath, tsSourceFile);
        };
    };
}

function removeCollectionImports(compilerCtx) {
    /*
  
      // remove side effect collection imports like:
      import 'ionicons';
  
      // do not remove collection imports with importClauses:
      import * as asdf 'ionicons';
      import { asdf } '@ionic/core';
  
    */
    return (transformContext) => {
        function visitImport(importNode) {
            if (!importNode.importClause && importNode.moduleSpecifier && ts.isStringLiteral(importNode.moduleSpecifier)) {
                // must not have an import clause
                // must have a module specifier and
                // the module specifier must be a string literal
                const moduleImport = importNode.moduleSpecifier.text;
                // test if this side effect import is a collection
                const isCollectionImport = compilerCtx.collections.some(c => {
                    return c.collectionName === moduleImport;
                });
                if (isCollectionImport) {
                    // turns out this is a side effect import is a collection,
                    // we actually don't want to include this in the JS output
                    // we've already gather the types we needed, kthxbai
                    return null;
                }
            }
            return importNode;
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

// same as the "declare" variables in the root index.ts file
const DECORATORS_TO_REMOVE = [
    'Element',
    'Event',
    'Listen',
    'Method',
    'Prop',
    'PropDidChange',
    'PropWillChange',
    'State',
    'Watch'
];
/**
 * Remove all decorators that are for metadata purposes
 */
function removeDecorators() {
    return (transformContext) => {
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    if (!isComponentClass(node)) {
                        return node;
                    }
                    return visitComponentClass(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => visit(tsSourceFile);
    };
}
/**
 * Visit the component class and remove decorators
 * @param classNode
 */
function visitComponentClass(classNode) {
    classNode.decorators = removeDecoratorsByName(classNode.decorators, ['Component']);
    classNode.members.forEach((member) => {
        if (Array.isArray(member.decorators)) {
            member.decorators = removeDecoratorsByName(member.decorators, DECORATORS_TO_REMOVE);
        }
    });
    return classNode;
}
/**
 * Remove a decorator from the an array by name
 * @param decorators array of decorators
 * @param name name to remove
 */
function removeDecoratorsByName(decoratorList, names) {
    const updatedDecoratorList = decoratorList.filter(dec => {
        const toRemove = ts.isCallExpression(dec.expression) &&
            ts.isIdentifier(dec.expression.expression) &&
            names.indexOf(dec.expression.expression.text) >= 0;
        return !toRemove;
    });
    if (updatedDecoratorList.length === 0 && decoratorList.length > 0) {
        return undefined;
    }
    if (updatedDecoratorList.length !== decoratorList.length) {
        return ts.createNodeArray(updatedDecoratorList);
    }
    return decoratorList;
}

function removeStencilImports() {
    return (transformContext) => {
        function visitImport(importNode) {
            if (importNode.moduleSpecifier &&
                ts.isStringLiteral(importNode.moduleSpecifier) &&
                importNode.moduleSpecifier.text === '@stencil/core') {
                return null;
            }
            return importNode;
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

var __awaiter$21 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function transpileModules(config, compilerCtx, buildCtx, tsFilePaths) {
    return __awaiter$21(this, void 0, void 0, function* () {
        if (hasError(buildCtx.diagnostics)) {
            // we've already got an error, let's not continue
            return;
        }
        if (tsFilePaths.length === 0) {
            // don't bother if there are no ts files to transpile
            return;
        }
        // fire up the typescript program
        const timespace = config.logger.createTimeSpan('transpileModules start', true);
        // get the tsconfig compiler options we'll use
        const tsOptions = yield getUserTsConfig(config, compilerCtx);
        if (config.suppressTypeScriptErrors) {
            // suppressTypeScriptErrors mainly for unit testing
            tsOptions.lib = [];
        }
        const writeQueue = [];
        // get the ts compiler host we'll use, which patches file operations
        // with our in-memory file system
        const tsHost = getTsHost(config, compilerCtx, writeQueue, tsOptions);
        // fire up the typescript program
        const componentsDtsSrcFilePath = getComponentsDtsSrcFilePath(config);
        // create the components.d.ts file from the component metadata
        const checkProgram = yield generateComponentTypes(config, compilerCtx, buildCtx, tsOptions, tsHost, tsFilePaths, componentsDtsSrcFilePath);
        // get all of the ts files paths to transpile
        // ensure the components.d.ts file is always included to this transpile program
        const programTsFiles = tsFilePaths.slice();
        if (programTsFiles.indexOf(componentsDtsSrcFilePath) === -1) {
            // we must always include the components.d.ts file in this tranpsile program
            programTsFiles.push(componentsDtsSrcFilePath);
        }
        // create another program, but use the previous checkProgram to speed it up
        const program = ts.createProgram(programTsFiles, tsOptions, tsHost, checkProgram);
        // run the second program again with our new typed info
        transpileProgram(program, tsHost, config, compilerCtx, buildCtx);
        // figure out if we actually have changed JS text that was written
        const writeResults = yield Promise.all(writeQueue);
        buildCtx.hasChangedJsText = writeResults.some(r => r.changedContent);
        // done and done
        timespace.finish(`transpileModules finished`);
    });
}
function transpileProgram(program, tsHost, config, compilerCtx, buildCtx) {
    // this is the big one, let's go ahead and kick off the transpiling
    const buildConditionals = {
        isDev: !!config.devMode
    };
    program.emit(undefined, tsHost.writeFile, undefined, false, {
        // NOTE! order of transforms and being in either "before" or "after" is very important!!!!
        before: [
            removeDecorators(),
            addComponentMetadata(compilerCtx.moduleFiles),
            buildConditionalsTransform(buildConditionals)
        ],
        after: [
            removeStencilImports(),
            removeCollectionImports(compilerCtx),
            moduleGraph(config, buildCtx),
            componentDependencies(compilerCtx, buildCtx)
        ]
    });
    if (!config.suppressTypeScriptErrors) {
        // suppressTypeScriptErrors mainly for unit testing
        const tsDiagnostics = [];
        program.getSyntacticDiagnostics().forEach(d => tsDiagnostics.push(d));
        program.getSemanticDiagnostics().forEach(d => tsDiagnostics.push(d));
        program.getOptionsDiagnostics().forEach(d => tsDiagnostics.push(d));
        loadTypeScriptDiagnostics(config.rootDir, buildCtx.diagnostics, tsDiagnostics);
    }
}

var __awaiter$22 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function transpileAppModules(config, compilerCtx, buildCtx) {
    return __awaiter$22(this, void 0, void 0, function* () {
        if (canSkipTranspiling(config, buildCtx)) {
            // this is a rebuild, but turns out the files causing to
            // do not require us to run the transpiling again
            return;
        }
        const timeSpan = config.logger.createTimeSpan(`compile started`);
        try {
            // recursively scan all of the src directories
            // looking for typescript files to transpile
            // and read the files async and put into our
            // in-memory file system
            const tsFilePaths = yield scanDirForTsFiles(config, compilerCtx.fs, config.srcDir);
            // found all the files we need to transpile
            // and have all the files in-memory and ready to go
            // go ahead and kick off transpiling
            yield transpileModules(config, compilerCtx, buildCtx, tsFilePaths);
        }
        catch (e) {
            // gah!!
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`compile finished`);
        config.logger.debug(`compile finished`);
    });
}
function scanDirForTsFiles(config, fs, dir) {
    return __awaiter$22(this, void 0, void 0, function* () {
        const scanDirTimeSpan = config.logger.createTimeSpan(`scan ${config.srcDir} for ts files started`, true);
        // loop through this directory and sub directories looking for
        // files that need to be transpiled
        const dirItems = yield fs.readdir(dir, { recursive: true });
        // filter down to only the ts files we should include
        const tsFileItems = dirItems.filter(item => {
            return item.isFile && isFileIncludePath(config, item.absPath);
        });
        // let's async read and cache the source file so it get's loaded up
        // into our in-memory file system to be used later during the actual transpile
        yield Promise.all(tsFileItems.map((tsFileItem) => __awaiter$22(this, void 0, void 0, function* () {
            yield fs.readFile(tsFileItem.absPath);
        })));
        scanDirTimeSpan.finish(`scan for ts files finished`);
        // return just the abs path
        return tsFileItems.map(tsFileItem => tsFileItem.absPath);
    });
}
function canSkipTranspiling(config, buildCtx) {
    if (buildCtx.requiresFullBuild) {
        // requires a full rebuild, so we cannot skip transpiling
        return false;
    }
    if (buildCtx.dirsAdded.length > 0 || buildCtx.dirsDeleted.length > 0) {
        // if a directory was added or deleted
        // then we cannot skip transpiling
        return false;
    }
    const isTsFileInChangedFiles = buildCtx.filesChanged.some(filePath => {
        // do transpiling if one of the changed files is a ts file
        // and the changed file is not the components.d.ts file
        // when the components.d.ts file is written to disk it shouldn't cause a new build
        return isFileIncludePath(config, filePath);
    });
    // we can skip transpiling if there are no ts files that have changed
    return !isTsFileInChangedFiles;
}
function isFileIncludePath(config, readPath) {
    for (var i = 0; i < config.excludeSrc.length; i++) {
        if (config.sys.minimatch(readPath, config.excludeSrc[i])) {
            // this file is a file we want to exclude
            return false;
        }
    }
    for (i = 0; i < config.includeSrc.length; i++) {
        if (config.sys.minimatch(readPath, config.includeSrc[i])) {
            // this file is a file we want to include
            return true;
        }
    }
    // not a file we want to include, let's not add it
    return false;
}

var __awaiter$23 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function docs(config, compilerCtx) {
    return __awaiter$23(this, void 0, void 0, function* () {
        compilerCtx = getCompilerCtx(config, compilerCtx);
        const buildCtx = getBuildContext(config, compilerCtx, null);
        config.logger.info(config.logger.cyan(`${config.sys.compiler.name} v${config.sys.compiler.version}`));
        // keep track of how long the entire build process takes
        const timeSpan = config.logger.createTimeSpan(`generate docs, ${config.fsNamespace}, started`);
        try {
            // begin the build
            // async scan the src directory for ts files
            // then transpile them all in one go
            yield transpileAppModules(config, compilerCtx, buildCtx);
            // generate each of the docs
            yield generateDocs(config, compilerCtx);
        }
        catch (e) {
            // catch all phase
            catchError(buildCtx.diagnostics, e);
        }
        // finalize phase
        buildCtx.diagnostics = cleanDiagnostics(buildCtx.diagnostics);
        config.logger.printDiagnostics(buildCtx.diagnostics);
        // create a nice pretty message stating what happend
        let buildStatus = 'finished';
        let statusColor = 'green';
        if (hasError(buildCtx.diagnostics)) {
            buildStatus = 'failed';
            statusColor = 'red';
        }
        timeSpan.finish(`generate docs ${buildStatus}`, statusColor, true, true);
    });
}
function generateDocs(config, compilerCtx) {
    return __awaiter$23(this, void 0, void 0, function* () {
        const docsOutputTargets = config.outputTargets.filter(o => o.type === 'docs');
        if (docsOutputTargets.length > 0) {
            yield generateReadmes(config, compilerCtx, docsOutputTargets);
        }
    });
}

var __awaiter$24 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateServiceWorkers(config, compilerCtx, buildCtx) {
    return __awaiter$24(this, void 0, void 0, function* () {
        const wwwServiceOutputs = config.outputTargets.filter(o => o.type === 'www' && o.serviceWorker);
        return Promise.all(wwwServiceOutputs.map(outputTarget => {
            return generateServiceWorker(config, compilerCtx, buildCtx, outputTarget);
        }));
    });
}
function generateServiceWorker(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$24(this, void 0, void 0, function* () {
        const shouldSkipSW = yield canSkipGenerateSW(config, compilerCtx, buildCtx, outputTarget);
        if (shouldSkipSW) {
            return;
        }
        if (hasSrcConfig(outputTarget)) {
            yield Promise.all([
                copyLib(config, buildCtx, outputTarget),
                injectManifest(config, buildCtx, outputTarget)
            ]);
        }
        else {
            yield generateSW(config, buildCtx, outputTarget.serviceWorker);
        }
    });
}
function copyLib(config, buildCtx, outputTarget) {
    return __awaiter$24(this, void 0, void 0, function* () {
        const timeSpan = config.logger.createTimeSpan(`copy service worker library started`, true);
        try {
            yield config.sys.workbox.copyWorkboxLibraries(outputTarget.dir);
        }
        catch (e) {
            // workaround for workbox issue in the latest alpha
            const d = buildWarn(buildCtx.diagnostics);
            d.messageText = 'Service worker library already exists';
        }
        timeSpan.finish(`copy service worker library finished`);
    });
}
function generateSW(config, buildCtx, serviceWorker) {
    return __awaiter$24(this, void 0, void 0, function* () {
        const timeSpan = config.logger.createTimeSpan(`generate service worker started`);
        try {
            yield config.sys.workbox.generateSW(serviceWorker);
            timeSpan.finish(`generate service worker finished`);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
function injectManifest(config, buildCtx, outputTarget) {
    return __awaiter$24(this, void 0, void 0, function* () {
        const timeSpan = config.logger.createTimeSpan(`inject manifest into service worker started`);
        try {
            yield config.sys.workbox.injectManifest(outputTarget.serviceWorker);
            timeSpan.finish('inject manifest into service worker finished');
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
function hasSrcConfig(outputTarget) {
    return !!outputTarget.serviceWorker.swSrc;
}
function canSkipGenerateSW(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$24(this, void 0, void 0, function* () {
        if (!outputTarget.serviceWorker) {
            return true;
        }
        if (!config.srcIndexHtml) {
            return true;
        }
        if ((compilerCtx.hasSuccessfulBuild && buildCtx.appFileBuildCount === 0) || hasError(buildCtx.diagnostics)) {
            // no need to rebuild index.html if there were no app file changes
            return true;
        }
        const hasSrcIndexHtml = yield compilerCtx.fs.access(config.srcIndexHtml);
        if (!hasSrcIndexHtml) {
            config.logger.debug(`generateServiceWorker, no index.html, so skipping sw build`);
            return true;
        }
        // let's build us some service workerz
        return false;
    });
}

function normalizePrerenderLocation(config, outputTarget, windowLocationHref, url) {
    let prerenderLocation = null;
    try {
        if (typeof url !== 'string') {
            return null;
        }
        // remove any quotes that somehow got in the href
        url = url.replace(/\'|\"/g, '');
        // parse the <a href> passed in
        const hrefParseUrl = config.sys.url.parse(url);
        // don't bother for basically empty <a> tags
        if (!hrefParseUrl.pathname) {
            return null;
        }
        // parse the window.location
        const windowLocationUrl = config.sys.url.parse(windowLocationHref);
        // urls must be on the same host
        // but only check they're the same host when the href has a host
        if (hrefParseUrl.hostname && hrefParseUrl.hostname !== windowLocationUrl.hostname) {
            return null;
        }
        // convert it back to a nice in pretty path
        prerenderLocation = {
            url: config.sys.url.resolve(windowLocationHref, url)
        };
        const normalizedUrl = config.sys.url.parse(prerenderLocation.url);
        normalizedUrl.hash = null;
        if (!outputTarget.prerenderPathQuery) {
            normalizedUrl.search = null;
        }
        prerenderLocation.url = config.sys.url.format(normalizedUrl);
        prerenderLocation.path = config.sys.url.parse(prerenderLocation.url).path;
        if (!prerenderLocation.path.startsWith(outputTarget.baseUrl)) {
            if (prerenderLocation.path !== outputTarget.baseUrl.substr(0, outputTarget.baseUrl.length - 1)) {
                return null;
            }
        }
        const filter = (typeof outputTarget.prerenderFilter === 'function') ? outputTarget.prerenderFilter : prerenderFilter;
        const isValidUrl = filter(hrefParseUrl);
        if (!isValidUrl) {
            return null;
        }
        if (hrefParseUrl.hash && outputTarget.prerenderPathHash) {
            prerenderLocation.url += hrefParseUrl.hash;
            prerenderLocation.path += hrefParseUrl.hash;
        }
    }
    catch (e) {
        config.logger.error(`normalizePrerenderLocation`, e);
        return null;
    }
    return prerenderLocation;
}
function prerenderFilter(url) {
    const parts = url.pathname.split('/');
    const basename = parts[parts.length - 1];
    return !basename.includes('.');
}
function crawlAnchorsForNextUrls(config, outputTarget, prerenderQueue, windowLocationHref, anchors) {
    anchors && anchors.forEach(anchor => {
        if (isValidCrawlableAnchor(anchor)) {
            addLocationToProcess(config, outputTarget, windowLocationHref, prerenderQueue, anchor.href);
        }
    });
}
function isValidCrawlableAnchor(anchor) {
    if (!anchor) {
        return false;
    }
    if (typeof anchor.href !== 'string' || anchor.href.trim() === '' || anchor.href.trim() === '#') {
        return false;
    }
    if (typeof anchor.target === 'string' && anchor.target.trim().toLowerCase() !== '_self') {
        return false;
    }
    return true;
}
function addLocationToProcess(config, outputTarget, windowLocationHref, prerenderQueue, locationUrl) {
    const prerenderLocation = normalizePrerenderLocation(config, outputTarget, windowLocationHref, locationUrl);
    if (!prerenderLocation || prerenderQueue.some(p => p.url === prerenderLocation.url)) {
        // either it's not a good location to prerender
        // or we've already got it in the queue
        return;
    }
    // set that this location is pending to be prerendered
    prerenderLocation.status = 'pending';
    // add this to our queue of locations to prerender
    prerenderQueue.push(prerenderLocation);
}
function getPrerenderQueue(config, outputTarget) {
    const prerenderHost = `http://prerender.stenciljs.com`;
    const prerenderQueue = [];
    if (Array.isArray(outputTarget.prerenderLocations)) {
        outputTarget.prerenderLocations.forEach(prerenderLocation => {
            addLocationToProcess(config, outputTarget, prerenderHost, prerenderQueue, prerenderLocation.path);
        });
    }
    return prerenderQueue;
}
function getWritePathFromUrl(config, outputTarget, url) {
    const parsedUrl = config.sys.url.parse(url);
    let pathName = parsedUrl.pathname;
    if (pathName.startsWith(outputTarget.baseUrl)) {
        pathName = pathName.substring(outputTarget.baseUrl.length);
    }
    else if (outputTarget.baseUrl === pathName + '/') {
        pathName = '/';
    }
    // figure out the directory where this file will be saved
    const dir = pathJoin(config, outputTarget.dir, pathName);
    // create the full path where this will be saved (normalize for windowz)
    let filePath;
    if (dir + '/' === outputTarget.dir + '/') {
        // this is the root of the output target directory
        // use the configured index.html
        const basename = outputTarget.indexHtml.substr(dir.length + 1);
        filePath = pathJoin(config, dir, basename);
    }
    else {
        filePath = pathJoin(config, dir, `index.html`);
    }
    return filePath;
}

function getFilePathFromUrl(config, outputTarget, windowLocationHref, url) {
    if (typeof url !== 'string' || url.trim() === '') {
        return null;
    }
    const location = normalizePrerenderLocation(config, outputTarget, windowLocationHref, url);
    if (!location) {
        return null;
    }
    return config.sys.path.join(outputTarget.dir, location.path);
}
function createHashedFileName(fileName, hash) {
    const parts = fileName.split('.');
    parts.splice(parts.length - 1, 0, hash);
    return parts.join('.');
}

var __awaiter$25 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function versionElementAssets(config, compilerCtx, outputTarget, windowLocationHref, doc) {
    return __awaiter$25(this, void 0, void 0, function* () {
        if (!config.assetVersioning.versionHtml) {
            return;
        }
        yield Promise.all(ELEMENT_TYPES.map((elmType) => __awaiter$25(this, void 0, void 0, function* () {
            yield versionElementTypeAssets(config, compilerCtx, outputTarget, windowLocationHref, doc, elmType.selector, elmType.selector);
        })));
    });
}
const ELEMENT_TYPES = [
    { selector: 'link[rel="apple-touch-icon"][href]', attr: 'href' },
    { selector: 'link[rel="icon"][href]', attr: 'href' },
    { selector: 'link[rel="manifest"][href]', attr: 'href' },
    { selector: 'link[rel="stylesheet"][href]', attr: 'href' }
];
function versionElementTypeAssets(config, compilerCtx, outputTarget, windowLocationHref, doc, selector, attrName) {
    return __awaiter$25(this, void 0, void 0, function* () {
        const elements = doc.querySelectorAll(selector);
        const promises = [];
        for (let i = 0; i < elements.length; i++) {
            promises.push(versionElementAsset(config, compilerCtx, outputTarget, windowLocationHref, elements[i], attrName));
        }
        return Promise.all(promises);
    });
}
function versionElementAsset(config, compilerCtx, outputTarget, windowLocationHref, elm, attrName) {
    return __awaiter$25(this, void 0, void 0, function* () {
        const url = elm.getAttribute(attrName);
        const versionedUrl = yield versionAsset(config, compilerCtx, outputTarget, windowLocationHref, url);
        if (versionedUrl) {
            elm.setAttribute(attrName, versionedUrl);
        }
    });
}
function versionAsset(config, compilerCtx, outputTarget, windowLocationHref, url) {
    return __awaiter$25(this, void 0, void 0, function* () {
        try {
            const orgFilePath = getFilePathFromUrl(config, outputTarget, windowLocationHref, url);
            if (!orgFilePath) {
                return null;
            }
            if (hasFileExtension(orgFilePath, TXT_EXT$1)) {
                const content = yield compilerCtx.fs.readFile(orgFilePath);
                const hash = config.sys.generateContentHash(content, config.hashedFileNameLength);
                const dirName = config.sys.path.dirname(orgFilePath);
                const fileName = config.sys.path.basename(orgFilePath);
                const hashedFileName = createHashedFileName(fileName, hash);
                const hashedFilePath = config.sys.path.join(dirName, hashedFileName);
                yield compilerCtx.fs.writeFile(hashedFilePath, content);
                yield compilerCtx.fs.remove(orgFilePath);
                return hashedFileName;
            }
        }
        catch (e) { }
        return null;
    });
}
const TXT_EXT$1 = ['js', 'css', 'svg', 'json'];

var __awaiter$26 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function versionManifestAssets(config, compilerCtx, outputTarget, windowLocationHref, doc) {
    return __awaiter$26(this, void 0, void 0, function* () {
        if (!config.assetVersioning.versionManifest) {
            return;
        }
        const manifestLink = doc.querySelector('link[rel="manifest"][href]');
        if (!manifestLink) {
            return;
        }
        return versionManifest(config, compilerCtx, outputTarget, windowLocationHref, manifestLink);
    });
}
function versionManifest(config, compilerCtx, outputTarget, windowLocationHref, linkElm) {
    return __awaiter$26(this, void 0, void 0, function* () {
        const url = linkElm.getAttribute('href');
        if (!url) {
            return;
        }
        const orgFilePath = getFilePathFromUrl(config, outputTarget, windowLocationHref, url);
        if (!orgFilePath) {
            return;
        }
        if (!hasFileExtension(orgFilePath, ['json'])) {
            return;
        }
        try {
            const jsonStr = yield compilerCtx.fs.readFile(orgFilePath);
            const manifest = JSON.parse(jsonStr);
            if (Array.isArray(manifest.icons)) {
                yield Promise.all(manifest.icons.map((manifestIcon) => __awaiter$26(this, void 0, void 0, function* () {
                    yield versionManifestIcon(config, compilerCtx, outputTarget, windowLocationHref, manifest, manifestIcon);
                })));
            }
            yield generateVersionedManifest(config, compilerCtx, linkElm, orgFilePath, manifest);
        }
        catch (e) {
            config.logger.error(`versionManifest: ${e}`);
        }
    });
}
function versionManifestIcon(config, compilerCtx, outputTarget, windowLocationHref, manifest, manifestIcon) {
    return __awaiter$26(this, void 0, void 0, function* () {
    });
}
function generateVersionedManifest(config, compilerCtx, linkElm, orgFilePath, manifest) {
    return __awaiter$26(this, void 0, void 0, function* () {
        const jsonStr = JSON.stringify(manifest);
        const dir = config.sys.path.dirname(orgFilePath);
        const orgFileName = config.sys.path.basename(orgFilePath);
        const hash = config.sys.generateContentHash(jsonStr, config.hashedFileNameLength);
        const newFileName = orgFileName.toLowerCase().replace(`.json`, `.${hash}.json`);
        const newFilePath = config.sys.path.join(dir, newFileName);
        yield Promise.all([
            compilerCtx.fs.remove(orgFilePath),
            compilerCtx.fs.writeFile(newFilePath, jsonStr)
        ]);
        let url = linkElm.getAttribute('href');
        url = url.replace(orgFileName, newFileName);
        linkElm.setAttribute('href', url);
    });
}

var __awaiter$27 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function assetVersioning(config, compilerCtx, outputTarget, windowLocationHref, doc) {
    return __awaiter$27(this, void 0, void 0, function* () {
        yield versionElementAssets(config, compilerCtx, outputTarget, windowLocationHref, doc);
        yield versionManifestAssets(config, compilerCtx, outputTarget, windowLocationHref, doc);
    });
}

function collapseHtmlWhitepace(node) {
    // this isn't about reducing HTML filesize (cuz it doesn't really matter after gzip)
    // this is more about having many less nodes for the client side to
    // have to climb through while it's creating vnodes from this HTML
    if (node.nodeType === 1 /* ElementNode */) {
        const attributeList = node.attributes;
        for (let j = attributeList.length - 1; j >= 0; j--) {
            const attr = attributeList[j];
            if (!attr.value) {
                if (SAFE_TO_REMOVE_EMPTY_ATTRS.includes(attr.name)) {
                    node.removeAttribute(attr.name);
                }
            }
        }
    }
    if (WHITESPACE_SENSITIVE_TAGS.includes(node.tagName)) {
        return;
    }
    let lastWhitespaceTextNode = null;
    for (let i = node.childNodes.length - 1; i >= 0; i--) {
        const childNode = node.childNodes[i];
        if (childNode.nodeType === 3 /* TextNode */ || childNode.nodeType === 8 /* CommentNode */) {
            childNode.nodeValue = childNode.nodeValue.replace(REDUCE_WHITESPACE_REGEX, ' ');
            if (childNode.nodeValue === ' ') {
                if (lastWhitespaceTextNode === null) {
                    childNode.nodeValue = ' ';
                    lastWhitespaceTextNode = childNode;
                }
                else {
                    childNode.parentNode.removeChild(childNode);
                }
                continue;
            }
        }
        else if (childNode.childNodes) {
            collapseHtmlWhitepace(childNode);
        }
        lastWhitespaceTextNode = null;
    }
}
const REDUCE_WHITESPACE_REGEX = /\s\s+/g;
const WHITESPACE_SENSITIVE_TAGS = ['PRE', 'SCRIPT', 'STYLE', 'TEXTAREA'];
const SAFE_TO_REMOVE_EMPTY_ATTRS = [
    'class',
    'style',
];

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
function parseCss(config, css, filePath) {
    /**
     * Positional.
     */
    var lineno = 1;
    var column = 1;
    var srcLines;
    /**
     * Update lineno and column based on `str`.
     */
    function updatePosition(str) {
        const lines = str.match(/\n/g);
        if (lines)
            lineno += lines.length;
        const i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
    }
    /**
     * Mark position and patch `node.position`.
     */
    function position() {
        const start = { line: lineno, column: column };
        return function (node) {
            node.position = new ParsePosition(start);
            whitespace();
            return node;
        };
    }
    /**
     * Store position information for a node
     */
    class ParsePosition {
        constructor(start) {
            this.start = start;
            this.end = { line: lineno, column: column };
            this.source = filePath;
        }
    }
    /**
     * Non-enumerable source string
     */
    ParsePosition.prototype.content = css;
    /**
     * Error `msg`.
     */
    const diagnostics = [];
    function error(msg) {
        if (!srcLines) {
            srcLines = css.split('\n');
        }
        const d = {
            level: 'error',
            type: 'css',
            language: 'css',
            header: 'CSS Parse',
            messageText: msg,
            absFilePath: filePath,
            lines: [{
                    lineIndex: lineno - 1,
                    lineNumber: lineno,
                    errorCharStart: column,
                    text: css[lineno - 1],
                }]
        };
        d.header = formatHeader('CSS', filePath, config.rootDir, lineno);
        if (lineno > 1) {
            const previousLine = {
                lineIndex: lineno - 1,
                lineNumber: lineno - 1,
                text: css[lineno - 2],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.unshift(previousLine);
        }
        if (lineno + 2 < srcLines.length) {
            const nextLine = {
                lineIndex: lineno,
                lineNumber: lineno + 1,
                text: srcLines[lineno],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.push(nextLine);
        }
        diagnostics.push(d);
    }
    /**
     * Parse stylesheet.
     */
    function stylesheet() {
        const rulesList = rules();
        return {
            type: 'stylesheet',
            stylesheet: {
                source: filePath,
                rules: rulesList,
                diagnostics: diagnostics
            }
        };
    }
    /**
     * Opening brace.
     */
    function open() {
        return match(/^{\s*/);
    }
    /**
     * Closing brace.
     */
    function close() {
        return match(/^}/);
    }
    /**
     * Parse ruleset.
     */
    function rules() {
        var node;
        const rules = [];
        whitespace();
        comments(rules);
        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
            if (node !== false) {
                rules.push(node);
                comments(rules);
            }
        }
        return rules;
    }
    /**
     * Match `re` and return captures.
     */
    function match(re) {
        const m = re.exec(css);
        if (!m)
            return;
        const str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
    }
    /**
     * Parse whitespace.
     */
    function whitespace() {
        match(/^\s*/);
    }
    /**
     * Parse comments;
     */
    function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
            if (c !== false) {
                rules.push(c);
            }
        }
        return rules;
    }
    /**
     * Parse comment.
     */
    function comment() {
        const pos = position();
        if ('/' !== css.charAt(0) || '*' !== css.charAt(1))
            return;
        var i = 2;
        while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1)))
            ++i;
        i += 2;
        if ('' === css.charAt(i - 1)) {
            return error('End of comment missing');
        }
        const str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
        return pos({
            type: 'comment',
            comment: str
        });
    }
    /**
     * Parse selector.
     */
    function selector() {
        const m = match(/^([^{]+)/);
        if (!m)
            return;
        /* @fix Remove all comments from selectors
         * http://ostermiller.org/findcomment.html */
        return trim(m[0])
            .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
            .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
            return m.replace(/,/g, '\u200C');
        })
            .split(/\s*(?![^(]*\)),\s*/)
            .map(function (s) {
            return s.replace(/\u200C/g, ',');
        });
    }
    /**
     * Parse declaration.
     */
    function declaration() {
        const pos = position();
        // prop
        var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop)
            return;
        prop = trim(prop[0]);
        // :
        if (!match(/^:\s*/))
            return error(`property missing ':'`);
        // val
        const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
        const ret = pos({
            type: 'declaration',
            property: prop.replace(commentre, ''),
            value: val ? trim(val[0]).replace(commentre, '') : ''
        });
        // ;
        match(/^[;\s]*/);
        return ret;
    }
    /**
     * Parse declarations.
     */
    function declarations() {
        const decls = [];
        if (!open())
            return error(`missing '{'`);
        comments(decls);
        // declarations
        var decl;
        while (decl = declaration()) {
            if (decl !== false) {
                decls.push(decl);
                comments(decls);
            }
        }
        if (!close())
            return error(`missing '}'`);
        return decls;
    }
    /**
     * Parse keyframe.
     */
    function keyframe() {
        var m;
        const vals = [];
        const pos = position();
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
            vals.push(m[1]);
            match(/^,\s*/);
        }
        if (!vals.length)
            return;
        return pos({
            type: 'keyframe',
            values: vals,
            declarations: declarations()
        });
    }
    /**
     * Parse keyframes.
     */
    function atkeyframes() {
        const pos = position();
        var m = match(/^@([-\w]+)?keyframes\s*/);
        if (!m)
            return;
        const vendor = m[1];
        // identifier
        m = match(/^([-\w]+)\s*/);
        if (!m)
            return error(`@keyframes missing name`);
        const name = m[1];
        if (!open())
            return error(`@keyframes missing '{'`);
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
            frames.push(frame);
            frames = frames.concat(comments());
        }
        if (!close())
            return error(`@keyframes missing '}'`);
        return pos({
            type: 'keyframes',
            name: name,
            vendor: vendor,
            keyframes: frames
        });
    }
    /**
     * Parse supports.
     */
    function atsupports() {
        const pos = position();
        const m = match(/^@supports *([^{]+)/);
        if (!m)
            return;
        const supports = trim(m[1]);
        if (!open())
            return error(`@supports missing '{'`);
        const style = comments().concat(rules());
        if (!close())
            return error(`@supports missing '}'`);
        return pos({
            type: 'supports',
            supports: supports,
            rules: style
        });
    }
    /**
     * Parse host.
     */
    function athost() {
        const pos = position();
        const m = match(/^@host\s*/);
        if (!m)
            return;
        if (!open())
            return error(`@host missing '{'`);
        const style = comments().concat(rules());
        if (!close())
            return error(`@host missing '}'`);
        return pos({
            type: 'host',
            rules: style
        });
    }
    /**
     * Parse media.
     */
    function atmedia() {
        const pos = position();
        const m = match(/^@media *([^{]+)/);
        if (!m)
            return;
        const media = trim(m[1]);
        if (!open())
            return error(`@media missing '{'`);
        const style = comments().concat(rules());
        if (!close())
            return error(`@media missing '}'`);
        return pos({
            type: 'media',
            media: media,
            rules: style
        });
    }
    /**
     * Parse custom-media.
     */
    function atcustommedia() {
        const pos = position();
        const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
        if (!m)
            return;
        return pos({
            type: 'custom-media',
            name: trim(m[1]),
            media: trim(m[2])
        });
    }
    /**
     * Parse paged media.
     */
    function atpage() {
        const pos = position();
        const m = match(/^@page */);
        if (!m)
            return;
        const sel = selector() || [];
        if (!open())
            return error(`@page missing '{'`);
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error(`@page missing '}'`);
        return pos({
            type: 'page',
            selectors: sel,
            declarations: decls
        });
    }
    /**
     * Parse document.
     */
    function atdocument() {
        const pos = position();
        const m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m)
            return;
        const vendor = trim(m[1]);
        const doc = trim(m[2]);
        if (!open())
            return error(`@document missing '{'`);
        const style = comments().concat(rules());
        if (!close())
            return error(`@document missing '}'`);
        return pos({
            type: 'document',
            document: doc,
            vendor: vendor,
            rules: style
        });
    }
    /**
     * Parse font-face.
     */
    function atfontface() {
        const pos = position();
        const m = match(/^@font-face\s*/);
        if (!m)
            return;
        if (!open())
            return error(`@font-face missing '{'`);
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error(`@font-face missing '}'`);
        return pos({
            type: 'font-face',
            declarations: decls
        });
    }
    /**
     * Parse import
     */
    const atimport = _compileAtrule('import');
    /**
     * Parse charset
     */
    const atcharset = _compileAtrule('charset');
    /**
     * Parse namespace
     */
    const atnamespace = _compileAtrule('namespace');
    /**
     * Parse non-block at-rules
     */
    function _compileAtrule(name) {
        const re = new RegExp('^@' + name + '\\s*([^;]+);');
        return function () {
            const pos = position();
            const m = match(re);
            if (!m)
                return;
            const ret = { type: name };
            ret[name] = m[1].trim();
            return pos(ret);
        };
    }
    /**
     * Parse at rule.
     */
    function atrule() {
        if (css[0] !== '@')
            return;
        return atkeyframes()
            || atmedia()
            || atcustommedia()
            || atsupports()
            || atimport()
            || atcharset()
            || atnamespace()
            || atdocument()
            || atpage()
            || athost()
            || atfontface();
    }
    /**
     * Parse rule.
     */
    function rule() {
        const pos = position();
        const sel = selector();
        if (!sel)
            return error('selector missing');
        comments();
        return pos({
            type: 'rule',
            selectors: sel,
            declarations: declarations()
        });
    }
    return addParent(stylesheet());
}
/**
 * Trim `str`.
 */
function trim(str) {
    return str ? str.trim() : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */
function addParent(obj, parent) {
    const isNode = obj && typeof obj.type === 'string';
    const childParent = isNode ? obj : parent;
    for (const k in obj) {
        const value = obj[k];
        if (Array.isArray(value)) {
            value.forEach(function (v) { addParent(v, childParent); });
        }
        else if (value && typeof value === 'object') {
            addParent(value, childParent);
        }
    }
    if (isNode) {
        Object.defineProperty(obj, 'parent', {
            configurable: true,
            writable: true,
            enumerable: false,
            value: parent || null
        });
    }
    return obj;
}

function getSelectors(sel) {
    // reusing global SELECTORS since this is a synchronous operation
    SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
    sel = sel.replace(/\./g, ' .')
        .replace(/\#/g, ' #')
        .replace(/\[/g, ' [')
        .replace(/\>/g, ' > ')
        .replace(/\+/g, ' + ')
        .replace(/\~/g, ' ~ ')
        .replace(/\*/g, ' * ')
        .replace(/\:not\((.*?)\)/g, ' ');
    const items = sel.split(' ');
    for (var i = 0; i < items.length; i++) {
        items[i] = items[i].split(':')[0];
        if (items[i].length === 0)
            continue;
        if (items[i].charAt(0) === '.') {
            SELECTORS.classNames.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '#') {
            SELECTORS.ids.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '[') {
            items[i] = items[i].substr(1).split('=')[0].split(']')[0].trim();
            SELECTORS.attrs.push(items[i].toLowerCase());
        }
        else if (/[a-z]/g.test(items[i].charAt(0))) {
            SELECTORS.tags.push(items[i].toLowerCase());
        }
    }
    SELECTORS.classNames = SELECTORS.classNames.sort((a, b) => {
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
    return SELECTORS;
}
const SELECTORS = {
    all: [],
    tags: [],
    classNames: [],
    ids: [],
    attrs: []
};

/**
 * CSS stringify adopted from rework/css by
 * TJ Holowaychuk (@tj)
 * Licensed under the MIT License
 * https://github.com/reworkcss/css/blob/master/LICENSE
 */
class StringifyCss {
    constructor(opts) {
        this.usedSelectors = opts.usedSelectors;
    }
    /**
     * Visit `node`.
     */
    visit(node) {
        return this[node.type](node);
    }
    /**
     * Map visit over array of `nodes`, optionally using a `delim`
     */
    mapVisit(nodes, delim) {
        var buf = '';
        delim = delim || '';
        for (var i = 0, length = nodes.length; i < length; i++) {
            buf += this.visit(nodes[i]);
            if (delim && i < length - 1)
                buf += delim;
        }
        return buf;
    }
    /**
     * Compile `node`.
     */
    compile(node) {
        return node.stylesheet
            .rules.map(this.visit, this)
            .join('');
    }
    comment() {
        return '';
    }
    /**
     * Visit import node.
     */
    import(node) {
        return '@import ' + node.import + ';';
    }
    /**
     * Visit media node.
     */
    media(node) {
        const mediaCss = this.mapVisit(node.rules);
        if (mediaCss === '') {
            return '';
        }
        return '@media ' + node.media + '{' + this.mapVisit(node.rules) + '}';
    }
    /**
     * Visit document node.
     */
    document(node) {
        const documentCss = this.mapVisit(node.rules);
        if (documentCss === '') {
            return '';
        }
        const doc = '@' + (node.vendor || '') + 'document ' + node.document;
        return doc + '{' + documentCss + '}';
    }
    /**
     * Visit charset node.
     */
    charset(node) {
        return '@charset ' + node.charset + ';';
    }
    /**
     * Visit namespace node.
     */
    namespace(node) {
        return '@namespace ' + node.namespace + ';';
    }
    /**
     * Visit supports node.
     */
    supports(node) {
        const supportsCss = this.mapVisit(node.rules);
        if (supportsCss === '') {
            return '';
        }
        return '@supports ' + node.supports + '{' + supportsCss + '}';
    }
    /**
     * Visit keyframes node.
     */
    keyframes(node) {
        const keyframesCss = this.mapVisit(node.keyframes);
        if (keyframesCss === '') {
            return '';
        }
        return '@' + (node.vendor || '') + 'keyframes ' + node.name + '{' + keyframesCss + '}';
    }
    /**
     * Visit keyframe node.
     */
    keyframe(node) {
        const decls = node.declarations;
        return node.values.join(',') + '{' + this.mapVisit(decls) + '}';
    }
    /**
     * Visit page node.
     */
    page(node) {
        const sel = node.selectors.length
            ? node.selectors.join(', ')
            : '';
        return '@page ' + sel + '{' + this.mapVisit(node.declarations) + '}';
    }
    /**
     * Visit font-face node.
     */
    ['font-face'](node) {
        const fontCss = this.mapVisit(node.declarations);
        if (fontCss === '') {
            return '';
        }
        return '@font-face{' + fontCss + '}';
    }
    /**
     * Visit host node.
     */
    host(node) {
        return '@host{' + this.mapVisit(node.rules) + '}';
    }
    /**
     * Visit custom-media node.
     */
    ['custom-media'](node) {
        return '@custom-media ' + node.name + ' ' + node.media + ';';
    }
    /**
     * Visit rule node.
     */
    rule(node) {
        const decls = node.declarations;
        if (!decls.length)
            return '';
        var i, j;
        for (i = node.selectors.length - 1; i >= 0; i--) {
            const sel = getSelectors(node.selectors[i]);
            if (this.usedSelectors) {
                var include = true;
                // classes
                var jlen = sel.classNames.length;
                if (jlen > 0) {
                    for (j = 0; j < jlen; j++) {
                        if (this.usedSelectors.classNames.indexOf(sel.classNames[j]) === -1) {
                            include = false;
                            break;
                        }
                    }
                }
                // tags
                if (include) {
                    jlen = sel.tags.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.tags.indexOf(sel.tags[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // attrs
                if (include) {
                    jlen = sel.attrs.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.attrs.indexOf(sel.attrs[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // ids
                if (include) {
                    jlen = sel.ids.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.ids.indexOf(sel.ids[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                if (!include) {
                    node.selectors.splice(i, 1);
                }
            }
        }
        if (node.selectors.length === 0)
            return '';
        return `${node.selectors}{${this.mapVisit(decls)}}`;
    }
    /**
     * Visit declaration node.
     */
    declaration(node) {
        return node.property + ':' + node.value + ';';
    }
}

function removeUnusedStyles(config, usedSelectors, cssContent, diagnostics) {
    let cleanedCss = cssContent;
    try {
        // parse the css from being applied to the document
        const cssAst = parseCss(config, cssContent);
        if (cssAst.stylesheet.diagnostics.length) {
            cssAst.stylesheet.diagnostics.forEach(d => {
                diagnostics.push(d);
            });
            return cleanedCss;
        }
        try {
            // convert the parsed css back into a string
            // but only keeping what was found in our active selectors
            const stringify = new StringifyCss({ usedSelectors });
            cleanedCss = stringify.compile(cssAst);
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'css',
                header: 'CSS Stringify',
                messageText: e
            });
        }
    }
    catch (e) {
        diagnostics.push({
            level: 'error',
            type: 'css',
            header: 'CSS Parse',
            messageText: e
        });
    }
    return cleanedCss;
}

class UsedSelectors {
    constructor(elm) {
        this.tags = [];
        this.classNames = [];
        this.ids = [];
        this.attrs = [];
        this.collectSelectors(elm);
    }
    collectSelectors(elm) {
        var i;
        if (elm && elm.tagName) {
            // tags
            const tagName = elm.tagName.toLowerCase();
            if (this.tags.indexOf(tagName) === -1) {
                this.tags.push(tagName);
            }
            // classes
            const classList = elm.classList;
            for (i = 0; i < classList.length; i++) {
                const className = classList[i];
                if (this.classNames.indexOf(className) === -1) {
                    this.classNames.push(className);
                }
            }
            // attributes
            const attributes = elm.attributes;
            for (i = 0; i < attributes.length; i++) {
                const attr = attributes[i];
                const attrName = attr.name.toLowerCase();
                if (!attrName || attrName === 'class' || attrName === 'id' || attrName === 'style')
                    continue;
                if (this.attrs.indexOf(attrName) === -1) {
                    this.attrs.push(attrName);
                }
            }
            // ids
            var idValue = elm.getAttribute('id');
            if (idValue) {
                idValue = idValue.trim();
                if (idValue && this.ids.indexOf(idValue) === -1) {
                    this.ids.push(idValue);
                }
            }
            // drill down
            for (i = 0; i < elm.children.length; i++) {
                this.collectSelectors(elm.children[i]);
            }
        }
    }
}

function inlineComponentStyles(config, outputTarget, doc, styles, diagnostics) {
    if (!styles.length) {
        return;
    }
    if (outputTarget.removeUnusedStyles !== false) {
        // removeUnusedStyles is the default
        try {
            // pick out all of the selectors that are actually
            // being used in the html document
            const usedSelectors = new UsedSelectors(doc.documentElement);
            styles = styles.map(styleText => {
                return removeUnusedStyles(config, usedSelectors, styleText, diagnostics);
            });
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'HTML Selector Parse',
                messageText: e
            });
        }
    }
    // insert our styles to the head of the document
    insertStyles(doc, styles);
}
function insertStyles(doc, styles) {
    const styleElm = doc.createElement('style');
    styleElm.setAttribute('data-styles', '');
    styleElm.innerHTML = styles.join('').trim();
    if (styleElm.innerHTML.length) {
        doc.head.insertBefore(styleElm, doc.head.firstChild);
    }
}

var __awaiter$28 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function inlineExternalAssets(config, compilerCtx, outputTarget, windowLocationPath, doc) {
    return __awaiter$28(this, void 0, void 0, function* () {
        const linkElements = doc.querySelectorAll('link[href][rel="stylesheet"]');
        for (var i = 0; i < linkElements.length; i++) {
            inlineStyle(config, compilerCtx, outputTarget, windowLocationPath, doc, linkElements[i]);
        }
        const scriptElements = doc.querySelectorAll('script[src]');
        for (i = 0; i < scriptElements.length; i++) {
            yield inlineScript(config, compilerCtx, outputTarget, windowLocationPath, scriptElements[i]);
        }
    });
}
function inlineStyle(config, compilerCtx, outputTarget, windowLocationPath, doc, linkElm) {
    return __awaiter$28(this, void 0, void 0, function* () {
        const content = yield getAssetContent(config, compilerCtx, outputTarget, windowLocationPath, linkElm.href);
        if (!content) {
            return;
        }
        config.logger.debug(`optimize ${windowLocationPath}, inline style: ${config.sys.url.parse(linkElm.href).pathname}`);
        const styleElm = doc.createElement('style');
        styleElm.innerHTML = content;
        linkElm.parentNode.insertBefore(styleElm, linkElm);
        linkElm.parentNode.removeChild(linkElm);
    });
}
function inlineScript(config, compilerCtx, outputTarget, windowLocationPath, scriptElm) {
    return __awaiter$28(this, void 0, void 0, function* () {
        const content = yield getAssetContent(config, compilerCtx, outputTarget, windowLocationPath, scriptElm.src);
        if (!content) {
            return;
        }
        config.logger.debug(`optimize ${windowLocationPath}, inline script: ${scriptElm.src}`);
        scriptElm.innerHTML = content;
        scriptElm.removeAttribute('src');
    });
}
function getAssetContent(config, ctx, outputTarget, windowLocationPath, assetUrl) {
    return __awaiter$28(this, void 0, void 0, function* () {
        if (typeof assetUrl !== 'string' || assetUrl.trim() === '') {
            return null;
        }
        // figure out the url's so we can check the hostnames
        const fromUrl = config.sys.url.parse(windowLocationPath);
        const toUrl = config.sys.url.parse(assetUrl);
        if (fromUrl.hostname !== toUrl.hostname) {
            // not the same hostname, so we wouldn't have the file content
            return null;
        }
        // figure out the local file path
        const filePath = getFilePathFromUrl$1(config, outputTarget, fromUrl, toUrl);
        // doesn't look like we've got it cached in app files
        try {
            // try looking it up directly
            const content = yield ctx.fs.readFile(filePath);
            // rough estimate of size
            const fileSize = content.length;
            if (fileSize > outputTarget.inlineAssetsMaxSize) {
                // welp, considered too big, don't inline
                return null;
            }
            return content;
        }
        catch (e) {
            // never found the content for this file
            return null;
        }
    });
}
function getFilePathFromUrl$1(config, outputTarget, fromUrl, toUrl) {
    const resolvedUrl = '.' + config.sys.url.resolve(fromUrl.pathname, toUrl.pathname);
    return pathJoin(config, outputTarget.dir, resolvedUrl);
}

var __awaiter$29 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function inlineLoaderScript(config, compilerCtx, outputTarget, windowLocationPath, doc) {
    return __awaiter$29(this, void 0, void 0, function* () {
        // create the script url we'll be looking for
        const loaderFileName = getLoaderFileName(config);
        // find the external loader script
        // which is usually in the <head> and a pretty small external file
        // now that we're prerendering the html, and all the styles and html
        // will get hardcoded in the output, it's safe to now put the
        // loader script at the bottom of <body>
        const scriptElm = findExternalLoaderScript(doc, loaderFileName);
        if (scriptElm) {
            // append the loader script content to the bottom of <body>
            yield updateInlineLoaderScriptElement(config, compilerCtx, outputTarget, doc, windowLocationPath, scriptElm);
        }
    });
}
function findExternalLoaderScript(doc, loaderFileName) {
    const scriptElements = doc.getElementsByTagName('script');
    for (let i = 0; i < scriptElements.length; i++) {
        const src = scriptElements[i].getAttribute('src');
        if (isLoaderScriptSrc(loaderFileName, src)) {
            // this is a script element with a src attribute which is
            // pointing to the app's external loader script
            // remove the script from the document, be gone with you
            return scriptElements[i];
        }
    }
    return null;
}
function isLoaderScriptSrc(loaderFileName, scriptSrc) {
    try {
        if (typeof scriptSrc !== 'string' || scriptSrc.trim() === '') {
            return false;
        }
        scriptSrc = scriptSrc.toLowerCase();
        if (scriptSrc.startsWith('http') || scriptSrc.startsWith('file')) {
            return false;
        }
        scriptSrc = scriptSrc.split('?')[0].split('#')[0];
        loaderFileName = loaderFileName.split('?')[0].split('#')[0];
        if (scriptSrc === loaderFileName || scriptSrc.endsWith('/' + loaderFileName)) {
            return true;
        }
    }
    catch (e) { }
    return false;
}
function updateInlineLoaderScriptElement(config, compilerCtx, outputTarget, doc, windowLocationPath, scriptElm) {
    return __awaiter$29(this, void 0, void 0, function* () {
        // get the file path
        const appLoaderPath = getLoaderPath(config, outputTarget);
        // get the loader content
        let content = null;
        try {
            // let's look it up directly
            content = yield compilerCtx.fs.readFile(appLoaderPath);
        }
        catch (e) {
            config.logger.debug(`unable to inline loader: ${appLoaderPath}`, e);
        }
        if (!content) {
            // didn't get good loader content, don't bother
            return;
        }
        config.logger.debug(`optimize ${windowLocationPath}, inline loader`);
        // remove the external src
        scriptElm.removeAttribute('src');
        // only add the data-resources-url attr if we don't already have one
        const existingResourcesUrlAttr = scriptElm.getAttribute('data-resources-url');
        if (!existingResourcesUrlAttr) {
            const resourcesUrl = setDataResourcesUrlAttr(config, outputTarget);
            // add the resource path data attribute
            scriptElm.setAttribute('data-resources-url', resourcesUrl);
        }
        // inline the js content
        scriptElm.innerHTML = content;
        if (outputTarget.hydrateComponents) {
            // remove the script element from where it's currently at in the dom
            scriptElm.parentNode.removeChild(scriptElm);
            // place it back in the dom, but at the bottom of the body
            doc.body.appendChild(scriptElm);
        }
    });
}
function setDataResourcesUrlAttr(config, outputTarget) {
    let resourcesUrl = outputTarget.resourcesUrl;
    if (!resourcesUrl) {
        resourcesUrl = config.sys.path.join(outputTarget.buildDir, config.fsNamespace);
        resourcesUrl = normalizePath(config.sys.path.relative(outputTarget.dir, resourcesUrl));
        if (!resourcesUrl.startsWith('/')) {
            resourcesUrl = '/' + resourcesUrl;
        }
        if (!resourcesUrl.endsWith('/')) {
            resourcesUrl = resourcesUrl + '/';
        }
        resourcesUrl = outputTarget.baseUrl + resourcesUrl.substring(1);
    }
    return resourcesUrl;
}

function updateCanonicalLink(config, doc, windowLocationPath) {
    // https://webmasters.googleblog.com/2009/02/specify-your-canonical.html
    // <link rel="canonical" href="http://www.example.com/product.php?item=swedish-fish" />
    if (typeof windowLocationPath !== 'string') {
        return;
    }
    const canonicalLink = doc.querySelector('link[rel="canonical"]');
    if (!canonicalLink) {
        return;
    }
    const existingHref = canonicalLink.getAttribute('href');
    const updatedRref = updateCanonicalLinkHref(config, existingHref, windowLocationPath);
    canonicalLink.setAttribute('href', updatedRref);
}
function updateCanonicalLinkHref(config, href, windowLocationPath) {
    const parsedUrl = config.sys.url.parse(windowLocationPath);
    if (typeof href === 'string') {
        href = href.trim();
        if (href.endsWith('/')) {
            href = href.substr(0, href.length - 1);
        }
    }
    else {
        href = '';
    }
    return `${href}${parsedUrl.path}`;
}

var __awaiter$30 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Interal minifier, not exposed publicly.
 */
function minifyJs(config, compilerCtx, jsText, sourceTarget, preamble) {
    return __awaiter$30(this, void 0, void 0, function* () {
        const opts = { output: {}, compress: {}, mangle: true };
        if (sourceTarget === 'es5') {
            opts.ecma = 5;
            opts.output.ecma = 5;
            opts.compress.ecma = 5;
            opts.compress.arrows = false;
            opts.output.beautify = false;
        }
        else {
            opts.ecma = 6;
            opts.output.ecma = 6;
            opts.compress.ecma = 6;
            opts.toplevel = true;
            opts.compress.arrows = true;
            opts.output.beautify = false;
        }
        if (config.logLevel === 'debug') {
            opts.mangle = {};
            opts.mangle.keep_fnames = true;
            opts.compress.drop_console = false;
            opts.compress.drop_debugger = false;
            opts.output.beautify = true;
            opts.output.bracketize = true;
            opts.output.indent_level = 2;
            opts.output.comments = 'all';
            opts.output.preserve_line = true;
        }
        else {
            opts.compress.pure_funcs = ['assert', 'console.debug'];
        }
        opts.compress.passes = 2;
        if (preamble) {
            opts.output.preamble = generatePreamble(config);
        }
        let cacheKey;
        if (compilerCtx) {
            cacheKey = compilerCtx.cache.createKey('minifyJs', opts, jsText);
            const cachedContent = yield compilerCtx.cache.get(cacheKey);
            if (cachedContent != null) {
                return {
                    output: cachedContent,
                    diagnostics: []
                };
            }
        }
        const r = config.sys.minifyJs(jsText, opts);
        if (compilerCtx) {
            if (r && r.diagnostics.length === 0 && typeof r.output === 'string') {
                yield compilerCtx.cache.put(cacheKey, r.output);
            }
        }
        return r;
    });
}

var __awaiter$31 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function minifyInlineScripts(config, compilerCtx, doc, diagnostics) {
    return __awaiter$31(this, void 0, void 0, function* () {
        const scripts = doc.querySelectorAll('script');
        const promises = [];
        for (let i = 0; i < scripts.length; i++) {
            promises.push(minifyInlineStyle(config, compilerCtx, diagnostics, scripts[i]));
        }
        yield Promise.all(promises);
    });
}
function minifyInlineStyle(config, compilerCtx, diagnostics, script) {
    return __awaiter$31(this, void 0, void 0, function* () {
        if (script.hasAttribute('src')) {
            return;
        }
        if (script.innerHTML.includes('  ') || script.innerHTML.includes('\t')) {
            const minifyResults = yield minifyJs(config, compilerCtx, script.innerHTML, 'es5', false);
            minifyResults.diagnostics.forEach(diagnostic => {
                diagnostics.push(diagnostic);
            });
            if (typeof minifyResults.output === 'string') {
                script.innerHTML = minifyResults.output;
            }
        }
    });
}

var __awaiter$32 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function minifyStyle(config, compilerCtx, diagnostics, styleText) {
    return __awaiter$32(this, void 0, void 0, function* () {
        const cacheKey = compilerCtx.cache.createKey('minifyStyle', styleText);
        const cachedContent = yield compilerCtx.cache.get(cacheKey);
        if (cachedContent != null) {
            return cachedContent;
        }
        const minifyResults = config.sys.minifyCss(styleText);
        minifyResults.diagnostics.forEach(d => {
            diagnostics.push(d);
        });
        if (typeof minifyResults.output === 'string') {
            yield compilerCtx.cache.put(cacheKey, minifyResults.output);
            return minifyResults.output;
        }
        return styleText;
    });
}

var __awaiter$33 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function minifyInlineStyles(config, compilerCtx, doc, diagnostics) {
    return __awaiter$33(this, void 0, void 0, function* () {
        const styles = doc.querySelectorAll('style');
        const promises = [];
        for (let i = 0; i < styles.length; i++) {
            promises.push(minifyInlineStyle$1(config, compilerCtx, diagnostics, styles[i]));
        }
        yield Promise.all(promises);
    });
}
function minifyInlineStyle$1(config, compilerCtx, diagnostics, style) {
    return __awaiter$33(this, void 0, void 0, function* () {
        if (style.innerHTML.includes('  ') || style.innerHTML.includes('\t')) {
            style.innerHTML = yield minifyStyle(config, compilerCtx, diagnostics, style.innerHTML);
        }
    });
}

var __awaiter$34 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function optimizeHtml(config, compilerCtx, hydrateTarget, windowLocationPath, doc, styles, diagnostics) {
    return __awaiter$34(this, void 0, void 0, function* () {
        const promises = [];
        if (hydrateTarget.hydrateComponents) {
            doc.documentElement.setAttribute('data-ssr', '');
        }
        if (hydrateTarget.canonicalLink) {
            try {
                updateCanonicalLink(config, doc, windowLocationPath);
            }
            catch (e) {
                diagnostics.push({
                    level: 'error',
                    type: 'hydrate',
                    header: 'Insert Canonical Link',
                    messageText: e
                });
            }
        }
        if (hydrateTarget.inlineStyles) {
            try {
                inlineComponentStyles(config, hydrateTarget, doc, styles, diagnostics);
            }
            catch (e) {
                diagnostics.push({
                    level: 'error',
                    type: 'hydrate',
                    header: 'Inline Component Styles',
                    messageText: e
                });
            }
        }
        if (hydrateTarget.inlineLoaderScript) {
            // remove the script to the external loader script request
            // inline the loader script at the bottom of the html
            promises.push(inlineLoaderScript(config, compilerCtx, hydrateTarget, windowLocationPath, doc));
        }
        if (hydrateTarget.inlineAssetsMaxSize > 0) {
            promises.push(inlineExternalAssets(config, compilerCtx, hydrateTarget, windowLocationPath, doc));
        }
        if (hydrateTarget.collapseWhitespace && !config.devMode && config.logLevel !== 'debug') {
            // collapseWhitespace is the default
            try {
                config.logger.debug(`optimize ${windowLocationPath}, collapse html whitespace`);
                collapseHtmlWhitepace(doc.documentElement);
            }
            catch (e) {
                diagnostics.push({
                    level: 'error',
                    type: 'hydrate',
                    header: 'Reduce HTML Whitespace',
                    messageText: e
                });
            }
        }
        // need to wait on to see if external files are inlined
        yield Promise.all(promises);
        // reset for new promises
        promises.length = 0;
        if (config.minifyCss) {
            promises.push(minifyInlineStyles(config, compilerCtx, doc, diagnostics));
        }
        if (config.minifyJs) {
            promises.push(minifyInlineScripts(config, compilerCtx, doc, diagnostics));
        }
        if (config.assetVersioning) {
            promises.push(assetVersioning(config, compilerCtx, hydrateTarget, windowLocationPath, doc));
        }
        yield Promise.all(promises);
    });
}
function optimizeIndexHtml(config, compilerCtx, hydrateTarget, windowLocationPath, diagnostics) {
    return __awaiter$34(this, void 0, void 0, function* () {
        try {
            hydrateTarget.html = yield compilerCtx.fs.readFile(hydrateTarget.indexHtml);
            try {
                const dom = config.sys.createDom();
                const win = dom.parse(hydrateTarget);
                const doc = win.document;
                const styles = [];
                yield optimizeHtml(config, compilerCtx, hydrateTarget, windowLocationPath, doc, styles, diagnostics);
                // serialize this dom back into a string
                yield compilerCtx.fs.writeFile(hydrateTarget.indexHtml, dom.serialize());
            }
            catch (e) {
                catchError(diagnostics, e);
            }
        }
        catch (e) {
            // index.html file doesn't exist, which is fine
        }
    });
}

/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const stack = [];
function h(nodeName, vnodeData, child) {
    let children = null;
    let lastSimple = false;
    let simple = false;
    for (var i = arguments.length; i-- > 2;) {
        stack.push(arguments[i]);
    }
    while (stack.length > 0) {
        if ((child = stack.pop()) && child.pop !== undefined) {
            for (i = child.length; i--;) {
                stack.push(child[i]);
            }
        }
        else {
            if (typeof child === 'boolean') {
                child = null;
            }
            if ((simple = typeof nodeName !== 'function')) {
                if (child == null) {
                    child = '';
                }
                else if (typeof child === 'number') {
                    child = String(child);
                }
                else if (typeof child !== 'string') {
                    simple = false;
                }
            }
            if (simple && lastSimple) {
                children[children.length - 1].vtext += child;
            }
            else if (children === null) {
                children = [simple ? { vtext: child } : child];
            }
            else {
                children.push(simple ? { vtext: child } : child);
            }
            lastSimple = simple;
        }
    }
    let vkey;
    let vname;
    if (vnodeData != null) {
        // normalize class / classname attributes
        if (vnodeData['className']) {
            vnodeData['class'] = vnodeData['className'];
        }
        if (typeof vnodeData['class'] === 'object') {
            for (i in vnodeData['class']) {
                if (vnodeData['class'][i]) {
                    stack.push(i);
                }
            }
            vnodeData['class'] = stack.join(' ');
            stack.length = 0;
        }
        if (vnodeData.key != null) {
            vkey = vnodeData.key;
        }
        if (vnodeData.name != null) {
            vname = vnodeData.name;
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(Object.assign({}, vnodeData, { children: children }), utils);
    }
    return {
        vtag: nodeName,
        vchildren: children,
        vtext: undefined,
        vattrs: vnodeData,
        vkey: vkey,
        vname: vname,
        elm: undefined,
        ishost: false
    };
}
const utils = {
    'getAttributes': (vnode) => vnode.vattrs,
    'replaceAttributes': (vnode, attributes) => vnode.vattrs = attributes
};

function normalizeHydrateOptions(wwwTarget, opts) {
    const hydrateTarget = Object.assign({}, wwwTarget);
    hydrateTarget.prerenderLocations = wwwTarget.prerenderLocations.map(p => Object.assign({}, p));
    hydrateTarget.hydrateComponents = true;
    const req = opts.req;
    if (req && typeof req.get === 'function') {
        // assuming node express request object
        // https://expressjs.com/
        if (!opts.url)
            opts.url = req.protocol + '://' + req.get('host') + req.originalUrl;
        if (!opts.referrer)
            opts.referrer = req.get('referrer');
        if (!opts.userAgent)
            opts.userAgent = req.get('user-agent');
        if (!opts.cookie)
            opts.cookie = req.get('cookie');
    }
    Object.assign(hydrateTarget, opts);
    return hydrateTarget;
}
function generateHydrateResults(config, hydrateTarget) {
    if (!hydrateTarget.url) {
        hydrateTarget.url = `https://hydrate.stenciljs.com/`;
    }
    // https://nodejs.org/api/url.html
    const urlParse = config.sys.url.parse(hydrateTarget.url);
    const hydrateResults = {
        diagnostics: [],
        url: hydrateTarget.url,
        host: urlParse.host,
        hostname: urlParse.hostname,
        port: urlParse.port,
        path: urlParse.path,
        pathname: urlParse.pathname,
        search: urlParse.search,
        query: urlParse.query,
        hash: urlParse.hash,
        html: hydrateTarget.html,
        styles: null,
        anchors: [],
        components: [],
        styleUrls: [],
        scriptUrls: [],
        imgUrls: []
    };
    createConsole(config, hydrateTarget, hydrateResults);
    return hydrateResults;
}
function createConsole(config, opts, results) {
    const pathname = results.pathname;
    opts.console = opts.console || {};
    if (typeof opts.console.error !== 'function') {
        opts.console.error = function (...args) {
            results.diagnostics.push({
                level: `error`,
                type: `hydrate`,
                header: `runtime console.error: ${pathname}`,
                messageText: args.join(', ')
            });
        };
    }
    if (config.logLevel === 'debug') {
        ['debug', 'info', 'log', 'warn'].forEach(level => {
            if (typeof opts.console[level] !== 'function') {
                opts.console[level] = function (...args) {
                    results.diagnostics.push({
                        level: level,
                        type: 'hydrate',
                        header: `runtime console.${level}: ${pathname}`,
                        messageText: args.join(', ')
                    });
                };
            }
        });
    }
}
function normalizeDirection(doc, hydrateTarget) {
    let dir = doc.body.getAttribute('dir');
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir.trim().length > 0) {
            console.warn(`dir="${dir}" should be placed on the <html> instead of <body>`);
        }
    }
    if (hydrateTarget.direction) {
        dir = hydrateTarget.direction;
    }
    else {
        dir = doc.documentElement.getAttribute('dir');
    }
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir !== 'ltr' && dir !== 'rtl') {
            console.warn(`only "ltr" and "rtl" are valid "dir" values on the <html> element`);
        }
    }
    if (dir !== 'ltr' && dir !== 'rtl') {
        dir = 'ltr';
    }
    doc.documentElement.dir = dir;
}
function normalizeLanguage(doc, hydrateTarget) {
    let lang = doc.body.getAttribute('lang');
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.trim().length > 0) {
            console.warn(`lang="${lang}" should be placed on <html> instead of <body>`);
        }
    }
    if (hydrateTarget.language) {
        lang = hydrateTarget.language;
    }
    else {
        lang = doc.documentElement.getAttribute('lang');
    }
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.length > 0) {
            doc.documentElement.lang = lang;
        }
    }
}
function collectAnchors(config, doc, results) {
    const anchorElements = doc.querySelectorAll('a');
    for (var i = 0; i < anchorElements.length; i++) {
        const attrs = {};
        const anchorAttrs = anchorElements[i].attributes;
        for (var j = 0; j < anchorAttrs.length; j++) {
            attrs[anchorAttrs[j].nodeName.toLowerCase()] = anchorAttrs[j].nodeValue;
        }
        results.anchors.push(attrs);
    }
    config.logger.debug(`optimize ${results.pathname}, collected anchors: ${results.anchors.length}`);
}
function generateFailureDiagnostic(diagnostic) {
    return `
    <div style="padding: 20px;">
      <div style="font-weight: bold;">${diagnostic.header}</div>
      <div>${diagnostic.messageText}</div>
    </div>
  `;
}

const Build = {
    cssVarShim: true,
    shadowDom: true,
    slotPolyfill: true,
    ssrServerSide: true,
    devInspector: true,
    verboseError: true,
    styles: true,
    hostData: true,
    hostTheme: true,
    reflectToAttr: true,
    hasSlot: true,
    hasSvg: true,
    observeAttr: true,
    isDev: true,
    isProd: false,
    // decorators
    element: true,
    event: true,
    listener: true,
    method: true,
    propConnect: true,
    propContext: true,
    watchCallback: true,
    // lifecycle events
    cmpDidLoad: true,
    cmpWillLoad: true,
    cmpDidUpdate: true,
    cmpWillUpdate: true,
    cmpDidUnload: true,
};

function useShadowDom(supportsNativeShadowDom, cmpMeta) {
    return (supportsNativeShadowDom && cmpMeta.encapsulation === 1 /* ShadowDom */);
}

function initHostSnapshot(domApi, cmpMeta, elm, hostSnapshot, attribName) {
    // MAIN THREAD
    if (Build.slotPolyfill) {
        // host element has been connected to the DOM
        if (!elm['s-cr'] && !domApi.$getAttribute(elm, SSR_VNODE_ID) && !useShadowDom(domApi.$supportsShadowDom, cmpMeta)) {
            // only required when we're NOT using native shadow dom (slot)
            // this host element was NOT created with SSR
            // let's pick out the inner content for slot projection
            // create a node to represent where the original
            // content was first placed, which is useful later on
            elm['s-cr'] = domApi.$createTextNode('');
            elm['s-cr']['s-cn'] = true;
            domApi.$insertBefore(elm, elm['s-cr'], domApi.$childNodes(elm)[0]);
        }
        if (!domApi.$supportsShadowDom && cmpMeta.encapsulation === 1 /* ShadowDom */) {
            // this component should use shadow dom
            // but this browser doesn't support it
            // so let's polyfill a few things for the user
            if (Build.isDev && Build.clientSide) {
                // it's possible we're manually forcing the slot polyfill
                // but this browser may already support the read-only shadowRoot
                // do an extra check here, but only for dev mode on the client
                if (!('shadowRoot' in HTMLElement.prototype)) {
                    elm.shadowRoot = elm;
                }
            }
            else {
                elm.shadowRoot = elm;
            }
        }
    }
    hostSnapshot = {
        $id: elm['s-id'],
        $attributes: {}
    };
    cmpMeta.membersMeta && Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        if (attribName = cmpMeta.membersMeta[memberName].attribName) {
            hostSnapshot.$attributes[attribName] = domApi.$getAttribute(elm, attribName);
        }
    });
    return hostSnapshot;
}

function initElementListeners(plt, elm) {
    // so the element was just connected, which means it's in the DOM
    // however, the component instance hasn't been created yet
    // but what if an event it should be listening to get emitted right now??
    // let's add our listeners right now to our element, and if it happens
    // to receive events between now and the instance being created let's
    // queue up all of the event data and fire it off on the instance when it's ready
    const cmpMeta = plt.getComponentMeta(elm);
    if (cmpMeta.listenersMeta) {
        // we've got listens
        cmpMeta.listenersMeta.forEach(listenMeta => {
            // go through each listener
            if (!listenMeta.eventDisabled) {
                // only add ones that are not already disabled
                plt.domApi.$addEventListener(elm, listenMeta.eventName, createListenerCallback(plt, elm, listenMeta.eventMethodName), listenMeta.eventCapture, listenMeta.eventPassive);
            }
        });
    }
}
function createListenerCallback(plt, elm, eventMethodName, val) {
    // create the function that gets called when the element receives
    // an event which it should be listening for
    return (ev) => {
        // get the instance if it exists
        val = plt.instanceMap.get(elm);
        if (val) {
            // instance is ready, let's call it's member method for this event
            val[eventMethodName](ev);
        }
        else {
            // instance is not ready!!
            // let's queue up this event data and replay it later
            // when the instance is ready
            val = (plt.queuedEvents.get(elm) || []);
            val.push(eventMethodName, ev);
            plt.queuedEvents.set(elm, val);
        }
    };
}
function enableEventListener(plt, instance, eventName, shouldEnable, attachTo, passive) {
    if (instance) {
        // cool, we've got an instance, it's get the element it's on
        const elm = plt.hostElementMap.get(instance);
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.listenersMeta) {
            // alrighty, so this cmp has listener meta
            if (shouldEnable) {
                // we want to enable this event
                // find which listen meta we're talking about
                const listenMeta = cmpMeta.listenersMeta.find(l => l.eventName === eventName);
                if (listenMeta) {
                    // found the listen meta, so let's add the listener
                    plt.domApi.$addEventListener(elm, eventName, (ev) => instance[listenMeta.eventMethodName](ev), listenMeta.eventCapture, (passive === undefined) ? listenMeta.eventPassive : !!passive, attachTo);
                }
            }
            else {
                // we're disabling the event listener
                // so let's just remove it entirely
                plt.domApi.$removeEventListener(elm, eventName);
            }
        }
    }
}

function connectedCallback(plt, cmpMeta, elm) {
    if (Build.listener) {
        // initialize our event listeners on the host element
        // we do this now so that we can listening to events that may
        // have fired even before the instance is ready
        if (!plt.hasListenersMap.has(elm)) {
            // it's possible we've already connected
            // then disconnected
            // and the same element is reconnected again
            plt.hasListenersMap.set(elm, true);
            initElementListeners(plt, elm);
        }
    }
    // this element just connected, which may be re-connecting
    // ensure we remove it from our map of disconnected
    plt.isDisconnectedMap.delete(elm);
    if (!plt.hasConnectedMap.has(elm)) {
        // first time we've connected
        plt.hasConnectedMap.set(elm, true);
        if (!elm['s-id']) {
            // assign a unique id to this host element
            // it's possible this was already given an element id
            elm['s-id'] = plt.nextId();
        }
        // register this component as an actively
        // loading child to its parent component
        registerWithParentComponent(plt, elm);
        // add to the queue to load the bundle
        // it's important to have an async tick in here so we can
        // ensure the "mode" attribute has been added to the element
        // place in high priority since it's not much work and we need
        // to know as fast as possible, but still an async tick in between
        plt.queue.tick(() => 
        // start loading this component mode's bundle
        // if it's already loaded then the callback will be synchronous
        plt.requestBundle(cmpMeta, elm, initHostSnapshot(plt.domApi, cmpMeta, elm)));
    }
}
function registerWithParentComponent(plt, elm, ancestorHostElement) {
    // find the first ancestor host element (if there is one) and register
    // this element as one of the actively loading child elements for its ancestor
    ancestorHostElement = elm;
    while (ancestorHostElement = plt.domApi.$parentElement(ancestorHostElement)) {
        // climb up the ancestors looking for the first registered component
        if (plt.isDefinedComponent(ancestorHostElement)) {
            // we found this elements the first ancestor host element
            // if the ancestor already loaded then do nothing, it's too late
            if (!plt.hasLoadedMap.has(elm)) {
                // keep a reference to this element's ancestor host element
                // elm._ancestorHostElement = ancestorHostElement;
                plt.ancestorHostElementMap.set(elm, ancestorHostElement);
                // ensure there is an array to contain a reference to each of the child elements
                // and set this element as one of the ancestor's child elements it should wait on
                if (ancestorHostElement['$activeLoading']) {
                    // $activeLoading deprecated 2018-04-02
                    ancestorHostElement['s-ld'] = ancestorHostElement['$activeLoading'];
                }
                (ancestorHostElement['s-ld'] = ancestorHostElement['s-ld'] || []).push(elm);
            }
            break;
        }
    }
}

function parsePropertyValue(propType, propValue) {
    // ensure this value is of the correct prop type
    // we're testing both formats of the "propType" value because
    // we could have either gotten the data from the attribute changed callback,
    // which wouldn't have Constructor data yet, and because this method is reused
    // within proxy where we don't have meta data, but only constructor data
    if (isDef(propValue) && typeof propValue !== 'object' && typeof propValue !== 'function') {
        if (propType === Boolean || propType === 3 /* Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return (propValue === 'false' ? false : propValue === '' || !!propValue);
        }
        if (propType === Number || propType === 4 /* Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (propType === String || propType === 2 /* String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return propValue.toString();
        }
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
}

function attributeChangedCallback(membersMeta, elm, attribName, oldVal, newVal, propName, memberMeta) {
    // only react if the attribute values actually changed
    if (membersMeta && oldVal !== newVal) {
        // using the known component meta data
        // look up to see if we have a property wired up to this attribute name
        for (propName in membersMeta) {
            memberMeta = membersMeta[propName];
            // normalize the attribute name w/ lower case
            if (memberMeta.attribName && toLowerCase(memberMeta.attribName) === toLowerCase(attribName)) {
                // cool we've got a prop using this attribute name, the value will
                // be a string, so let's convert it to the correct type the app wants
                elm[propName] = parsePropertyValue(memberMeta.propType, newVal);
                break;
            }
        }
    }
}

function initEventEmitters(plt, cmpEvents, instance) {
    if (cmpEvents) {
        const elm = plt.hostElementMap.get(instance);
        cmpEvents.forEach(eventMeta => {
            instance[eventMeta.method] = {
                emit: (data) => {
                    plt.emitEvent(elm, eventMeta.name, {
                        bubbles: eventMeta.bubbles,
                        composed: eventMeta.composed,
                        cancelable: eventMeta.cancelable,
                        detail: data
                    });
                }
            };
        });
    }
}

function proxyComponentInstance(plt, cmpConstructor, elm, instance, hostSnapshot, properties, memberName) {
    // at this point we've got a specific node of a host element, and created a component class instance
    // and we've already created getters/setters on both the host element and component class prototypes
    // let's upgrade any data that might have been set on the host element already
    // and let's have the getters/setters kick in and do their jobs
    // let's automatically add a reference to the host element on the instance
    plt.hostElementMap.set(instance, elm);
    // create the values object if it doesn't already exist
    // this will hold all of the internal getter/setter values
    if (!plt.valuesMap.has(elm)) {
        plt.valuesMap.set(elm, {});
    }
    // get the properties from the constructor
    // and add default "mode" and "color" properties
    properties = Object.assign({
        color: { type: String }
    }, cmpConstructor.properties);
    // always set mode
    properties.mode = { type: String };
    // define each of the members and initialize what their role is
    for (memberName in properties) {
        defineMember(plt, properties[memberName], elm, instance, memberName, hostSnapshot);
    }
}

function initComponentInstance(plt, elm, hostSnapshot, instance, componentConstructor, queuedEvents, i) {
    try {
        // using the user's component class, let's create a new instance
        componentConstructor = plt.getComponentMeta(elm).componentConstructor;
        instance = new componentConstructor();
        // ok cool, we've got an host element now, and a actual instance
        // and there were no errors creating the instance
        // let's upgrade the data on the host element
        // and let the getters/setters do their jobs
        proxyComponentInstance(plt, componentConstructor, elm, instance, hostSnapshot);
        if (Build.event) {
            // add each of the event emitters which wire up instance methods
            // to fire off dom events from the host element
            initEventEmitters(plt, componentConstructor.events, instance);
        }
        if (Build.listener) {
            try {
                // replay any event listeners on the instance that
                // were queued up between the time the element was
                // connected and before the instance was ready
                queuedEvents = plt.queuedEvents.get(elm);
                if (queuedEvents) {
                    // events may have already fired before the instance was even ready
                    // now that the instance is ready, let's replay all of the events that
                    // we queued up earlier that were originally meant for the instance
                    for (i = 0; i < queuedEvents.length; i += 2) {
                        // data was added in sets of two
                        // first item the eventMethodName
                        // second item is the event data
                        // take a look at initElementListener()
                        instance[queuedEvents[i]](queuedEvents[i + 1]);
                    }
                    plt.queuedEvents.delete(elm);
                }
            }
            catch (e) {
                plt.onError(e, 2 /* QueueEventsError */, elm);
            }
        }
    }
    catch (e) {
        // something done went wrong trying to create a component instance
        // create a dumby instance so other stuff can load
        // but chances are the app isn't fully working cuz this component has issues
        instance = {};
        plt.onError(e, 7 /* InitInstanceError */, elm, true);
    }
    plt.instanceMap.set(elm, instance);
    return instance;
}
function initComponentLoaded(plt, elm, hydratedCssClass, instance, onReadyCallbacks) {
    if (Build.polyfills && !allChildrenHaveConnected(plt, elm)) {
        // this check needs to be done when using the customElements polyfill
        // since the polyfill uses MutationObserver which causes the
        // connectedCallbacks to fire async, which isn't ideal for the code below
        return;
    }
    // all is good, this component has been told it's time to finish loading
    // it's possible that we've already decided to destroy this element
    // check if this element has any actively loading child elements
    if (!plt.hasLoadedMap.has(elm) &&
        (instance = plt.instanceMap.get(elm)) &&
        !plt.isDisconnectedMap.has(elm) &&
        (!elm['s-ld'] || !elm['s-ld'].length)) {
        // cool, so at this point this element isn't already being destroyed
        // and it does not have any child elements that are still loading
        // ensure we remove any child references cuz it doesn't matter at this point
        delete elm['s-ld'];
        // sweet, this particular element is good to go
        // all of this element's children have loaded (if any)
        // elm._hasLoaded = true;
        plt.hasLoadedMap.set(elm, true);
        try {
            // fire off the ref if it exists
            callNodeRefs(plt.vnodeMap.get(elm));
            // fire off the user's elm.componentOnReady() callbacks that were
            // put directly on the element (well before anything was ready)
            if (onReadyCallbacks = plt.onReadyCallbacksMap.get(elm)) {
                onReadyCallbacks.forEach(cb => cb(elm));
                plt.onReadyCallbacksMap.delete(elm);
            }
            if (Build.cmpDidLoad) {
                // fire off the user's componentDidLoad method (if one was provided)
                // componentDidLoad only runs ONCE, after the instance's element has been
                // assigned as the host element, and AFTER render() has been called
                // we'll also fire this method off on the element, just to
                instance.componentDidLoad && instance.componentDidLoad();
            }
        }
        catch (e) {
            plt.onError(e, 4 /* DidLoadError */, elm);
        }
        // add the css class that this element has officially hydrated
        elm.classList.add(hydratedCssClass);
        // ( •_•)
        // ( •_•)>⌐■-■
        // (⌐■_■)
        // load events fire from bottom to top
        // the deepest elements load first then bubbles up
        propagateComponentLoaded(plt, elm);
    }
}
function allChildrenHaveConnected(plt, elm) {
    // Note: in IE11 <svg> does not have the "children" property
    for (let i = 0; i < elm.childNodes.length; i++) {
        if (elm.childNodes[i].nodeType === 1 /* ElementNode */) {
            if (plt.getComponentMeta(elm.childNodes[i]) && !plt.hasConnectedMap.has(elm.childNodes[i])) {
                // this is a defined componnent
                // but it hasn't connected yet
                return false;
            }
            if (!allChildrenHaveConnected(plt, elm.childNodes[i])) {
                // one of the defined child components hasn't connected yet
                return false;
            }
        }
    }
    // everything has connected, we're good
    return true;
}
function propagateComponentLoaded(plt, elm, index, ancestorsActivelyLoadingChildren) {
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    const ancestorHostElement = plt.ancestorHostElementMap.get(elm);
    if (ancestorHostElement) {
        // ok so this element already has a known ancestor host element
        // let's make sure we remove this element from its ancestor's
        // known list of child elements which are actively loading
        ancestorsActivelyLoadingChildren = ancestorHostElement['s-ld'] || ancestorHostElement['$activeLoading'];
        if (ancestorsActivelyLoadingChildren) {
            index = ancestorsActivelyLoadingChildren.indexOf(elm);
            if (index > -1) {
                // yup, this element is in the list of child elements to wait on
                // remove it so we can work to get the length down to 0
                ancestorsActivelyLoadingChildren.splice(index, 1);
            }
            // the ancestor's initLoad method will do the actual checks
            // to see if the ancestor is actually loaded or not
            // then let's call the ancestor's initLoad method if there's no length
            // (which actually ends up as this method again but for the ancestor)
            if (!ancestorsActivelyLoadingChildren.length) {
                ancestorHostElement['s-init'] && ancestorHostElement['s-init']();
                // $initLoad deprecated 2018-04-02
                ancestorHostElement['$initLoad'] && ancestorHostElement['$initLoad']();
            }
        }
        plt.ancestorHostElementMap.delete(elm);
    }
}

function render(plt, cmpMeta, elm, instance, isUpdateRender) {
    try {
        // if this component has a render function, let's fire
        // it off and generate the child vnodes for this host element
        // note that we do not create the host element cuz it already exists
        const hostMeta = cmpMeta.componentConstructor.host;
        let reflectHostAttr;
        if (Build.reflectToAttr) {
            reflectHostAttr = reflectInstanceValuesToHostAttributes(cmpMeta.componentConstructor.properties, instance);
        }
        if (instance.render || instance.hostData || hostMeta || reflectHostAttr) {
            // tell the platform we're actively rendering
            // if a value is changed within a render() then
            // this tells the platform not to queue the change
            plt.activeRender = true;
            const vnodeChildren = instance.render && instance.render();
            let vnodeHostData;
            if (Build.hostData) {
                // user component provided a "hostData()" method
                // the returned data/attributes are used on the host element
                vnodeHostData = instance.hostData && instance.hostData();
            }
            if (Build.reflectToAttr && reflectHostAttr) {
                vnodeHostData = vnodeHostData ? Object.assign(vnodeHostData, reflectHostAttr) : reflectHostAttr;
            }
            // tell the platform we're done rendering
            // now any changes will again queue
            plt.activeRender = false;
            if (Build.hostTheme && hostMeta) {
                // component meta data has a "theme"
                // use this to automatically generate a good css class
                // from the mode and color to add to the host element
                vnodeHostData = applyComponentHostData(vnodeHostData, hostMeta, instance);
            }
            // looks like we've got child nodes to render into this host element
            // or we need to update the css class/attrs on the host element
            // if we haven't already created a vnode, then we give the renderer the actual element
            // if this is a re-render, then give the renderer the last vnode we already created
            const oldVNode = plt.vnodeMap.get(elm) || {};
            oldVNode.elm = elm;
            const hostVNode = h(null, vnodeHostData, vnodeChildren);
            if (Build.reflectToAttr) {
                // only care if we're reflecting values to the host element
                hostVNode.ishost = true;
            }
            // each patch always gets a new vnode
            // the host element itself isn't patched because it already exists
            // kick off the actual render and any DOM updates
            plt.vnodeMap.set(elm, plt.render(oldVNode, hostVNode, isUpdateRender, cmpMeta.componentConstructor.encapsulation));
        }
        if (Build.styles) {
            // attach the styles this component needs, if any
            // this fn figures out if the styles should go in a
            // shadow root or if they should be global
            plt.attachStyles(plt, plt.domApi, cmpMeta, instance.mode, elm);
        }
        // it's official, this element has rendered
        elm['s-rn'] = true;
        if (elm['$onRender']) {
            // $onRender deprecated 2018-04-02
            elm['s-rc'] = elm['$onRender'];
        }
        if (elm['s-rc']) {
            // ok, so turns out there are some child host elements
            // waiting on this parent element to load
            // let's fire off all update callbacks waiting
            elm['s-rc'].forEach(cb => cb());
            elm['s-rc'] = null;
        }
    }
    catch (e) {
        plt.activeRender = false;
        plt.onError(e, 8 /* RenderError */, elm, true);
    }
}
function applyComponentHostData(vnodeHostData, hostMeta, instance) {
    vnodeHostData = vnodeHostData || {};
    // component meta data has a "theme"
    // use this to automatically generate a good css class
    // from the mode and color to add to the host element
    Object.keys(hostMeta).forEach(key => {
        if (key === 'theme') {
            // host: { theme: 'button' }
            // adds css classes w/ mode and color combinations
            // class="button button-md button-primary button-md-primary"
            convertCssNamesToObj(vnodeHostData['class'] = vnodeHostData['class'] || {}, hostMeta[key], instance.mode, instance.color);
        }
        else if (key === 'class') {
            // host: { class: 'multiple css-classes' }
            // class="multiple css-classes"
            convertCssNamesToObj(vnodeHostData[key] = vnodeHostData[key] || {}, hostMeta[key]);
        }
        else {
            // rando attribute/properties
            vnodeHostData[key] = hostMeta[key];
        }
    });
    return vnodeHostData;
}
function convertCssNamesToObj(cssClassObj, className, mode, color) {
    className.split(' ').forEach(cssClass => {
        cssClassObj[cssClass] = true;
        if (mode) {
            cssClassObj[`${cssClass}-${mode}`] = true;
            if (color) {
                cssClassObj[`${cssClass}-${mode}-${color}`] = cssClassObj[`${cssClass}-${color}`] = true;
            }
        }
    });
}
function reflectInstanceValuesToHostAttributes(properties, instance, reflectHostAttr) {
    if (properties) {
        Object.keys(properties).forEach(memberName => {
            if (properties[memberName].reflectToAttr) {
                reflectHostAttr = reflectHostAttr || {};
                reflectHostAttr[memberName] = instance[memberName];
            }
        });
    }
    return reflectHostAttr;
}

function queueUpdate(plt, elm) {
    // only run patch if it isn't queued already
    if (!plt.isQueuedForUpdate.has(elm)) {
        plt.isQueuedForUpdate.set(elm, true);
        // run the patch in the next tick
        // vdom diff and patch the host element for differences
        if (plt.isAppLoaded) {
            // app has already loaded
            // let's queue this work in the dom write phase
            plt.queue.write(() => update(plt, elm));
        }
        else {
            // app hasn't finished loading yet
            // so let's use next tick to do everything
            // as fast as possible
            plt.queue.tick(() => update(plt, elm));
        }
    }
}
function update(plt, elm, isInitialLoad, instance, ancestorHostElement, userPromise) {
    // no longer queued for update
    plt.isQueuedForUpdate.delete(elm);
    // everything is async, so somehow we could have already disconnected
    // this node, so be sure to do nothing if we've already disconnected
    if (!plt.isDisconnectedMap.has(elm)) {
        instance = plt.instanceMap.get(elm);
        isInitialLoad = !instance;
        if (isInitialLoad) {
            ancestorHostElement = plt.ancestorHostElementMap.get(elm);
            if (ancestorHostElement && ancestorHostElement['$rendered']) {
                // $rendered deprecated 2018-04-02
                ancestorHostElement['s-rn'] = true;
            }
            if (ancestorHostElement && !ancestorHostElement['s-rn']) {
                // this is the intial load
                // this element has an ancestor host element
                // but the ancestor host element has NOT rendered yet
                // so let's just cool our jets and wait for the ancestor to render
                (ancestorHostElement['s-rc'] = ancestorHostElement['s-rc'] || []).push(() => {
                    // this will get fired off when the ancestor host element
                    // finally gets around to rendering its lazy self
                    update(plt, elm);
                });
                // $onRender deprecated 2018-04-02
                ancestorHostElement['$onRender'] = ancestorHostElement['s-rc'];
                return;
            }
            // haven't created a component instance for this host element yet!
            // create the instance from the user's component class
            // https://www.youtube.com/watch?v=olLxrojmvMg
            instance = initComponentInstance(plt, elm, plt.hostSnapshotMap.get(elm));
            if (Build.cmpWillLoad) {
                // fire off the user's componentWillLoad method (if one was provided)
                // componentWillLoad only runs ONCE, after instance's element has been
                // assigned as the host element, but BEFORE render() has been called
                try {
                    if (instance.componentWillLoad) {
                        userPromise = instance.componentWillLoad();
                    }
                }
                catch (e) {
                    plt.onError(e, 3 /* WillLoadError */, elm);
                }
            }
        }
        else if (Build.cmpWillUpdate) {
            // already created an instance and this is an update
            // fire off the user's componentWillUpdate method (if one was provided)
            // componentWillUpdate runs BEFORE render() has been called
            // but only BEFORE an UPDATE and not before the intial render
            // get the returned promise (if one was provided)
            try {
                if (instance.componentWillUpdate) {
                    userPromise = instance.componentWillUpdate();
                }
            }
            catch (e) {
                plt.onError(e, 5 /* WillUpdateError */, elm);
            }
        }
        if (userPromise && userPromise.then) {
            // looks like the user return a promise!
            // let's not actually kick off the render
            // until the user has resolved their promise
            userPromise.then(() => renderUpdate(plt, elm, instance, isInitialLoad));
        }
        else {
            // user never returned a promise so there's
            // no need to wait on anything, let's do the render now my friend
            renderUpdate(plt, elm, instance, isInitialLoad);
        }
    }
}
function renderUpdate(plt, elm, instance, isInitialLoad) {
    // if this component has a render function, let's fire
    // it off and generate a vnode for this
    render(plt, plt.getComponentMeta(elm), elm, instance, !isInitialLoad);
    try {
        if (isInitialLoad) {
            // so this was the initial load i guess
            elm['s-init']();
            // componentDidLoad just fired off
        }
        else {
            if (Build.cmpDidUpdate) {
                // fire off the user's componentDidUpdate method (if one was provided)
                // componentDidUpdate runs AFTER render() has been called
                // but only AFTER an UPDATE and not after the intial render
                instance.componentDidUpdate && instance.componentDidUpdate();
            }
            callNodeRefs(plt.vnodeMap.get(elm));
        }
    }
    catch (e) {
        // derp
        plt.onError(e, 6 /* DidUpdateError */, elm, true);
    }
}

function defineMember(plt, property, elm, instance, memberName, hostSnapshot, hostAttributes, hostAttrValue) {
    function getComponentProp(values) {
        // component instance prop/state getter
        // get the property value directly from our internal values
        values = plt.valuesMap.get(plt.hostElementMap.get(this));
        return values && values[memberName];
    }
    function setComponentProp(newValue, elm) {
        // component instance prop/state setter (cannot be arrow fn)
        elm = plt.hostElementMap.get(this);
        if (elm) {
            if (property.state || property.mutable) {
                setValue(plt, elm, memberName, newValue);
            }
            else if (Build.verboseError) {
                console.warn(`@Prop() "${memberName}" on "${elm.tagName}" cannot be modified.`);
            }
        }
    }
    if (property.type || property.state) {
        const values = plt.valuesMap.get(elm);
        if (!property.state) {
            if (property.attr && (values[memberName] === undefined || values[memberName] === '')) {
                // check the prop value from the host element attribute
                if ((hostAttributes = hostSnapshot && hostSnapshot.$attributes) && isDef(hostAttrValue = hostAttributes[property.attr])) {
                    // looks like we've got an attribute value
                    // let's set it to our internal values
                    values[memberName] = parsePropertyValue(property.type, hostAttrValue);
                }
            }
            if (Build.clientSide) {
                // client-side
                // within the browser, the element's prototype
                // already has its getter/setter set, but on the
                // server the prototype is shared causing issues
                // so instead the server's elm has the getter/setter
                // directly on the actual element instance, not its prototype
                // so on the browser we can use "hasOwnProperty"
                if (elm.hasOwnProperty(memberName)) {
                    // @Prop or @Prop({mutable:true})
                    // property values on the host element should override
                    // any default values on the component instance
                    if (values[memberName] === undefined) {
                        values[memberName] = parsePropertyValue(property.type, elm[memberName]);
                    }
                    // for the client only, let's delete its "own" property
                    // this way our already assigned getter/setter on the prototype kicks in
                    delete elm[memberName];
                }
            }
            else {
                // server-side
                // server-side elm has the getter/setter
                // on the actual element instance, not its prototype
                // on the server we cannot accurately use "hasOwnProperty"
                // instead we'll do a direct lookup to see if the
                // constructor has this property
                if (elementHasProperty(plt, elm, memberName)) {
                    // @Prop or @Prop({mutable:true})
                    // property values on the host element should override
                    // any default values on the component instance
                    if (values[memberName] === undefined) {
                        values[memberName] = elm[memberName];
                    }
                }
            }
        }
        if (instance.hasOwnProperty(memberName) && values[memberName] === undefined) {
            // @Prop() or @Prop({mutable:true}) or @State()
            // we haven't yet got a value from the above checks so let's
            // read any "own" property instance values already set
            // to our internal value as the source of getter data
            // we're about to define a property and it'll overwrite this "own" property
            values[memberName] = instance[memberName];
        }
        if (property.watchCallbacks) {
            values[WATCH_CB_PREFIX + memberName] = property.watchCallbacks.slice();
        }
        // add getter/setter to the component instance
        // these will be pointed to the internal data set from the above checks
        definePropertyGetterSetter(instance, memberName, getComponentProp, setComponentProp);
    }
    else if (Build.element && property.elementRef) {
        // @Element()
        // add a getter to the element reference using
        // the member name the component meta provided
        definePropertyValue(instance, memberName, elm);
    }
    else if (Build.method && property.method) {
        // @Method()
        // add a property "value" on the host element
        // which we'll bind to the instance's method
        definePropertyValue(elm, memberName, instance[memberName].bind(instance));
    }
    else if (Build.propContext && property.context) {
        // @Prop({ context: 'config' })
        const contextObj = plt.getContextItem(property.context);
        if (contextObj !== undefined) {
            definePropertyValue(instance, memberName, (contextObj.getContext && contextObj.getContext(elm)) || contextObj);
        }
    }
    else if (Build.propConnect && property.connect) {
        // @Prop({ connect: 'ion-loading-ctrl' })
        definePropertyValue(instance, memberName, plt.propConnect(property.connect));
    }
}
function setValue(plt, elm, memberName, newVal, values, instance, watchMethods) {
    // get the internal values object, which should always come from the host element instance
    // create the _values object if it doesn't already exist
    values = plt.valuesMap.get(elm);
    if (!values) {
        plt.valuesMap.set(elm, values = {});
    }
    const oldVal = values[memberName];
    // check our new property value against our internal value
    if (newVal !== oldVal) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        // https://youtu.be/dFtLONl4cNc?t=22
        values[memberName] = newVal;
        instance = plt.instanceMap.get(elm);
        if (instance) {
            // get an array of method names of watch functions to call
            watchMethods = values[WATCH_CB_PREFIX + memberName];
            if (Build.watchCallback && watchMethods) {
                // this instance is watching for when this property changed
                for (let i = 0; i < watchMethods.length; i++) {
                    try {
                        // fire off each of the watch methods that are watching this property
                        instance[watchMethods[i]].call(instance, newVal, oldVal, memberName);
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            }
            if (!plt.activeRender && elm['s-rn']) {
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                queueUpdate(plt, elm);
            }
        }
    }
}
function definePropertyValue(obj, propertyKey, value) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'value': value
    });
}
function definePropertyGetterSetter(obj, propertyKey, get, set) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'get': get,
        'set': set
    });
}
const WATCH_CB_PREFIX = `wc-`;
function elementHasProperty(plt, elm, memberName) {
    // within the browser, the element's prototype
    // already has its getter/setter set, but on the
    // server the prototype is shared causing issues
    // so instead the server's elm has the getter/setter
    // directly on the actual element instance, not its prototype
    // so at the time of this function being called, the server
    // side element is unaware if the element has this property
    // name. So for server-side only, do this trick below
    // don't worry, this runtime code doesn't show on the client
    let hasOwnProperty = elm.hasOwnProperty(memberName);
    if (!hasOwnProperty) {
        // element doesn't
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta) {
            if (cmpMeta.componentConstructor && cmpMeta.componentConstructor.properties) {
                // if we have the constructor property data, let's check that
                const member = cmpMeta.componentConstructor.properties[memberName];
                hasOwnProperty = !!(member && member.type);
            }
            if (!hasOwnProperty && cmpMeta.membersMeta) {
                // if we have the component's metadata, let's check that
                const member = cmpMeta.membersMeta[memberName];
                hasOwnProperty = !!(member && member.propType);
            }
        }
    }
    return hasOwnProperty;
}

function updateAttribute(elm, memberName, newValue, isBoolean, forceRemove) {
    const isXlinkNs = (memberName !== (memberName = memberName.replace(/^xlink\:?/, '')));
    const isBooleanAttr = BOOLEAN_ATTRS[memberName] || isBoolean;
    if ((isBooleanAttr && (!newValue || newValue === 'false')) || forceRemove) {
        if (isXlinkNs) {
            elm.removeAttributeNS(XLINK_NS$1, toLowerCase(memberName));
        }
        else {
            elm.removeAttribute(memberName);
        }
    }
    else if (typeof newValue !== 'function') {
        if (isBooleanAttr) {
            newValue = '';
        }
        if (isXlinkNs) {
            elm.setAttributeNS(XLINK_NS$1, toLowerCase(memberName), newValue);
        }
        else {
            elm.setAttribute(memberName, newValue);
        }
    }
}
const BOOLEAN_ATTRS = {
    'allowfullscreen': 1,
    'async': 1,
    'autofocus': 1,
    'autoplay': 1,
    'checked': 1,
    'controls': 1,
    'disabled': 1,
    'enabled': 1,
    'formnovalidate': 1,
    'hidden': 1,
    'multiple': 1,
    'noresize': 1,
    'readonly': 1,
    'required': 1,
    'selected': 1,
    'spellcheck': 1,
};
const XLINK_NS$1 = 'http://www.w3.org/1999/xlink';

function setAccessor(plt, elm, memberName, oldValue, newValue, isSvg, isHostElement, i, ilen, cmpMeta) {
    if (memberName === 'class' && !isSvg) {
        // Class
        if (oldValue !== newValue) {
            const oldList = (oldValue == null || oldValue === '') ? EMPTY_ARR : oldValue.trim().split(/\s+/);
            const newList = (newValue == null || newValue === '') ? EMPTY_ARR : newValue.trim().split(/\s+/);
            let classList = (elm.className == null || elm.className === '') ? EMPTY_ARR : elm.className.trim().split(/\s+/);
            for (i = 0, ilen = oldList.length; i < ilen; i++) {
                if (newList.indexOf(oldList[i]) === -1) {
                    classList = classList.filter((c) => c !== oldList[i]);
                }
            }
            for (i = 0, ilen = newList.length; i < ilen; i++) {
                if (oldList.indexOf(newList[i]) === -1) {
                    classList = [...classList, newList[i]];
                }
            }
            elm.className = classList.join(' ');
        }
    }
    else if (memberName === 'style') {
        // Style
        oldValue = oldValue || EMPTY_OBJ;
        newValue = newValue || EMPTY_OBJ;
        for (i in oldValue) {
            if (!newValue[i]) {
                elm.style[i] = '';
            }
        }
        for (i in newValue) {
            if (newValue[i] !== oldValue[i]) {
                elm.style[i] = newValue[i];
            }
        }
    }
    else if ((memberName[0] === 'o' && memberName[1] === 'n' && /[A-Z]/.test(memberName[2])) && (!(memberName in elm))) {
        // Event Handlers
        // so if the member name starts with "on" and the 3rd characters is
        // a capital letter, and it's not already a member on the element,
        // then we're assuming it's an event listener
        if (toLowerCase(memberName) in elm) {
            // standard event
            // the JSX attribute could have been "onMouseOver" and the
            // member name "onmouseover" is on the element's prototype
            // so let's add the listener "mouseover", which is all lowercased
            memberName = toLowerCase(memberName.substring(2));
        }
        else {
            // custom event
            // the JSX attribute could have been "onMyCustomEvent"
            // so let's trim off the "on" prefix and lowercase the first character
            // and add the listener "myCustomEvent"
            // except for the first character, we keep the event name case
            memberName = toLowerCase(memberName[2]) + memberName.substring(3);
        }
        if (newValue) {
            if (newValue !== oldValue) {
                // add listener
                plt.domApi.$addEventListener(elm, memberName, newValue);
            }
        }
        else {
            // remove listener
            plt.domApi.$removeEventListener(elm, memberName);
        }
    }
    else if (memberName !== 'list' && memberName !== 'type' && !isSvg &&
        (memberName in elm || (['object', 'function'].indexOf(typeof newValue) !== -1) && newValue !== null)
        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {
        // Properties
        // - list and type are attributes that get applied as values on the element
        // - all svgs get values as attributes not props
        // - check if elm contains name or if the value is array, object, or function
        cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {
            // we know for a fact that this element is a known component
            // and this component has this member name as a property,
            // let's set the known @Prop on this element
            // set it directly as property on the element
            setProperty(elm, memberName, newValue);
            if (Build.reflectToAttr && isHostElement && cmpMeta.membersMeta[memberName].reflectToAttrib) {
                // we also want to set this data to the attribute
                updateAttribute(elm, cmpMeta.membersMeta[memberName].attribName, newValue, cmpMeta.membersMeta[memberName].propType === 3 /* Boolean */, (newValue == null));
            }
        }
        else if (memberName !== 'ref') {
            // this member name is a property on this element, but it's not a component
            // this is a native property like "value" or something
            // also we can ignore the "ref" member name at this point
            setProperty(elm, memberName, newValue == null ? '' : newValue);
            if (newValue == null || newValue === false) {
                elm.removeAttribute(memberName);
            }
        }
    }
    else if (newValue != null) {
        // Element Attributes
        updateAttribute(elm, memberName, newValue);
    }
    else if (isSvg && (newValue == null || newValue === false)) {
        // remove svg attribute
        plt.domApi.$removeAttribute(elm, memberName);
    }
}
/**
 * Attempt to set a DOM property to the given value.
 * IE & FF throw for certain property-value combinations.
 */
function setProperty(elm, name, value) {
    try {
        elm[name] = value;
    }
    catch (e) { }
}

function updateElement(plt, oldVnode, newVnode, isSvgMode, memberName) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = (newVnode.elm.nodeType === 11 /* DocumentFragment */ && newVnode.elm.host) ? newVnode.elm.host : newVnode.elm;
    const oldVnodeAttrs = (oldVnode && oldVnode.vattrs) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.vattrs || EMPTY_OBJ;
    // remove attributes no longer present on the vnode by setting them to undefined
    for (memberName in oldVnodeAttrs) {
        if (!(newVnodeAttrs && newVnodeAttrs[memberName] != null) && oldVnodeAttrs[memberName] != null) {
            setAccessor(plt, elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.ishost);
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        if (!(memberName in oldVnodeAttrs) || newVnodeAttrs[memberName] !== (memberName === 'value' || memberName === 'checked' ? elm[memberName] : oldVnodeAttrs[memberName])) {
            setAccessor(plt, elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.ishost);
        }
    }
}

let isSvgMode = false;
function createRendererPatch(plt, domApi) {
    // createRenderer() is only created once per app
    // the patch() function which createRenderer() returned is the function
    // which gets called numerous times by each component
    function createElm(oldParentVNode, newParentVNode, childIndex, parentElm, i, elm, childNode, newVNode, oldVNode) {
        newVNode = newParentVNode.vchildren[childIndex];
        if (Build.slotPolyfill && !useNativeShadowDom) {
            // remember for later we need to check to relocate nodes
            checkSlotRelocate = true;
            if (newVNode.vtag === 'slot') {
                if (scopeId) {
                    // scoped css needs to add its scoped id to the parent element
                    domApi.$setAttribute(parentElm, scopeId + '-slot', '');
                }
                if (!newVNode.vchildren) {
                    // slot element does not have fallback content
                    // create an html comment we'll use to always reference
                    // where actual slot content should sit next to
                    newVNode.isSlotReference = true;
                }
                else {
                    // slot element has fallback content
                    // still create an element that "mocks" the slot element
                    newVNode.isSlotFallback = true;
                }
            }
        }
        if (isDef(newVNode.vtext)) {
            // create text node
            newVNode.elm = domApi.$createTextNode(newVNode.vtext);
        }
        else if (Build.slotPolyfill && newVNode.isSlotReference) {
            // create a slot reference html text node
            newVNode.elm = domApi.$createTextNode('');
        }
        else {
            // create element
            elm = newVNode.elm = ((Build.hasSvg && (isSvgMode || newVNode.vtag === 'svg')) ?
                domApi.$createElementNS('http://www.w3.org/2000/svg', newVNode.vtag) :
                domApi.$createElement((Build.slotPolyfill && newVNode.isSlotFallback) ? 'slot-fb' : newVNode.vtag));
            if (Build.hasSvg) {
                isSvgMode = newVNode.vtag === 'svg' ? true : (newVNode.vtag === 'foreignObject' ? false : isSvgMode);
            }
            // add css classes, attrs, props, listeners, etc.
            updateElement(plt, null, newVNode, isSvgMode);
            if (isDef(scopeId) && elm['s-si'] !== scopeId) {
                // if there is a scopeId and this is the initial render
                // then let's add the scopeId as an attribute
                domApi.$setAttribute(elm, (elm['s-si'] = scopeId), '');
            }
            if (Build.ssrServerSide && isDef(ssrId)) {
                // SSR ONLY: this is an SSR render and this
                // logic does not run on the client
                // give this element the SSR child id that can be read by the client
                domApi.$setAttribute(elm, SSR_CHILD_ID, ssrId + '.' + childIndex + (hasChildNodes(newVNode.vchildren) ? '' : '.'));
            }
            if (newVNode.vchildren) {
                for (i = 0; i < newVNode.vchildren.length; ++i) {
                    // create the node
                    childNode = createElm(oldParentVNode, newVNode, i, elm);
                    // return node could have been null
                    if (childNode) {
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3 /* TextNode */ && !childNode['s-cr']) {
                            // SSR ONLY: add the text node's start comment
                            domApi.$appendChild(elm, domApi.$createComment('s.' + ssrId + '.' + i));
                        }
                        // append our new node
                        domApi.$appendChild(elm, childNode);
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3 /* TextNode */ && !childNode['s-cr']) {
                            // SSR ONLY: add the text node's end comment
                            domApi.$appendChild(elm, domApi.$createComment('/'));
                            domApi.$appendChild(elm, domApi.$createTextNode(' '));
                        }
                    }
                }
            }
            if (Build.hasSvg && newVNode.vtag === 'svg') {
                // Only reset the SVG context when we're exiting SVG element
                isSvgMode = false;
            }
        }
        if (Build.slotPolyfill) {
            newVNode.elm['s-hn'] = hostTagName;
            if (newVNode.isSlotFallback || newVNode.isSlotReference) {
                // remember the content reference comment
                newVNode.elm['s-sr'] = true;
                // remember the content reference comment
                newVNode.elm['s-cr'] = contentRef;
                // remember the slot name, or empty string for default slot
                newVNode.elm['s-sn'] = newVNode.vname || '';
                // check if we've got an old vnode for this slot
                oldVNode = oldParentVNode && oldParentVNode.vchildren && oldParentVNode.vchildren[childIndex];
                if (oldVNode && oldVNode.vtag === newVNode.vtag && oldParentVNode.elm) {
                    // we've got an old slot vnode and the wrapper is being replaced
                    // so let's move the old slot content back to it's original location
                    putBackInOriginalLocation(oldParentVNode.elm);
                }
            }
        }
        return newVNode.elm;
    }
    function putBackInOriginalLocation(parentElm, recursive, i, childNode) {
        plt.tmpDisconnected = true;
        const oldSlotChildNodes = domApi.$childNodes(parentElm);
        for (i = oldSlotChildNodes.length - 1; i >= 0; i--) {
            childNode = oldSlotChildNodes[i];
            if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
                // this child node in the old element is from another component
                // remove this node from the old slot's parent
                domApi.$remove(childNode);
                // and relocate it back to it's original location
                domApi.$insertBefore(parentReferenceNode(childNode), childNode, referenceNode(childNode));
                // remove the old original location comment entirely
                // later on the patch function will know what to do
                // and move this to the correct spot in need be
                domApi.$remove(childNode['s-ol']);
                childNode['s-ol'] = null;
                checkSlotRelocate = true;
            }
            if (recursive) {
                putBackInOriginalLocation(childNode, recursive);
            }
        }
        plt.tmpDisconnected = false;
    }
    function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx, containerElm, childNode) {
        // $defaultHolder deprecated 2018-04-02
        const contentRef = parentElm['s-cr'] || parentElm['$defaultHolder'];
        containerElm = ((contentRef && domApi.$parentNode(contentRef)) || parentElm);
        if (containerElm.shadowRoot) {
            containerElm = containerElm.shadowRoot;
        }
        for (; startIdx <= endIdx; ++startIdx) {
            if (vnodes[startIdx]) {
                childNode = isDef(vnodes[startIdx].vtext) ?
                    domApi.$createTextNode(vnodes[startIdx].vtext) :
                    createElm(null, parentVNode, startIdx, parentElm);
                if (childNode) {
                    vnodes[startIdx].elm = childNode;
                    domApi.$insertBefore(containerElm, childNode, referenceNode(before));
                }
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx, node) {
        for (; startIdx <= endIdx; ++startIdx) {
            if (isDef(vnodes[startIdx])) {
                node = vnodes[startIdx].elm;
                if (Build.slotPolyfill) {
                    // we're removing this element
                    // so it's possible we need to show slot fallback content now
                    checkSlotFallbackVisibility = true;
                    if (node['s-ol']) {
                        // remove the original location comment
                        domApi.$remove(node['s-ol']);
                    }
                    else {
                        // it's possible that child nodes of the node
                        // that's being removed are slot nodes
                        putBackInOriginalLocation(node, true);
                    }
                }
                // remove the vnode's element from the dom
                domApi.$remove(node);
            }
        }
    }
    function updateChildren(parentElm, oldCh, newVNode, newCh, idxInOld, i, node, elmToMove) {
        let oldStartIdx = 0, newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                // Vnode might have been moved left
                oldStartVnode = oldCh[++oldStartIdx];
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newStartVnode)) {
                patchVNode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (isSameVnode(oldEndVnode, newEndVnode)) {
                patchVNode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                if (oldStartVnode.vtag === 'slot' || newEndVnode.vtag === 'slot') {
                    putBackInOriginalLocation(domApi.$parentNode(oldStartVnode.elm));
                }
                patchVNode(oldStartVnode, newEndVnode);
                domApi.$insertBefore(parentElm, oldStartVnode.elm, domApi.$nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                if (oldStartVnode.vtag === 'slot' || newEndVnode.vtag === 'slot') {
                    putBackInOriginalLocation(domApi.$parentNode(oldEndVnode.elm));
                }
                patchVNode(oldEndVnode, newStartVnode);
                domApi.$insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // createKeyToOldIdx
                idxInOld = null;
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && isDef(oldCh[i].vkey) && oldCh[i].vkey === newStartVnode.vkey) {
                        idxInOld = i;
                        break;
                    }
                }
                if (isDef(idxInOld)) {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.vtag !== newStartVnode.vtag) {
                        node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
                    }
                    else {
                        patchVNode(elmToMove, newStartVnode);
                        oldCh[idxInOld] = undefined;
                        node = elmToMove.elm;
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    // new element
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
                    newStartVnode = newCh[++newStartIdx];
                }
                if (node) {
                    domApi.$insertBefore(parentReferenceNode(oldStartVnode.elm), node, referenceNode(oldStartVnode.elm));
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            addVnodes(parentElm, (newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm), newVNode, newCh, newStartIdx, newEndIdx);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function isSameVnode(vnode1, vnode2) {
        // compare if two vnode to see if they're "technically" the same
        // need to have the same element tag, and same key to be the same
        if (vnode1.vtag === vnode2.vtag && vnode1.vkey === vnode2.vkey) {
            if (Build.slotPolyfill) {
                if (vnode1.vtag === 'slot') {
                    return vnode1.vname === vnode2.vname;
                }
            }
            return true;
        }
        return false;
    }
    function referenceNode(node) {
        if (Build.slotPolyfill) {
            if (node && node['s-ol']) {
                // this node was relocated to a new location in the dom
                // because of some other component's slot
                // but we still have an html comment in place of where
                // it's original location was according to it's original vdom
                return node['s-ol'];
            }
        }
        return node;
    }
    function parentReferenceNode(node) {
        return domApi.$parentNode(node['s-ol'] ? node['s-ol'] : node);
    }
    function patchVNode(oldVNode, newVNode, defaultHolder) {
        const elm = newVNode.elm = oldVNode.elm;
        const oldChildren = oldVNode.vchildren;
        const newChildren = newVNode.vchildren;
        if (Build.hasSvg) {
            // test if we're rendering an svg element, or still rendering nodes inside of one
            // only add this to the when the compiler sees we're using an svg somewhere
            isSvgMode = newVNode.elm &&
                isDef(domApi.$parentElement(newVNode.elm)) &&
                newVNode.elm.ownerSVGElement !== undefined;
            isSvgMode = newVNode.vtag === 'svg' ? true : (newVNode.vtag === 'foreignObject' ? false : isSvgMode);
        }
        if (!isDef(newVNode.vtext)) {
            // element node
            if (newVNode.vtag !== 'slot') {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(plt, oldVNode, newVNode, isSvgMode);
            }
            if (isDef(oldChildren) && isDef(newChildren)) {
                // looks like there's child vnodes for both the old and new vnodes
                updateChildren(elm, oldChildren, newVNode, newChildren);
            }
            else if (isDef(newChildren)) {
                // no old child vnodes, but there are new child vnodes to add
                if (isDef(oldVNode.vtext)) {
                    // the old vnode was text, so be sure to clear it out
                    domApi.$setTextContent(elm, '');
                }
                // add the new vnode children
                addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
            }
            else if (isDef(oldChildren)) {
                // no new child vnodes, but there are old child vnodes to remove
                removeVnodes(oldChildren, 0, oldChildren.length - 1);
            }
        }
        else if (Build.slotPolyfill && (defaultHolder = (elm['s-cr'] || elm['$defaultHolder'] /* $defaultHolder deprecated 2018-04-02 */))) {
            // this element has slotted content
            domApi.$setTextContent(domApi.$parentNode(defaultHolder), newVNode.vtext);
        }
        else if (oldVNode.vtext !== newVNode.vtext) {
            // update the text content for the text only vnode
            // and also only if the text is different than before
            domApi.$setTextContent(elm, newVNode.vtext);
        }
        if (Build.hasSvg) {
            // reset svgMode when svg node is fully patched
            if (isSvgMode && 'svg' === newVNode.vtag) {
                isSvgMode = false;
            }
        }
    }
    function updateFallbackSlotVisibility(elm, childNode, childNodes, i, ilen, j, slotNameAttr, nodeType) {
        childNodes = domApi.$childNodes(elm);
        for (i = 0, ilen = childNodes.length; i < ilen; i++) {
            childNode = childNodes[i];
            if (domApi.$nodeType(childNode) === 1 /* ElementNode */) {
                if (childNode['s-sr']) {
                    // this is a slot fallback node
                    // get the slot name for this slot reference node
                    slotNameAttr = childNode['s-sn'];
                    // by default always show a fallback slot node
                    // then hide it if there are other slots in the light dom
                    childNode.hidden = false;
                    for (j = 0; j < ilen; j++) {
                        if (childNodes[j]['s-hn'] !== childNode['s-hn']) {
                            // this sibling node is from a different component
                            nodeType = domApi.$nodeType(childNodes[j]);
                            if (slotNameAttr !== '') {
                                // this is a named fallback slot node
                                if (nodeType === 1 /* ElementNode */ && slotNameAttr === domApi.$getAttribute(childNodes[j], 'slot')) {
                                    childNode.hidden = true;
                                    break;
                                }
                            }
                            else {
                                // this is a default fallback slot node
                                // any element or text node (with content)
                                // should hide the default fallback slot node
                                if (nodeType === 1 /* ElementNode */ || (nodeType === 3 /* TextNode */ && domApi.$getTextContent(childNodes[j]).trim() !== '')) {
                                    childNode.hidden = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                // keep drilling down
                updateFallbackSlotVisibility(childNode);
            }
        }
    }
    const relocateNodes = [];
    function relocateSlotContent(elm, childNodes, childNode, node, i, ilen, j, hostContentNodes, slotNameAttr, nodeType) {
        childNodes = domApi.$childNodes(elm);
        for (i = 0, ilen = childNodes.length; i < ilen; i++) {
            childNode = childNodes[i];
            if (childNode['s-sr'] && (node = childNode['s-cr'])) {
                // first got the content reference comment node
                // then we got it's parent, which is where all the host content is in now
                hostContentNodes = domApi.$childNodes(domApi.$parentNode(node));
                slotNameAttr = childNode['s-sn'];
                for (j = hostContentNodes.length - 1; j >= 0; j--) {
                    node = hostContentNodes[j];
                    if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
                        // let's do some relocating to its new home
                        // but never relocate a content reference node
                        // that is suppose to always represent the original content location
                        nodeType = domApi.$nodeType(node);
                        if (((nodeType === 3 /* TextNode */ || nodeType === 8 /* CommentNode */) && slotNameAttr === '') ||
                            (nodeType === 1 /* ElementNode */ && domApi.$getAttribute(node, 'slot') === null && slotNameAttr === '') ||
                            (nodeType === 1 /* ElementNode */ && domApi.$getAttribute(node, 'slot') === slotNameAttr)) {
                            // it's possible we've already decided to relocate this node
                            if (!relocateNodes.some(r => r.nodeToRelocate === node)) {
                                // made some changes to slots
                                // let's make sure we also double check
                                // fallbacks are correctly hidden or shown
                                checkSlotFallbackVisibility = true;
                                node['s-sn'] = slotNameAttr;
                                // add to our list of nodes to relocate
                                relocateNodes.push({
                                    slotRefNode: childNode,
                                    nodeToRelocate: node
                                });
                            }
                        }
                    }
                }
            }
            if (domApi.$nodeType(childNode) === 1 /* ElementNode */) {
                relocateSlotContent(childNode);
            }
        }
    }
    // internal variables to be reused per patch() call
    let useNativeShadowDom, ssrId, scopeId, isUpdate, checkSlotFallbackVisibility, checkSlotRelocate, hostTagName, contentRef;
    return function patch(oldVNode, newVNode, isUpdatePatch, encapsulation, ssrPatchId, i, relocateNode, orgLocationNode, refNode) {
        // patchVNode() is synchronous
        // so it is safe to set these variables and internally
        // the same patch() call will reference the same data
        isUpdate = isUpdatePatch;
        hostTagName = domApi.$tagName(oldVNode.elm);
        contentRef = oldVNode.elm['s-cr'];
        if (Build.ssrServerSide) {
            if (encapsulation !== 'shadow') {
                ssrId = ssrPatchId;
            }
            else {
                ssrId = null;
            }
        }
        if (Build.slotPolyfill) {
            // get the scopeId
            scopeId = (encapsulation === 'scoped' || (encapsulation === 'shadow' && !domApi.$supportsShadowDom)) ? 'data-' + domApi.$tagName(oldVNode.elm) : null;
            // always reset
            checkSlotRelocate = checkSlotFallbackVisibility = false;
        }
        if (Build.shadowDom) {
            // use native shadow dom only if the component wants to use it
            // and if this browser supports native shadow dom
            useNativeShadowDom = (encapsulation === 'shadow' && domApi.$supportsShadowDom);
        }
        if (!isUpdate) {
            if (Build.shadowDom && useNativeShadowDom) {
                // this component SHOULD use native slot/shadow dom
                // this browser DOES support native shadow dom
                // and this is the first render
                // let's create that shadow root
                oldVNode.elm = domApi.$attachShadow(oldVNode.elm, { mode: 'open' });
            }
            else if (Build.slotPolyfill && scopeId) {
                // this host element should use scoped css
                // add the scope attribute to the host
                domApi.$setAttribute(oldVNode.elm, scopeId + '-host', '');
            }
        }
        // synchronous patch
        patchVNode(oldVNode, newVNode);
        if (Build.ssrServerSide && isDef(ssrId)) {
            // SSR ONLY: we've been given an SSR id, so the host element
            // should be given the ssr id attribute
            domApi.$setAttribute(oldVNode.elm, SSR_VNODE_ID, ssrId);
        }
        if (Build.slotPolyfill) {
            if (checkSlotRelocate) {
                relocateSlotContent(newVNode.elm);
                for (i = 0; i < relocateNodes.length; i++) {
                    relocateNode = relocateNodes[i];
                    if (!relocateNode.nodeToRelocate['s-ol']) {
                        // add a reference node marking this node's original location
                        // keep a reference to this node for later lookups
                        orgLocationNode = domApi.$createTextNode('');
                        orgLocationNode['s-nr'] = relocateNode.nodeToRelocate;
                        domApi.$insertBefore(domApi.$parentNode(relocateNode.nodeToRelocate), (relocateNode.nodeToRelocate['s-ol'] = orgLocationNode), relocateNode.nodeToRelocate);
                    }
                }
                // while we're moving nodes around existing nodes, temporarily disable
                // the disconnectCallback from working
                plt.tmpDisconnected = true;
                for (i = 0; i < relocateNodes.length; i++) {
                    relocateNode = relocateNodes[i];
                    // by default we're just going to insert it directly
                    // after the slot reference node
                    const parentNodeRef = domApi.$parentNode(relocateNode.slotRefNode);
                    let insertBeforeNode = domApi.$nextSibling(relocateNode.slotRefNode);
                    orgLocationNode = relocateNode.nodeToRelocate['s-ol'];
                    while (orgLocationNode = domApi.$previousSibling(orgLocationNode)) {
                        refNode = orgLocationNode['s-nr'];
                        if (refNode && refNode['s-sn'] === relocateNode.nodeToRelocate['s-sn']) {
                            if (parentNodeRef === domApi.$parentNode(refNode)) {
                                insertBeforeNode = domApi.$nextSibling(refNode);
                                break;
                            }
                        }
                    }
                    if ((!insertBeforeNode && parentNodeRef !== domApi.$parentNode(relocateNode.nodeToRelocate)) ||
                        (domApi.$nextSibling(relocateNode.nodeToRelocate) !== insertBeforeNode)) {
                        // we've checked that it's worth while to relocate
                        // since that the node to relocate
                        // has a different next sibling or parent relocated
                        if (relocateNode.nodeToRelocate !== insertBeforeNode) {
                            // remove the node from the dom
                            domApi.$remove(relocateNode.nodeToRelocate);
                            // add it back to the dom but in its new home
                            domApi.$insertBefore(parentNodeRef, relocateNode.nodeToRelocate, insertBeforeNode);
                        }
                    }
                }
                // done moving nodes around
                // allow the disconnect callback to work again
                plt.tmpDisconnected = false;
            }
            if (checkSlotFallbackVisibility) {
                updateFallbackSlotVisibility(newVNode.elm);
            }
            // always reset
            relocateNodes.length = 0;
        }
        // return our new vnode
        return newVNode;
    };
}
function callNodeRefs(vNode, isDestroy) {
    if (vNode) {
        vNode.vattrs && vNode.vattrs.ref && vNode.vattrs.ref(isDestroy ? null : vNode.elm);
        vNode.vchildren && vNode.vchildren.forEach(vChild => {
            callNodeRefs(vChild, isDestroy);
        });
    }
}
function hasChildNodes(children) {
    // SSR ONLY: check if there are any more nested child elements
    // if there aren't, this info is useful so the client runtime
    // doesn't have to climb down and check so many elements
    if (children) {
        for (var i = 0; i < children.length; i++) {
            if (children[i].vtag !== 'slot' || hasChildNodes(children[i].vchildren)) {
                return true;
            }
        }
    }
    return false;
}

function disconnectedCallback(plt, elm, instance) {
    // only disconnect if we're not temporarily disconnected
    // tmpDisconnected will happen when slot nodes are being relocated
    if (!plt.tmpDisconnected && isDisconnected(plt.domApi, elm)) {
        // ok, let's officially destroy this thing
        // set this to true so that any of our pending async stuff
        // doesn't continue since we already decided to destroy this node
        // elm._hasDestroyed = true;
        plt.isDisconnectedMap.set(elm, true);
        // double check that we've informed the ancestor host elements
        // that they're good to go and loaded (cuz this one is on its way out)
        propagateComponentLoaded(plt, elm);
        // since we're disconnecting, call all of the JSX ref's with null
        callNodeRefs(plt.vnodeMap.get(elm), true);
        // detatch any event listeners that may have been added
        // because we're not passing an exact event name it'll
        // remove all of this element's event, which is good
        plt.domApi.$removeEventListener(elm);
        plt.hasListenersMap.delete(elm);
        if (Build.cmpDidUnload) {
            // call instance componentDidUnload
            // if we've created an instance for this
            instance = plt.instanceMap.get(elm);
            if (instance) {
                // call the user's componentDidUnload if there is one
                instance.componentDidUnload && instance.componentDidUnload();
            }
        }
        // clear any references to other elements
        // more than likely we've already deleted these references
        // but let's double check there pal
        [
            plt.ancestorHostElementMap,
            plt.onReadyCallbacksMap,
            plt.hostSnapshotMap
        ].forEach(wm => wm.delete(elm));
    }
}
function isDisconnected(domApi, elm) {
    while (elm) {
        if (!domApi.$parentNode(elm)) {
            return domApi.$nodeType(elm) !== 9 /* DocumentNode */;
        }
        elm = domApi.$parentNode(elm);
    }
}

function proxyHostElementPrototype(plt, membersMeta, hostPrototype) {
    // create getters/setters on the host element prototype to represent the public API
    // the setters allows us to know when data has changed so we can re-render
    if (!Build.clientSide) {
        // in just a server-side build
        // let's set the properties to the values immediately
        let values = plt.valuesMap.get(hostPrototype);
        if (!values) {
            values = {};
            plt.valuesMap.set(hostPrototype, values);
        }
        membersMeta && Object.keys(membersMeta).forEach(memberName => {
            const memberType = membersMeta[memberName].memberType;
            if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
                values[memberName] = hostPrototype[memberName];
            }
        });
    }
    membersMeta && Object.keys(membersMeta).forEach(memberName => {
        // add getters/setters
        const member = membersMeta[memberName];
        const memberType = member.memberType;
        if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
            // @Prop() or @Prop({ mutable: true })
            definePropertyGetterSetter(hostPrototype, memberName, function getHostElementProp() {
                // host element getter (cannot be arrow fn)
                // yup, ugly, srynotsry
                return (plt.valuesMap.get(this) || {})[memberName];
            }, function setHostElementProp(newValue) {
                // host element setter (cannot be arrow fn)
                setValue(plt, this, memberName, parsePropertyValue(member.propType, newValue));
            });
        }
        else if (memberType === 6 /* Method */) {
            // @Method()
            // add a placeholder noop value on the host element's prototype
            // incase this method gets called before setup
            definePropertyValue(hostPrototype, memberName, noop);
        }
    });
}

function initHostElement(plt, cmpMeta, HostElementConstructor, hydratedCssClass) {
    // let's wire up our functions to the host element's prototype
    // we can also inject our platform into each one that needs that api
    // note: these cannot be arrow functions cuz "this" is important here hombre
    HostElementConstructor.connectedCallback = function () {
        // coolsville, our host element has just hit the DOM
        connectedCallback(plt, cmpMeta, this);
    };
    if (Build.observeAttr) {
        HostElementConstructor.attributeChangedCallback = function (attribName, oldVal, newVal) {
            // the browser has just informed us that an attribute
            // on the host element has changed
            attributeChangedCallback(cmpMeta.membersMeta, this, attribName, oldVal, newVal);
        };
    }
    HostElementConstructor.disconnectedCallback = function () {
        // the element has left the builing
        disconnectedCallback(plt, this);
    };
    HostElementConstructor['s-init'] = function () {
        initComponentLoaded(plt, this, hydratedCssClass);
    };
    HostElementConstructor.forceUpdate = function () {
        queueUpdate(plt, this);
    };
    // add getters/setters to the host element members
    // these would come from the @Prop and @Method decorators that
    // should create the public API to this component
    proxyHostElementPrototype(plt, cmpMeta.membersMeta, HostElementConstructor);
}

function connectChildElements(config, plt, App, hydrateResults, parentElm) {
    if (parentElm && parentElm.children) {
        for (let i = 0; i < parentElm.children.length; i++) {
            connectElement(config, plt, App, hydrateResults, parentElm.children[i]);
            connectChildElements(config, plt, App, hydrateResults, parentElm.children[i]);
        }
    }
}
function connectElement(config, plt, App, hydrateResults, elm) {
    if (!plt.hasConnectedMap.has(elm)) {
        const tagName = elm.tagName.toLowerCase();
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta) {
            connectHostElement(config, plt, App, hydrateResults, elm, cmpMeta);
        }
        else if (tagName === 'script') {
            connectScriptElement(hydrateResults, elm);
        }
        else if (tagName === 'link') {
            connectLinkElement(hydrateResults, elm);
        }
        else if (tagName === 'img') {
            connectImgElement(hydrateResults, elm);
        }
        plt.hasConnectedMap.set(elm, true);
    }
}
function connectHostElement(config, plt, App, hydrateResults, elm, cmpMeta) {
    if (!cmpMeta.componentConstructor) {
        const hostSnapshot = initHostSnapshot(plt.domApi, cmpMeta, elm);
        plt.requestBundle(cmpMeta, elm, hostSnapshot);
    }
    if (cmpMeta.encapsulation !== 1 /* ShadowDom */) {
        initHostElement(plt, cmpMeta, elm, config.hydratedCssClass);
        connectedCallback(plt, cmpMeta, elm);
    }
    connectComponentOnReady(App, elm);
    const depth = getNodeDepth(elm);
    const cmp = hydrateResults.components.find(c => c.tag === cmpMeta.tagNameMeta);
    if (cmp) {
        cmp.count++;
        if (depth > cmp.depth) {
            cmp.depth = depth;
        }
    }
    else {
        hydrateResults.components.push({
            tag: cmpMeta.tagNameMeta,
            count: 1,
            depth: depth
        });
    }
}
function connectComponentOnReady(App, elm) {
    elm.componentOnReady = function componentOnReady(cb) {
        const elm = this;
        if (cb) {
            App.componentOnReady(elm, cb);
        }
        else {
            return new Promise(resolve => {
                App.componentOnReady(elm, resolve);
            });
        }
    };
}
function connectScriptElement(hydrateResults, elm) {
    const src = elm.src;
    if (src && hydrateResults.scriptUrls.indexOf(src) === -1) {
        hydrateResults.scriptUrls.push(src);
    }
}
function connectLinkElement(hydrateResults, elm) {
    const href = elm.href;
    const rel = (elm.rel || '').toLowerCase();
    if (rel === 'stylesheet' && href && hydrateResults.styleUrls.indexOf(href) === -1) {
        hydrateResults.styleUrls.push(href);
    }
}
function connectImgElement(hydrateResults, elm) {
    const src = elm.src;
    if (src && hydrateResults.imgUrls.indexOf(src) === -1) {
        hydrateResults.imgUrls.push(src);
    }
}
function getNodeDepth(elm) {
    let depth = 0;
    while (elm.parentNode) {
        depth++;
        elm = elm.parentNode;
    }
    return depth;
}

function createDomApi(App, win, doc) {
    // using the $ prefix so that closure is
    // cool with property renaming each of these
    if (!App.ael) {
        App.ael = (elm, eventName, cb, opts) => elm.addEventListener(eventName, cb, opts);
        App.rel = (elm, eventName, cb, opts) => elm.removeEventListener(eventName, cb, opts);
    }
    const unregisterListenerFns = new WeakMap();
    const domApi = {
        $documentElement: doc.documentElement,
        $head: doc.head,
        $body: doc.body,
        $supportsEventOptions: false,
        $nodeType: (node) => node.nodeType,
        $createElement: (tagName) => doc.createElement(tagName),
        $createElementNS: (namespace, tagName) => doc.createElementNS(namespace, tagName),
        $createTextNode: (text) => doc.createTextNode(text),
        $createComment: (data) => doc.createComment(data),
        $insertBefore: (parentNode, childNode, referenceNode) => parentNode.insertBefore(childNode, referenceNode),
        // https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
        // and it's polyfilled in es5 builds
        $remove: (node) => node.remove(),
        $appendChild: (parentNode, childNode) => parentNode.appendChild(childNode),
        $childNodes: (node) => node.childNodes,
        $parentNode: (node) => node.parentNode,
        $nextSibling: (node) => node.nextSibling,
        $previousSibling: (node) => node.previousSibling,
        $tagName: (elm) => toLowerCase(elm.nodeName),
        $getTextContent: (node) => node.textContent,
        $setTextContent: (node, text) => node.textContent = text,
        $getAttribute: (elm, key) => elm.getAttribute(key),
        $setAttribute: (elm, key, val) => elm.setAttribute(key, val),
        $setAttributeNS: (elm, namespaceURI, qualifiedName, val) => elm.setAttributeNS(namespaceURI, qualifiedName, val),
        $removeAttribute: (elm, key) => elm.removeAttribute(key),
        $elementRef: (elm, referenceName) => {
            if (referenceName === 'child') {
                return elm.firstElementChild;
            }
            if (referenceName === 'parent') {
                return domApi.$parentElement(elm);
            }
            if (referenceName === 'body') {
                return domApi.$body;
            }
            if (referenceName === 'document') {
                return doc;
            }
            if (referenceName === 'window') {
                return win;
            }
            return elm;
        },
        $addEventListener: (assignerElm, eventName, listenerCallback, useCapture, usePassive, attachTo, eventListenerOpts, splt) => {
            // remember the original name before we possibly change it
            const assignersEventName = eventName;
            let attachToElm = assignerElm;
            // get the existing unregister listeners for
            // this element from the unregister listeners weakmap
            let assignersUnregListeners = unregisterListenerFns.get(assignerElm);
            if (assignersUnregListeners && assignersUnregListeners[assignersEventName]) {
                // removed any existing listeners for this event for the assigner element
                // this element already has this listener, so let's unregister it now
                assignersUnregListeners[assignersEventName]();
            }
            if (typeof attachTo === 'string') {
                // attachTo is a string, and is probably something like
                // "parent", "window", or "document"
                // and the eventName would be like "mouseover" or "mousemove"
                attachToElm = domApi.$elementRef(assignerElm, attachTo);
            }
            else if (typeof attachTo === 'object') {
                // we were passed in an actual element to attach to
                attachToElm = attachTo;
            }
            else {
                // depending on the event name, we could actually be attaching
                // this element to something like the document or window
                splt = eventName.split(':');
                if (splt.length > 1) {
                    // document:mousemove
                    // parent:touchend
                    // body:keyup.enter
                    attachToElm = domApi.$elementRef(assignerElm, splt[0]);
                    eventName = splt[1];
                }
            }
            if (!attachToElm) {
                // somehow we're referencing an element that doesn't exist
                // let's not continue
                return;
            }
            let eventListener = listenerCallback;
            // test to see if we're looking for an exact keycode
            splt = eventName.split('.');
            if (splt.length > 1) {
                // looks like this listener is also looking for a keycode
                // keyup.enter
                eventName = splt[0];
                eventListener = (ev) => {
                    // wrap the user's event listener with our own check to test
                    // if this keyboard event has the keycode they're looking for
                    if (ev.keyCode === KEY_CODE_MAP[splt[1]]) {
                        listenerCallback(ev);
                    }
                };
            }
            // create the actual event listener options to use
            // this browser may not support event options
            eventListenerOpts = domApi.$supportsEventOptions ? {
                capture: !!useCapture,
                passive: !!usePassive
            } : !!useCapture;
            // ok, good to go, let's add the actual listener to the dom element
            App.ael(attachToElm, eventName, eventListener, eventListenerOpts);
            if (!assignersUnregListeners) {
                // we don't already have a collection, let's create it
                unregisterListenerFns.set(assignerElm, assignersUnregListeners = {});
            }
            // add the unregister listener to this element's collection
            assignersUnregListeners[assignersEventName] = () => {
                // looks like it's time to say goodbye
                attachToElm && App.rel(attachToElm, eventName, eventListener, eventListenerOpts);
                assignersUnregListeners[assignersEventName] = null;
            };
        },
        $removeEventListener: (elm, eventName) => {
            // get the unregister listener functions for this element
            const assignersUnregListeners = unregisterListenerFns.get(elm);
            if (assignersUnregListeners) {
                // this element has unregister listeners
                if (eventName) {
                    // passed in one specific event name to remove
                    assignersUnregListeners[eventName] && assignersUnregListeners[eventName]();
                }
                else {
                    // remove all event listeners
                    Object.keys(assignersUnregListeners).forEach(assignersEventName => {
                        assignersUnregListeners[assignersEventName] && assignersUnregListeners[assignersEventName]();
                    });
                }
            }
        }
    };
    if (Build.shadowDom) {
        domApi.$attachShadow = (elm, shadowRootInit) => elm.attachShadow(shadowRootInit);
        domApi.$supportsShadowDom = !!domApi.$documentElement.attachShadow;
        if (Build.isDev) {
            if (win.location.search.indexOf('shadow=false') > 0) {
                // by adding ?shadow=false it'll force the slot polyfill
                // only add this check when in dev mode
                domApi.$supportsShadowDom = false;
            }
        }
    }
    if (Build.es5) {
        if (typeof win.CustomEvent !== 'function') {
            // CustomEvent polyfill
            win.CustomEvent = (event, data, evt) => {
                evt = doc.createEvent('CustomEvent');
                evt.initCustomEvent(event, data.bubbles, data.cancelable, data.detail);
                return evt;
            };
            win.CustomEvent.prototype = win.Event.prototype;
        }
    }
    domApi.$dispatchEvent = (elm, eventName, data) => elm && elm.dispatchEvent(new win.CustomEvent(eventName, data));
    if (Build.event || Build.listener) {
        // test if this browser supports event options or not
        try {
            win.addEventListener('e', null, Object.defineProperty({}, 'passive', {
                get: () => domApi.$supportsEventOptions = true
            }));
        }
        catch (e) { }
    }
    domApi.$parentElement = (elm, parentNode) => 
    // if the parent node is a document fragment (shadow root)
    // then use the "host" property on it
    // otherwise use the parent node
    ((parentNode = domApi.$parentNode(elm)) && domApi.$nodeType(parentNode) === 11 /* DocumentFragment */) ? parentNode.host : parentNode;
    return domApi;
}

function createQueueServer() {
    const highPriority = [];
    const domReads = [];
    const domWrites = [];
    let queued = false;
    function flush(cb) {
        while (highPriority.length > 0) {
            highPriority.shift()();
        }
        while (domReads.length > 0) {
            domReads.shift()();
        }
        while (domWrites.length > 0) {
            domWrites.shift()();
        }
        queued = (highPriority.length > 0) || (domReads.length > 0) || (domWrites.length > 0);
        if (queued) {
            process.nextTick(flush);
        }
        cb && cb();
    }
    function clear() {
        highPriority.length = 0;
        domReads.length = 0;
        domWrites.length = 0;
    }
    return {
        tick: (cb) => {
            // queue high priority work to happen in next tick
            // uses Promise.resolve() for next tick
            highPriority.push(cb);
            if (!queued) {
                queued = true;
                process.nextTick(flush);
            }
        },
        read: (cb) => {
            // queue dom reads
            domReads.push(cb);
            if (!queued) {
                queued = true;
                process.nextTick(flush);
            }
        },
        write: (cb) => {
            // queue dom writes
            domWrites.push(cb);
            if (!queued) {
                queued = true;
                process.nextTick(flush);
            }
        },
        flush: flush,
        clear: clear
    };
}

function fillCmpMetaFromConstructor(cmp, cmpMeta) {
    if (!cmpMeta.tagNameMeta) {
        cmpMeta.tagNameMeta = cmp.is;
    }
    if (!cmpMeta.bundleIds) {
        cmpMeta.bundleIds = cmp.is;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    if (!cmpMeta.membersMeta.color) {
        cmpMeta.membersMeta.color = {
            propType: 2 /* String */,
            attribName: 'color',
            memberType: 1 /* Prop */
        };
    }
    if (cmp.properties) {
        Object.keys(cmp.properties).forEach(memberName => {
            const property = cmp.properties[memberName];
            const memberMeta = cmpMeta.membersMeta[memberName] = {};
            if (property.state) {
                memberMeta.memberType = 5 /* State */;
            }
            else if (property.elementRef) {
                memberMeta.memberType = 7 /* Element */;
            }
            else if (property.method) {
                memberMeta.memberType = 6 /* Method */;
            }
            else if (property.connect) {
                memberMeta.memberType = 4 /* PropConnect */;
                memberMeta.ctrlId = property.connect;
            }
            else if (property.context) {
                memberMeta.memberType = 3 /* PropContext */;
                memberMeta.ctrlId = property.context;
            }
            else {
                if (property.type === String) {
                    memberMeta.propType = 2 /* String */;
                }
                else if (property.type === Boolean) {
                    memberMeta.propType = 3 /* Boolean */;
                }
                else if (property.type === Number) {
                    memberMeta.propType = 4 /* Number */;
                }
                else {
                    memberMeta.propType = 1 /* Any */;
                }
                if (property.attr) {
                    memberMeta.attribName = property.attr;
                }
                else {
                    memberMeta.attribName = memberName;
                }
                memberMeta.reflectToAttrib = !!property.reflectToAttr;
                if (property.mutable) {
                    memberMeta.memberType = 2 /* PropMutable */;
                }
                else {
                    memberMeta.memberType = 1 /* Prop */;
                }
            }
        });
    }
    if (cmp.listeners) {
        cmpMeta.listenersMeta = cmp.listeners.map(listener => {
            return {
                eventName: listener.name,
                eventMethodName: listener.method,
                eventCapture: listener.capture,
                eventDisabled: listener.disabled,
                eventPassive: listener.passive
            };
        });
    }
    return cmpMeta;
}

function initCoreComponentOnReady(plt, App) {
    // create the function the HTMLElement.prototype.componentOnReady will end up calling
    App.componentOnReady = (elm, resolve) => {
        if (plt.getComponentMeta(elm) && !plt.hasLoadedMap.has(elm)) {
            // this is a known component and the
            // host element hasn't finished loading yet
            const onReadyCallbacks = plt.onReadyCallbacksMap.get(elm) || [];
            onReadyCallbacks.push(resolve);
            plt.onReadyCallbacksMap.set(elm, onReadyCallbacks);
        }
        else {
            // either the host element has already loaded
            // or it's not even a component
            resolve(elm);
        }
    };
    // drain the queue that could have been filled up before the core fully loaded
    App.$r && App.$r.forEach(r => App.componentOnReady(r[0], r[1]));
    // remove the queue now that the core file has initialized
    App.$r = null;
}

function patchDomApi(config, plt, domApi) {
    const orgCreateElement = domApi.$createElement;
    domApi.$createElement = (tagName) => {
        const elm = orgCreateElement(tagName);
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && !cmpMeta.componentConstructor) {
            initHostElement(plt, cmpMeta, elm, config.namespace);
            const hostSnapshot = initHostSnapshot(domApi, cmpMeta, elm);
            plt.requestBundle(cmpMeta, elm, hostSnapshot);
        }
        return elm;
    };
}

function proxyController(domApi, controllerComponents, ctrlTag) {
    return {
        'create': proxyProp(domApi, controllerComponents, ctrlTag, 'create'),
        'componentOnReady': proxyProp(domApi, controllerComponents, ctrlTag, 'componentOnReady')
    };
}
function proxyProp(domApi, controllerComponents, ctrlTag, proxyMethodName) {
    return function () {
        const args = arguments;
        return loadComponent(domApi, controllerComponents, ctrlTag)
            .then(ctrlElm => ctrlElm[proxyMethodName].apply(ctrlElm, args));
    };
}
function loadComponent(domApi, controllerComponents, ctrlTag) {
    return new Promise(resolve => {
        let ctrlElm = controllerComponents[ctrlTag];
        if (!ctrlElm) {
            ctrlElm = domApi.$body.querySelector(ctrlTag);
        }
        if (!ctrlElm) {
            ctrlElm = controllerComponents[ctrlTag] = domApi.$createElement(ctrlTag);
            domApi.$appendChild(domApi.$body, ctrlElm);
        }
        ctrlElm.componentOnReady(resolve);
    });
}

function createPlatformServer(config, outputTarget, win, doc, App, cmpRegistry, diagnostics, isPrerender, compilerCtx) {
    const loadedBundles = {};
    const styles = {};
    const controllerComponents = {};
    const domApi = createDomApi(App, win, doc);
    // init build context
    compilerCtx = compilerCtx || {};
    // the root <html> element is always the top level registered component
    cmpRegistry = Object.assign({ 'html': {} }, cmpRegistry);
    // initialize Core global object
    const Context = {};
    Context.enableListener = (instance, eventName, enabled, attachTo, passive) => enableEventListener(plt, instance, eventName, enabled, attachTo, passive);
    Context.emit = (elm, eventName, data) => domApi.$dispatchEvent(elm, Context.eventNameFn ? Context.eventNameFn(eventName) : eventName, data);
    Context.isClient = false;
    Context.isServer = true;
    Context.isPrerender = isPrerender;
    Context.window = win;
    Context.location = win.location;
    Context.document = doc;
    // add the Core global to the window context
    // Note: "Core" is not on the window context on the client-side
    win.Context = Context;
    // add the h() fn to the app's global namespace
    App.h = h;
    App.Context = Context;
    // add the app's global to the window context
    win[config.namespace] = App;
    const appBuildDir = getAppBuildDir(config, outputTarget);
    Context.resourcesUrl = Context.publicPath = appBuildDir;
    // create the sandboxed context with a new instance of a V8 Context
    // V8 Context provides an isolated global environment
    config.sys.vm.createContext(compilerCtx, outputTarget, win);
    // execute the global scripts (if there are any)
    runGlobalScripts();
    // internal id increment for unique ids
    let ids = 0;
    // create the platform api which is used throughout common core code
    const plt = {
        attachStyles: noop,
        defineComponent,
        domApi,
        emitEvent: Context.emit,
        getComponentMeta,
        getContextItem,
        isDefinedComponent,
        onError,
        nextId: () => config.namespace + (ids++),
        propConnect,
        queue: (Context.queue = createQueueServer()),
        requestBundle: requestBundle,
        tmpDisconnected: false,
        ancestorHostElementMap: new WeakMap(),
        componentAppliedStyles: new WeakMap(),
        hasConnectedMap: new WeakMap(),
        hasListenersMap: new WeakMap(),
        hasLoadedMap: new WeakMap(),
        hostElementMap: new WeakMap(),
        hostSnapshotMap: new WeakMap(),
        instanceMap: new WeakMap(),
        isDisconnectedMap: new WeakMap(),
        isQueuedForUpdate: new WeakMap(),
        onReadyCallbacksMap: new WeakMap(),
        queuedEvents: new WeakMap(),
        vnodeMap: new WeakMap(),
        valuesMap: new WeakMap()
    };
    // patch dom api like createElement()
    patchDomApi(config, plt, domApi);
    // create the renderer which will be used to patch the vdom
    plt.render = createRendererPatch(plt, domApi);
    // patch the componentOnReady fn
    initCoreComponentOnReady(plt, App);
    // setup the root node of all things
    // which is the mighty <html> tag
    const rootElm = domApi.$documentElement;
    rootElm['s-ld'] = [];
    rootElm['s-rn'] = true;
    rootElm['s-init'] = function appLoadedCallback() {
        plt.hasLoadedMap.set(rootElm, true);
        appLoaded();
    };
    function appLoaded(failureDiagnostic) {
        if (plt.hasLoadedMap.has(rootElm) || failureDiagnostic) {
            // the root node has loaded
            // and there are no css files still loading
            const allStyles = Object.keys(styles).map(tagName => styles[tagName]);
            plt.onAppLoad && plt.onAppLoad(rootElm, allStyles, failureDiagnostic);
        }
    }
    function getComponentMeta(elm) {
        // registry tags are always lower-case
        return cmpRegistry[elm.tagName.toLowerCase()];
    }
    function defineComponent(cmpMeta) {
        // default mode and color props
        cmpRegistry[cmpMeta.tagNameMeta] = cmpMeta;
    }
    function setLoadedBundle(bundleId, value) {
        loadedBundles[bundleId] = value;
    }
    function getLoadedBundle(bundleId) {
        if (bundleId == null) {
            return null;
        }
        return loadedBundles[bundleId.replace(/^\.\//, '')];
    }
    /**
     * Execute a bundle queue item
     * @param name
     * @param deps
     * @param callback
     */
    function execBundleCallback(name, deps, callback) {
        const bundleExports = {};
        try {
            callback(bundleExports, ...deps.map(d => getLoadedBundle(d)));
        }
        catch (e) {
            onError(e, 1 /* LoadBundleError */, null, true);
        }
        // If name is undefined then this callback was fired by component callback
        if (name === undefined) {
            return;
        }
        setLoadedBundle(name, bundleExports);
        // If name contains chunk then this callback was associated with a dependent bundle loading
        // let's add a reference to the constructors on each components metadata
        // each key in moduleImports is a PascalCased tag name
        if (!name.startsWith('chunk')) {
            Object.keys(bundleExports).forEach(pascalCasedTagName => {
                const normalizedTagName = pascalCasedTagName.replace(/-/g, '').toLowerCase();
                const registryTags = Object.keys(cmpRegistry);
                for (let i = 0; i < registryTags.length; i++) {
                    const normalizedRegistryTag = registryTags[i].replace(/-/g, '').toLowerCase();
                    if (normalizedRegistryTag === normalizedTagName) {
                        const cmpMeta = cmpRegistry[toDashCase(pascalCasedTagName)];
                        if (cmpMeta) {
                            // connect the component's constructor to its metadata
                            const componentConstructor = bundleExports[pascalCasedTagName];
                            if (!cmpMeta.componentConstructor) {
                                fillCmpMetaFromConstructor(componentConstructor, cmpMeta);
                                if (!cmpMeta.componentConstructor) {
                                    cmpMeta.componentConstructor = componentConstructor;
                                }
                            }
                            if (componentConstructor.style) {
                                styles[cmpMeta.tagNameMeta] = componentConstructor.style;
                            }
                        }
                        break;
                    }
                }
            });
        }
    }
    /**
     * This function is called anytime a JS file is loaded
     */
    App.loadBundle = function loadBundle(bundleId, [, ...dependentsList], importer) {
        const missingDependents = dependentsList.filter(d => !getLoadedBundle(d));
        missingDependents.forEach(d => {
            const fileName = d.replace('.js', '.es5.js');
            loadFile(fileName);
        });
        execBundleCallback(bundleId, dependentsList, importer);
    };
    function isDefinedComponent(elm) {
        return !!(cmpRegistry[elm.tagName.toLowerCase()]);
    }
    plt.attachStyles = function attachStyles(_domApi, _cmpMeta, _modeName, _elm) { };
    // This is executed by the component's connected callback.
    function requestBundle(cmpMeta, elm, hostSnapshot) {
        // remember a "snapshot" of this host element's current attributes/child nodes/slots/etc
        plt.hostSnapshotMap.set(elm, hostSnapshot);
        // set the "mode" property
        if (!elm.mode) {
            // looks like mode wasn't set as a property directly yet
            // first check if there's an attribute
            // next check the app's global
            elm.mode = domApi.$getAttribute(elm, 'mode') || Context.mode;
        }
        // It is possible the data was loaded from an outside source like tests
        if (cmpRegistry[cmpMeta.tagNameMeta].componentConstructor) {
            if (cmpRegistry[cmpMeta.tagNameMeta].componentConstructor.style) {
                styles[cmpMeta.tagNameMeta] = cmpRegistry[cmpMeta.tagNameMeta].componentConstructor.style;
            }
            queueUpdate(plt, elm);
        }
        else {
            const bundleId = (typeof cmpMeta.bundleIds === 'string') ?
                cmpMeta.bundleIds :
                cmpMeta.bundleIds[elm.mode];
            if (getLoadedBundle(bundleId)) {
                // sweet, we've already loaded this bundle
                if (cmpRegistry[cmpMeta.tagNameMeta].componentConstructor.style) {
                    styles[cmpMeta.tagNameMeta] = cmpRegistry[cmpMeta.tagNameMeta].componentConstructor.style;
                }
                queueUpdate(plt, elm);
            }
            else {
                const fileName = getComponentBundleFilename(cmpMeta, elm.mode);
                loadFile(fileName);
            }
        }
    }
    function loadFile(fileName) {
        const jsFilePath = config.sys.path.join(appBuildDir, fileName);
        const jsCode = compilerCtx.fs.readFileSync(jsFilePath);
        config.sys.vm.runInContext(jsCode, win);
    }
    function runGlobalScripts() {
        if (!compilerCtx || !compilerCtx.appFiles || !compilerCtx.appFiles.global) {
            return;
        }
        config.sys.vm.runInContext(compilerCtx.appFiles.global, win);
    }
    function onError(err, type, elm, appFailure) {
        const diagnostic = {
            type: 'runtime',
            header: 'Runtime error detected',
            level: 'error',
            messageText: err ? err.message ? err.message : err.toString() : ''
        };
        if (err && err.stack) {
            diagnostic.messageText += '\n' + err.stack;
            diagnostic.messageText = diagnostic.messageText.trim();
        }
        switch (type) {
            case 1 /* LoadBundleError */:
                diagnostic.header += ' while loading bundle';
                break;
            case 2 /* QueueEventsError */:
                diagnostic.header += ' while running initial events';
                break;
            case 3 /* WillLoadError */:
                diagnostic.header += ' during componentWillLoad()';
                break;
            case 4 /* DidLoadError */:
                diagnostic.header += ' during componentDidLoad()';
                break;
            case 7 /* InitInstanceError */:
                diagnostic.header += ' while initializing instance';
                break;
            case 8 /* RenderError */:
                diagnostic.header += ' while rendering';
                break;
            case 6 /* DidUpdateError */:
                diagnostic.header += ' while updating';
                break;
        }
        if (elm && elm.tagName) {
            diagnostic.header += ': ' + elm.tagName.toLowerCase();
        }
        diagnostics.push(diagnostic);
        if (appFailure) {
            appLoaded(diagnostic);
        }
    }
    function propConnect(ctrlTag) {
        return proxyController(domApi, controllerComponents, ctrlTag);
    }
    function getContextItem(contextKey) {
        return Context[contextKey];
    }
    return plt;
}
function getComponentBundleFilename(cmpMeta, modeName) {
    let bundleId = (typeof cmpMeta.bundleIds === 'string') ?
        cmpMeta.bundleIds :
        (cmpMeta.bundleIds[modeName] || cmpMeta.bundleIds[DEFAULT_STYLE_MODE]);
    if (cmpMeta.encapsulation === 2 /* ScopedCss */ || cmpMeta.encapsulation === 1 /* ShadowDom */) {
        bundleId += '.sc';
    }
    // server-side always uses es5 and jsonp callback modules
    bundleId += '.es5.js';
    return bundleId;
}

var __awaiter$35 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function hydrateHtml(config, compilerCtx, outputTarget, cmpRegistry, opts) {
    return new Promise(resolve => {
        // validate the hydrate options and add any missing info
        const hydrateTarget = normalizeHydrateOptions(outputTarget, opts);
        // create the results object we're gonna return
        const hydrateResults = generateHydrateResults(config, hydrateTarget);
        // create a emulated window
        // attach data the request to the window
        const dom = config.sys.createDom();
        const win = dom.parse(hydrateTarget);
        const doc = win.document;
        // normalize dir and lang before connecting elements
        // so that the info is their incase they read it at runtime
        normalizeDirection(doc, hydrateTarget);
        normalizeLanguage(doc, hydrateTarget);
        // create the app global
        const App = {};
        // create the platform
        const plt = createPlatformServer(config, hydrateTarget, win, doc, App, cmpRegistry, hydrateResults.diagnostics, hydrateTarget.isPrerender, compilerCtx);
        // fire off this function when the app has finished loading
        // and all components have finished hydrating
        plt.onAppLoad = (rootElm, styles, failureDiagnostic) => __awaiter$35(this, void 0, void 0, function* () {
            if (config._isTesting) {
                hydrateResults.__testPlatform = plt;
            }
            if (failureDiagnostic) {
                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);
                dom.destroy();
                resolve(hydrateResults);
                return;
            }
            // all synchronous operations next
            if (rootElm) {
                try {
                    // optimize this document!!
                    yield optimizeHtml(config, compilerCtx, hydrateTarget, hydrateResults.url, doc, styles, hydrateResults.diagnostics);
                    // gather up all of the <a> tag information in the doc
                    if (hydrateTarget.isPrerender && hydrateTarget.hydrateComponents) {
                        collectAnchors(config, doc, hydrateResults);
                    }
                    // serialize this dom back into a string
                    if (hydrateTarget.serializeHtml !== false) {
                        hydrateResults.html = dom.serialize();
                    }
                }
                catch (e) {
                    // gahh, something's up
                    hydrateResults.diagnostics.push({
                        level: 'error',
                        type: 'hydrate',
                        header: 'DOM Serialize',
                        messageText: e
                    });
                    // idk, some error, just use the original html
                    hydrateResults.html = hydrateTarget.html;
                }
            }
            if (hydrateTarget.destroyDom !== false) {
                // always destroy the dom unless told otherwise
                dom.destroy();
            }
            else {
                // we didn't destroy the dom
                // so let's return the root element
                hydrateResults.root = rootElm;
            }
            // cool, all good here, even if there are errors
            // we're passing back the result object
            resolve(hydrateResults);
        });
        if (hydrateTarget.hydrateComponents === false) {
            plt.onAppLoad(win.document.body, []);
            return;
        }
        // patch the render function that we can add SSR ids
        // and to connect any elements it may have just appened to the DOM
        let ssrIds = 0;
        const pltRender = plt.render;
        plt.render = function render(oldVNode, newVNode, isUpdate, encapsulation) {
            let ssrId;
            let existingSsrId;
            if (hydrateTarget.ssrIds !== false) {
                // this may have been patched more than once
                // so reuse the ssr id if it already has one
                if (oldVNode && oldVNode.elm) {
                    existingSsrId = oldVNode.elm.getAttribute(SSR_VNODE_ID);
                }
                if (existingSsrId) {
                    ssrId = parseInt(existingSsrId, 10);
                }
                else {
                    ssrId = ssrIds++;
                }
            }
            newVNode = pltRender(oldVNode, newVNode, isUpdate, encapsulation, ssrId);
            connectChildElements(config, plt, App, hydrateResults, newVNode.elm);
            return newVNode;
        };
        // loop through each node and start connecting/hydrating
        // any elements that are host elements to components
        // this kicks off all the async hydrating
        connectChildElements(config, plt, App, hydrateResults, win.document.body);
        if (hydrateResults.components.length === 0) {
            // what gives, never found ANY host elements to connect!
            // ok we're just done i guess, idk
            hydrateResults.html = hydrateTarget.html;
            resolve(hydrateResults);
        }
    });
}

var __awaiter$36 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createAppRegistry(config) {
    // create the shared app registry object
    const appRegistry = {
        namespace: config.namespace,
        fsNamespace: config.fsNamespace,
        loader: `../${getLoaderFileName(config)}`
    };
    return appRegistry;
}
function getAppRegistry(config, compilerCtx, outputTarget) {
    const registryJsonFilePath = getRegistryJson(config, outputTarget);
    let appRegistry;
    try {
        // open up the app registry json file
        const appRegistryJson = compilerCtx.fs.readFileSync(registryJsonFilePath);
        // parse the json into app registry data
        appRegistry = JSON.parse(appRegistryJson);
        config.logger.debug(`parsed app registry: ${registryJsonFilePath}`);
    }
    catch (e) {
        throw new Error(`Error parsing app registry, ${registryJsonFilePath}: ${e}`);
    }
    return appRegistry;
}
function serializeComponentRegistry(cmpRegistry) {
    const appRegistryComponents = {};
    Object.keys(cmpRegistry).sort().forEach(tagName => {
        appRegistryComponents[tagName] = cmpRegistry[tagName].bundleIds;
    });
    return appRegistryComponents;
}
function writeAppRegistry(config, compilerCtx, outputTarget, appRegistry, cmpRegistry) {
    return __awaiter$36(this, void 0, void 0, function* () {
        if (outputTarget.type !== 'www') {
            // only create a registry for www builds
            return;
        }
        appRegistry.components = serializeComponentRegistry(cmpRegistry);
        const registryJson = JSON.stringify(appRegistry, null, 2);
        // cache so we can check if it changed on rebuilds
        compilerCtx.appFiles.registryJson = registryJson;
        const appRegistryWWW = getRegistryJson(config, outputTarget);
        config.logger.debug(`build, app www registry: ${appRegistryWWW}`);
        yield compilerCtx.fs.writeFile(appRegistryWWW, registryJson);
    });
}

function loadComponentRegistry(config, compilerCtx, outputTarget) {
    const appRegistry = getAppRegistry(config, compilerCtx, outputTarget);
    const cmpRegistry = {};
    const tagNames = Object.keys(appRegistry.components);
    tagNames.forEach(tagName => {
        cmpRegistry[tagName] = {
            tagNameMeta: tagName,
            bundleIds: appRegistry.components[tagName]
        };
    });
    return cmpRegistry;
}

var __awaiter$37 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Renderer {
    constructor(config, registry, ctx, outputTarget) {
        this.config = config;
        this.config = validateConfig(config);
        // init the build context
        this.ctx = getCompilerCtx(config, ctx);
        this.outputTarget = outputTarget || config.outputTargets.find(o => o.type === 'www');
        // load the component registry from the registry.json file
        this.cmpRegistry = registry || loadComponentRegistry(config, this.ctx, this.outputTarget);
        if (Object.keys(this.cmpRegistry).length === 0) {
            throw new Error(`No registered components found: ${config.namespace}`);
        }
        // load the app global file into the context
        loadAppGlobal(config, this.ctx, this.outputTarget);
    }
    hydrate(hydrateOpts) {
        return __awaiter$37(this, void 0, void 0, function* () {
            let hydrateResults;
            // kick off hydrated, which is an async opertion
            try {
                hydrateResults = yield hydrateHtml(this.config, this.ctx, this.outputTarget, this.cmpRegistry, hydrateOpts);
            }
            catch (e) {
                hydrateResults = {
                    url: hydrateOpts.path,
                    diagnostics: [],
                    html: hydrateOpts.html,
                    styles: null,
                    anchors: [],
                    components: [],
                    styleUrls: [],
                    scriptUrls: [],
                    imgUrls: []
                };
                catchError(hydrateResults.diagnostics, e);
            }
            return hydrateResults;
        });
    }
    get fs() {
        return this.ctx.fs;
    }
}
function loadAppGlobal(config, compilerCtx, outputTarget) {
    compilerCtx.appFiles = compilerCtx.appFiles || {};
    if (compilerCtx.appFiles.global) {
        // already loaded the global js content
        return;
    }
    // let's load the app global js content
    const appGlobalPath = getGlobalJsBuildPath(config, outputTarget);
    try {
        compilerCtx.appFiles.global = compilerCtx.fs.readFileSync(appGlobalPath);
    }
    catch (e) {
        config.logger.debug(`missing app global: ${appGlobalPath}`);
    }
}

var __awaiter$38 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function prerenderPath(config, compilerCtx, buildCtx, outputTarget, indexSrcHtml, prerenderLocation) {
    return __awaiter$38(this, void 0, void 0, function* () {
        const msg = outputTarget.hydrateComponents ? 'prerender' : 'optimize html';
        const timeSpan = config.logger.createTimeSpan(`${msg}, started: ${prerenderLocation.path}`);
        const results = {
            diagnostics: []
        };
        try {
            // create the renderer config
            const rendererConfig = Object.assign({}, config);
            // create the hydrate options from the prerender config
            const hydrateOpts = {};
            hydrateOpts.url = prerenderLocation.url;
            hydrateOpts.isPrerender = true;
            // set the input html which we just read from the src index html file
            hydrateOpts.html = indexSrcHtml;
            // create a server-side renderer
            const renderer = new Renderer(rendererConfig, null, compilerCtx, outputTarget);
            // parse the html to dom nodes, hydrate the components, then
            // serialize the hydrated dom nodes back to into html
            const hydratedResults = yield renderer.hydrate(hydrateOpts);
            // hydrating to string is done!!
            // let's use this updated html for the index content now
            Object.assign(results, hydratedResults);
        }
        catch (e) {
            // ahh man! what happened!
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`${msg}, finished: ${prerenderLocation.path}`);
        return results;
    });
}

var __awaiter$39 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function prerenderOutputTargets(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$39(this, void 0, void 0, function* () {
        if (!config.srcIndexHtml) {
            return;
        }
        const outputTargets = config.outputTargets.filter(o => {
            return o.type === 'www' && o.indexHtml;
        });
        yield Promise.all(outputTargets.map((outputTarget) => __awaiter$39(this, void 0, void 0, function* () {
            if (outputTarget.hydrateComponents && outputTarget.prerenderLocations && outputTarget.prerenderLocations.length > 0) {
                yield prerenderOutputTarget(config, compilerCtx, buildCtx, outputTarget, entryModules);
            }
            else {
                const windowLocationPath = outputTarget.baseUrl;
                yield optimizeIndexHtml(config, compilerCtx, outputTarget, windowLocationPath, buildCtx.diagnostics);
            }
        })));
    });
}
function prerenderOutputTarget(config, compilerCtx, buildCtx, outputTarget, entryModules) {
    return __awaiter$39(this, void 0, void 0, function* () {
        // if there was src index.html file, then the process before this one
        // would have already loaded and updated the src index to its www path
        // get the www index html content for the template for all prerendered pages
        let indexHtml = null;
        try {
            indexHtml = yield compilerCtx.fs.readFile(outputTarget.indexHtml);
        }
        catch (e) { }
        if (typeof indexHtml !== 'string') {
            // looks like we don't have an index html file, which is fine
            config.logger.debug(`prerenderApp, missing index.html for prerendering`);
            return [];
        }
        // get the prerender urls to queue up
        const prerenderQueue = getPrerenderQueue(config, outputTarget);
        if (!prerenderQueue.length) {
            const d = buildWarn(buildCtx.diagnostics);
            d.messageText = `No urls found in the prerender config`;
            return [];
        }
        return runPrerenderApp(config, compilerCtx, buildCtx, outputTarget, entryModules, prerenderQueue, indexHtml);
    });
}
function runPrerenderApp(config, compilerCtx, buildCtx, outputTarget, entryModules, prerenderQueue, indexHtml) {
    return __awaiter$39(this, void 0, void 0, function* () {
        // keep track of how long the entire build process takes
        const timeSpan = config.logger.createTimeSpan(`prerendering started`, !outputTarget.hydrateComponents);
        const hydrateResults = [];
        try {
            yield new Promise(resolve => {
                drainPrerenderQueue(config, compilerCtx, buildCtx, outputTarget, prerenderQueue, indexHtml, hydrateResults, resolve);
            });
            yield generateHostConfig(config, compilerCtx, outputTarget, entryModules, hydrateResults);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        hydrateResults.forEach(hydrateResult => {
            hydrateResult.diagnostics.forEach(diagnostic => {
                buildCtx.diagnostics.push(diagnostic);
            });
        });
        if (hasError(buildCtx.diagnostics)) {
            timeSpan.finish(`prerendering failed`);
        }
        else {
            timeSpan.finish(`prerendered urls: ${hydrateResults.length}`);
        }
        if (compilerCtx.localPrerenderServer) {
            compilerCtx.localPrerenderServer.close();
            delete compilerCtx.localPrerenderServer;
        }
        return hydrateResults;
    });
}
function drainPrerenderQueue(config, compilerCtx, buildCtx, outputTarget, prerenderQueue, indexSrcHtml, hydrateResults, resolve) {
    for (var i = 0; i < outputTarget.prerenderMaxConcurrent; i++) {
        const activelyProcessingCount = prerenderQueue.filter(p => p.status === 'processing').length;
        if (activelyProcessingCount >= outputTarget.prerenderMaxConcurrent) {
            // whooaa, slow down there buddy, let's not get carried away
            break;
        }
        runNextPrerenderUrl(config, compilerCtx, buildCtx, outputTarget, prerenderQueue, indexSrcHtml, hydrateResults, resolve);
    }
    const remaining = prerenderQueue.filter(p => {
        return p.status === 'processing' || p.status === 'pending';
    }).length;
    if (remaining === 0) {
        // we're not actively processing anything
        // and there aren't anymore urls in the queue to be prerendered
        // so looks like our job here is done, good work team
        resolve();
    }
}
function runNextPrerenderUrl(config, compilerCtx, buildCtx, outputTarget, prerenderQueue, indexSrcHtml, hydrateResults, resolve) {
    return __awaiter$39(this, void 0, void 0, function* () {
        const p = prerenderQueue.find(p => p.status === 'pending');
        if (!p)
            return;
        // we've got a url that's pending
        // well guess what, it's go time
        p.status = 'processing';
        try {
            // prender this path and wait on the results
            const results = yield prerenderPath(config, compilerCtx, buildCtx, outputTarget, indexSrcHtml, p);
            // awesome!!
            if (outputTarget.prerenderUrlCrawl) {
                crawlAnchorsForNextUrls(config, outputTarget, prerenderQueue, results.url, results.anchors);
            }
            hydrateResults.push(results);
            yield writePrerenderDest(config, compilerCtx, outputTarget, results);
        }
        catch (e) {
            // darn, idk, bad news
            catchError(buildCtx.diagnostics, e);
        }
        // this job is not complete
        p.status = 'complete';
        // let's try to drain the queue again and let this
        // next call figure out if we're actually done or not
        drainPrerenderQueue(config, compilerCtx, buildCtx, outputTarget, prerenderQueue, indexSrcHtml, hydrateResults, resolve);
    });
}
function writePrerenderDest(config, compilerCtx, outputTarget, results) {
    return __awaiter$39(this, void 0, void 0, function* () {
        // create the full path where this will be saved
        const filePath = getWritePathFromUrl(config, outputTarget, results.url);
        // add the prerender html content it to our collection of
        // files that need to be saved when we're all ready
        yield compilerCtx.fs.writeFile(filePath, results.html);
    });
}

var __awaiter$40 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function buildAuxiliaries(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$40(this, void 0, void 0, function* () {
        // generate component docs
        // and prerender can run in parallel
        yield Promise.all([
            generateDocs(config, compilerCtx),
            generateServiceWorkers(config, compilerCtx, buildCtx),
            prerenderOutputTargets(config, compilerCtx, buildCtx, entryModules)
        ]);
        if (!buildCtx.shouldAbort()) {
            yield compilerCtx.fs.commit();
        }
    });
}

var __awaiter$41 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function emptyOutputTargetDirs(config, compilerCtx) {
    return __awaiter$41(this, void 0, void 0, function* () {
        if (compilerCtx.isRebuild) {
            // only empty the directories on the first build
            return;
        }
        // let's empty out the build dest directory
        const outputTargets = config.outputTargets.filter(o => o.empty === true);
        yield Promise.all(outputTargets.map((outputTarget) => __awaiter$41(this, void 0, void 0, function* () {
            config.logger.debug(`empty dir: ${outputTarget.dir}`);
            yield compilerCtx.fs.emptyDir(outputTarget.dir);
        })));
    });
}

function buildExpressionReplacer(config, input) {
    return input
        .replace(/process.env.NODE_ENV(\s*)(===|==)(\s*)['"`]production['"`]/g, (!config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(!==|!=)(\s*)['"`]development['"`]/g, (!config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(===|==)(\s*)['"`]development['"`]/g, (config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(!==|!=)(\s*)['"`]production['"`]/g, (config.devMode).toString());
}

function loadRollupDiagnostics(config, compilerCtx, buildCtx, rollupError) {
    const d = {
        level: 'error',
        type: 'build',
        language: 'javascript',
        header: 'build error',
        code: rollupError.code,
        messageText: rollupError.message,
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (rollupError.loc && rollupError.loc.file) {
        d.absFilePath = rollupError.loc.file;
        d.relFilePath = formatFileName(config.rootDir, d.absFilePath);
        try {
            const sourceText = compilerCtx.fs.readFileSync(d.absFilePath);
            const srcLines = splitLineBreaks(sourceText);
            let htmlLines = srcLines;
            try {
                htmlLines = splitLineBreaks(highlight(d.language, sourceText, true).value);
            }
            catch (e) { }
            const errorLine = {
                lineIndex: rollupError.loc.line - 1,
                lineNumber: rollupError.loc.line,
                text: srcLines[rollupError.loc.line - 1],
                html: htmlLines[rollupError.loc.line - 1],
                errorCharStart: rollupError.loc.column,
                errorLength: 0
            };
            const highlightLine = errorLine.text.substr(rollupError.loc.column);
            for (var i = 0; i < highlightLine.length; i++) {
                if (CHAR_BREAK.indexOf(highlightLine.charAt(i)) > -1) {
                    break;
                }
                errorLine.errorLength++;
            }
            if (errorLine.html && errorLine.html.indexOf('class="hljs') === -1) {
                try {
                    errorLine.html = highlight(d.language, errorLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.push(errorLine);
            if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
                errorLine.errorLength = 1;
                errorLine.errorCharStart--;
            }
            d.header = formatHeader('bundling', d.absFilePath, config.rootDir, errorLine.lineNumber);
            if (errorLine.lineIndex > 0) {
                const previousLine = {
                    lineIndex: errorLine.lineIndex - 1,
                    lineNumber: errorLine.lineNumber - 1,
                    text: srcLines[errorLine.lineIndex - 1],
                    html: htmlLines[errorLine.lineIndex - 1],
                    errorCharStart: -1,
                    errorLength: -1
                };
                if (previousLine.html && previousLine.html.indexOf('class="hljs') === -1) {
                    try {
                        previousLine.html = highlight(d.language, previousLine.text, true).value;
                    }
                    catch (e) { }
                }
                d.lines.unshift(previousLine);
            }
            if (errorLine.lineIndex + 1 < srcLines.length) {
                const nextLine = {
                    lineIndex: errorLine.lineIndex + 1,
                    lineNumber: errorLine.lineNumber + 1,
                    text: srcLines[errorLine.lineIndex + 1],
                    html: htmlLines[errorLine.lineIndex + 1],
                    errorCharStart: -1,
                    errorLength: -1
                };
                if (nextLine.html && nextLine.html.indexOf('class="hljs') === -1) {
                    try {
                        nextLine.html = highlight(d.language, nextLine.text, true).value;
                    }
                    catch (e) { }
                }
                d.lines.push(nextLine);
            }
        }
        catch (e) {
            d.messageText = `Error parsing: ${rollupError.loc.file}, line: ${rollupError.loc.line}, column: ${rollupError.loc.column}`;
        }
    }
    buildCtx.diagnostics.push(d);
}
const CHAR_BREAK = [' ', '=', '.', ',', '?', ':', ';', '(', ')', '{', '}', '[', ']', '|', `'`, `"`, '`'];
function createOnWarnFn(config, diagnostics, bundleModulesFiles) {
    const previousWarns = {};
    return function onWarningMessage(warning) {
        if (!warning || warning.message in previousWarns) {
            return;
        }
        previousWarns[warning.message] = true;
        if (warning.code) {
            if (INGORE_WARNING_CODES.includes(warning.code)) {
                return;
            }
            if (SUPPRESS_WARNING_CODES.includes(warning.code)) {
                config.logger.debug(warning.message);
                return;
            }
        }
        let label = '';
        if (bundleModulesFiles) {
            label = bundleModulesFiles.map(moduleFile => moduleFile.cmpMeta.tagNameMeta).join(', ').trim();
            if (label.length) {
                label += ': ';
            }
        }
        buildWarn(diagnostics).messageText = label + (warning.message || warning);
    };
}
const INGORE_WARNING_CODES = [
    `THIS_IS_UNDEFINED`, `NON_EXISTENT_EXPORT`
];
const SUPPRESS_WARNING_CODES = [
    `CIRCULAR_DEPENDENCY`
];

var __awaiter$42 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function inMemoryFsRead(config, path$$1, compilerCtx) {
    const assetsCache = {};
    let tsFileNames;
    return {
        name: 'inMemoryFsRead',
        resolveId(importee, importer) {
            return __awaiter$42(this, void 0, void 0, function* () {
                // note: node-resolve plugin has already ran
                // we can assume the importee is a file path
                const orgImportee = importee;
                if (!path$$1.isAbsolute(importee)) {
                    importee = path$$1.resolve(importer ? path$$1.dirname(importer) : path$$1.resolve(), importee);
                    if (!importee.endsWith('.js')) {
                        importee += '.js';
                    }
                }
                importee = normalizePath(importee);
                // it's possible the importee is a file pointing directly to the source ts file
                // if it is a ts file path, then we're good to go
                var moduleFile = compilerCtx.moduleFiles[importee];
                if (compilerCtx.moduleFiles[importee]) {
                    return moduleFile.jsFilePath;
                }
                if (!tsFileNames) {
                    // get all the module files as filenames
                    // caching the filenames so we don't have to keep doing this
                    tsFileNames = Object.keys(compilerCtx.moduleFiles);
                }
                for (let i = 0; i < tsFileNames.length; i++) {
                    // see if we can find by importeE
                    moduleFile = compilerCtx.moduleFiles[tsFileNames[i]];
                    const moduleJsFilePath = moduleFile.jsFilePath;
                    if (moduleJsFilePath === importee) {
                        // exact match
                        return importee;
                    }
                    if (!importee.endsWith('.js') && moduleJsFilePath === importee + '.js') {
                        // try by appending .js
                        return `${importee}.js`;
                    }
                    if (!importee.endsWith('/index.js') && moduleJsFilePath === importee + '/index.js') {
                        // try by appending /index.js
                        return `${importee}/index.js`;
                    }
                }
                if (typeof importer === 'string' && !path$$1.isAbsolute(orgImportee)) {
                    // no luck finding the path the importee
                    // try again by using the importers source path and original importee
                    // get the original ts source path importer from this js path importer
                    for (let i = 0; i < tsFileNames.length; i++) {
                        const tsFilePath = tsFileNames[i];
                        moduleFile = compilerCtx.moduleFiles[tsFilePath];
                        if (moduleFile.jsFilePath !== importer) {
                            continue;
                        }
                        // found the importer's module file using importer's jsFilePath
                        // create an importee path using the source of the importers original ts file path
                        const srcImportee = normalizePath(path$$1.resolve(path$$1.dirname(tsFilePath), orgImportee));
                        let accessData = yield compilerCtx.fs.accessData(srcImportee);
                        if (accessData.isFile) {
                            return srcImportee;
                        }
                        if (!srcImportee.endsWith('/index.js')) {
                            accessData = yield compilerCtx.fs.accessData(srcImportee + '/index.js');
                            if (accessData.isFile) {
                                return srcImportee + '/index.js';
                            }
                        }
                        if (!srcImportee.endsWith('.js')) {
                            accessData = yield compilerCtx.fs.accessData(srcImportee + '.js');
                            if (accessData.isFile) {
                                return srcImportee + '.js';
                            }
                        }
                        break;
                    }
                }
                // let's check all of the asset directories for this path
                // think slide's swiper dependency
                for (let i = 0; i < tsFileNames.length; i++) {
                    // see if we can find by importeR
                    moduleFile = compilerCtx.moduleFiles[tsFileNames[i]];
                    if (moduleFile.jsFilePath === importer) {
                        // awesome, there's a module file for this js file via importeR
                        // now let's check if this module has an assets directory
                        if (moduleFile.cmpMeta && moduleFile.cmpMeta.assetsDirsMeta) {
                            for (var j = 0; j < moduleFile.cmpMeta.assetsDirsMeta.length; j++) {
                                const assetsAbsPath = moduleFile.cmpMeta.assetsDirsMeta[j].absolutePath;
                                const importeeFileName = path$$1.basename(importee);
                                const assetsFilePath = normalizePath(path$$1.join(assetsAbsPath, importeeFileName));
                                // ok, we've got a potential absolute path where the file "could" be
                                try {
                                    // let's see if it actually exists, but with readFileSync :(
                                    assetsCache[assetsFilePath] = compilerCtx.fs.readFileSync(assetsFilePath);
                                    if (typeof assetsCache[assetsFilePath] === 'string') {
                                        return assetsFilePath;
                                    }
                                }
                                catch (e) {
                                    config.logger.debug(`asset ${assetsFilePath} did not exist`);
                                }
                            }
                        }
                    }
                }
                return null;
            });
        },
        load(sourcePath) {
            return __awaiter$42(this, void 0, void 0, function* () {
                sourcePath = normalizePath(sourcePath);
                if (typeof assetsCache[sourcePath] === 'string') {
                    // awesome, this is one of the cached asset file we already read in resolveId
                    return assetsCache[sourcePath];
                }
                return compilerCtx.fs.readFile(sourcePath);
            });
        }
    };
}

var __awaiter$43 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function resolveCollections(compilerCtx) {
    // and by "resolve collections", we mean
    // completely ignore the entry module for collections
    // basically it's the collection's loader.js file which
    // is useful for npm and cdns, but not useful in this
    // case. Specifically for a stencil build, we can safely
    // ignore the entry module (loader) for a stencil collection
    // because this build comes with its very own freshly built loader
    return {
        name: 'resolveCollections',
        resolveId(importee) {
            const stencilCollection = compilerCtx.collections.find(c => c.collectionName === importee);
            if (stencilCollection && !stencilCollection.hasExports) {
                return COLLECTION_ID;
            }
            return null;
        },
        load(id) {
            if (id === COLLECTION_ID) {
                // already determined this is a stencil collection
                // we don't want its content, let's clear it out
                return '';
            }
            return null;
        },
        transform(_sourceText, id) {
            return __awaiter$43(this, void 0, void 0, function* () {
                if (id === COLLECTION_ID) {
                    // just to save other plugins from
                    // wasting their time here
                    return '';
                }
                return null;
            });
        }
    };
}
const COLLECTION_ID = '#collection#';

var __awaiter$44 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function transpileCoreBuild(compilerCtx, coreBuild, input) {
    return __awaiter$44(this, void 0, void 0, function* () {
        const results = {
            code: null,
            diagnostics: null
        };
        let cacheKey;
        if (compilerCtx) {
            cacheKey = compilerCtx.cache.createKey('transpileCoreBuild', coreBuild, input);
            const cachedContent = yield compilerCtx.cache.get(cacheKey);
            if (cachedContent != null) {
                results.code = cachedContent;
                results.diagnostics = [];
                return results;
            }
        }
        const diagnostics = [];
        const transpileOpts = {
            compilerOptions: getCompilerOptions(coreBuild),
            transformers: {
                before: [
                    buildConditionalsTransform(coreBuild)
                ]
            }
        };
        const tsResults = ts.transpileModule(input, transpileOpts);
        loadTypeScriptDiagnostics('', diagnostics, tsResults.diagnostics);
        if (diagnostics.length) {
            results.diagnostics = diagnostics;
            results.code = input;
            return results;
        }
        results.code = tsResults.outputText;
        if (compilerCtx) {
            yield compilerCtx.cache.put(cacheKey, results.code);
        }
        return results;
    });
}
function transpileToEs5(compilerCtx, input) {
    return __awaiter$44(this, void 0, void 0, function* () {
        const diagnostics = [];
        const results = {
            code: null,
            diagnostics: null
        };
        const cacheKey = compilerCtx.cache.createKey('transpileToEs5', input);
        const cachedContent = yield compilerCtx.cache.get(cacheKey);
        if (cachedContent != null) {
            results.code = cachedContent;
            results.diagnostics = [];
            return results;
        }
        const transpileOpts = {
            compilerOptions: {
                allowJs: true,
                declaration: false,
                target: ts.ScriptTarget.ES5,
                module: ts.ModuleKind.ESNext
            }
        };
        const tsResults = ts.transpileModule(input, transpileOpts);
        loadTypeScriptDiagnostics('', diagnostics, tsResults.diagnostics);
        if (diagnostics.length > 0) {
            results.diagnostics = diagnostics;
            results.code = input;
            return results;
        }
        results.code = tsResults.outputText;
        yield compilerCtx.cache.put(cacheKey, results.code);
        return results;
    });
}
function getCompilerOptions(coreBuild) {
    const opts = {
        allowJs: true,
        declaration: false
    };
    if (coreBuild.es5) {
        opts.target = ts.ScriptTarget.ES5;
    }
    else {
        opts.target = ts.ScriptTarget.ES2017;
    }
    opts.module = ts.ModuleKind.ESNext;
    return opts;
}

var __awaiter$45 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateAppGlobalScript(config, compilerCtx, buildCtx, appRegistry, sourceTarget) {
    return __awaiter$45(this, void 0, void 0, function* () {
        const globalJsContents = yield generateAppGlobalContents(config, compilerCtx, buildCtx, sourceTarget);
        if (globalJsContents.length) {
            appRegistry.global = getGlobalFileName(config);
            const globalJsContent = generateGlobalJs(config, globalJsContents);
            const globalEsmContent = generateGlobalEsm(config, globalJsContents);
            compilerCtx.appFiles.global = globalJsContent;
            const promises = [];
            if (sourceTarget !== 'es5') {
                config.outputTargets.filter(o => o.appBuild).forEach(outputTarget => {
                    const appGlobalFilePath = getGlobalJsBuildPath(config, outputTarget);
                    promises.push(compilerCtx.fs.writeFile(appGlobalFilePath, globalJsContent));
                });
            }
            config.outputTargets.filter(o => o.type === 'dist' || o.type === 'angular').forEach(outputTarget => {
                const appGlobalFilePath = getGlobalEsmBuildPath(config, outputTarget, 'es5');
                promises.push(compilerCtx.fs.writeFile(appGlobalFilePath, globalEsmContent));
            });
            yield Promise.all(promises);
        }
        return globalJsContents.join('\n').trim();
    });
}
function generateAppGlobalContents(config, compilerCtx, buildCtx, sourceTarget) {
    return __awaiter$45(this, void 0, void 0, function* () {
        const [projectGlobalJsContent, dependentGlobalJsContents] = yield Promise.all([
            bundleProjectGlobal(config, compilerCtx, buildCtx, sourceTarget, config.namespace, config.globalScript),
            loadDependentGlobalJsContents(config, compilerCtx, buildCtx, sourceTarget),
        ]);
        return [
            projectGlobalJsContent,
            ...dependentGlobalJsContents
        ];
    });
}
function loadDependentGlobalJsContents(config, compilerCtx, buildCtx, sourceTarget) {
    return __awaiter$45(this, void 0, void 0, function* () {
        const collections = compilerCtx.collections.filter(m => m.global && m.global.jsFilePath);
        return Promise.all(collections.map(collectionManifest => {
            return bundleProjectGlobal(config, compilerCtx, buildCtx, sourceTarget, collectionManifest.collectionName, collectionManifest.global.jsFilePath);
        }));
    });
}
function bundleProjectGlobal(config, compilerCtx, buildCtx, sourceTarget, namespace, entry) {
    return __awaiter$45(this, void 0, void 0, function* () {
        // stencil by itself does not have a global file
        // however, other collections can provide a global js
        // which will bundle whatever is in the global, and then
        // prepend the output content on top of the core js
        // this way external collections can provide a shared global at runtime
        if (!entry) {
            // looks like they never provided an entry file, which is fine, so let's skip this
            return '';
        }
        const cacheKey = compilerCtx.cache.createKey('bundleProjectGlobal', namespace, entry, sourceTarget);
        const cachedContent = yield compilerCtx.cache.get(cacheKey);
        if (cachedContent != null) {
            buildCtx.global = compilerCtx.moduleFiles[config.globalScript];
            return cachedContent;
        }
        // ok, so the project also provided an entry file, so let's bundle it up and
        // the output from this can be tacked onto the top of the project's core file
        // start the bundler on our temporary file
        let output = '';
        try {
            const rollup$$1 = yield config.sys.rollup.rollup({
                input: entry,
                plugins: [
                    resolveCollections(compilerCtx),
                    config.sys.rollup.plugins.nodeResolve({
                        jsnext: true,
                        main: true
                    }),
                    config.sys.rollup.plugins.commonjs({
                        include: 'node_modules/**',
                        sourceMap: false
                    }),
                    inMemoryFsRead(config, config.sys.path, compilerCtx),
                    ...config.plugins
                ],
                onwarn: createOnWarnFn(config, buildCtx.diagnostics)
            });
            const results = yield rollup$$1.generate({ format: 'es' });
            // cool, so we balled up all of the globals into one string
            // replace build time expressions, like process.env.NODE_ENV === 'production'
            // with a hard coded boolean
            results.code = buildExpressionReplacer(config, results.code);
            // wrap our globals code with our own iife
            output = yield wrapGlobalJs(config, compilerCtx, buildCtx, sourceTarget, namespace, results.code);
            yield compilerCtx.cache.put(cacheKey, output);
            buildCtx.global = compilerCtx.moduleFiles[config.globalScript];
        }
        catch (e) {
            loadRollupDiagnostics(config, compilerCtx, buildCtx, e);
        }
        return output;
    });
}
function wrapGlobalJs(config, compilerCtx, buildCtx, sourceTarget, globalJsName, jsContent) {
    return __awaiter$45(this, void 0, void 0, function* () {
        jsContent = (jsContent || '').trim();
        // just format it a touch better in dev mode
        jsContent = `\n/** ${globalJsName || ''} global **/\n\n${jsContent}`;
        const lines = jsContent.split(/\r?\n/);
        jsContent = lines.map(line => {
            if (line.length) {
                return '    ' + line;
            }
            return line;
        }).join('\n');
        if (sourceTarget === 'es5') {
            // global could already be in es2017
            // transpile it down to es5
            config.logger.debug(`transpile global to es5: ${globalJsName}`);
            const transpileResults = yield transpileToEs5(compilerCtx, jsContent);
            if (transpileResults.diagnostics && transpileResults.diagnostics.length) {
                buildCtx.diagnostics.push(...transpileResults.diagnostics);
            }
            else {
                jsContent = transpileResults.code;
            }
        }
        if (config.minifyJs) {
            const minifyResults = yield minifyJs(config, compilerCtx, jsContent, sourceTarget, false);
            if (minifyResults.diagnostics && minifyResults.diagnostics.length) {
                buildCtx.diagnostics.push(...minifyResults.diagnostics);
            }
            else {
                jsContent = minifyResults.output;
            }
        }
        return `\n(function(resourcesUrl){${jsContent}\n})(resourcesUrl);\n`;
    });
}
function generateGlobalJs(config, globalJsContents) {
    const output = [
        generatePreamble(config) + '\n',
        `(function(namespace,resourcesUrl){`,
        `"use strict";\n`,
        globalJsContents.join('\n').trim(),
        `\n})("${config.namespace}");`
    ].join('');
    return output;
}
function generateGlobalEsm(config, globalJsContents) {
    const output = [
        generatePreamble(config) + '\n',
        `export default function appGlobal(namespace, Context, window, document, resourcesUrl, hydratedCssClass) {`,
        globalJsContents.join('\n').trim(),
        `\n}`
    ].join('');
    return output;
}

/**
 * Properties which must not be property renamed during minification
 */
const RESERVED_PROPERTIES = [
    'addListener',
    'applyPolyfill',
    'attr',
    'color',
    'Context',
    'dom',
    'emit',
    'enableListener',
    'eventNameFn',
    'h',
    'hydratedCssClass',
    'initialized',
    'isClient',
    'isPrerender',
    'isServer',
    'loaded',
    'mode',
    'namespace',
    'Promise',
    'publicPath',
    'queue',
    'raf',
    'read',
    'ref',
    'resourcesUrl',
    'tick',
    'write',
    '$definedCmps',
    '$r',
    /**
     * App Global - window.App
     * Properties which get added to the app's global
     */
    'components',
    'loadBundle',
    'loadStyles',
    /**
     * Host Element
     * Properties set on the host element
     */
    '$',
    'componentOnReady',
    /**
     * Component Constructor static properties
     */
    'attr',
    'capture',
    'connect',
    'context',
    'disabled',
    'elementRef',
    'encapsulation',
    'events',
    'host',
    'is',
    'listeners',
    'method',
    'mutable',
    'passive',
    'properties',
    'reflectToAttr',
    'scoped',
    'state',
    'style',
    'styleMode',
    'type',
    'watchCallbacks',
    /**
     * Component Instance
     * Methods set on the user's component
     */
    'componentWillLoad',
    'componentDidLoad',
    'componentWillUpdate',
    'componentDidUpdate',
    'componentDidUnload',
    'forceUpdate',
    'hostData',
    'render',
    /**
     * Web Standards / DOM
     */
    'add',
    'addEventListener',
    'appendChild',
    'async',
    'attachShadow',
    'attributeChangedCallback',
    'body',
    'bubbles',
    'cancelable',
    'capture',
    'characterData',
    'charset',
    'childNodes',
    'children',
    'class',
    'classList',
    'className',
    'cloneNode',
    'closest',
    'composed',
    'connectedCallback',
    'content',
    'createComment',
    'createElement',
    'createElementNS',
    'createEvent',
    'createTextNode',
    'CSS',
    'customElements',
    'CustomEvent',
    'data',
    'defaultView',
    'define',
    'detail',
    'didTimeout',
    'disconnect',
    'disconnectedCallback',
    'dispatchEvent',
    'document',
    'documentElement',
    'Element',
    'error',
    'Event',
    'fetch',
    'firstElementChild',
    'getAttribute',
    'getAttributeNS',
    'getRootNode',
    'getStyle',
    'head',
    'hidden',
    'host',
    'href',
    'id',
    'initCustomEvent',
    'innerHTML',
    'insertBefore',
    'location',
    'log',
    'keyCode',
    'match',
    'matches',
    'matchesSelector',
    'matchMedia',
    'mozMatchesSelector',
    'msMatchesSelector',
    'navigator',
    'nextSibling',
    'nodeName',
    'nodeType',
    'now',
    'observe',
    'observedAttributes',
    'onerror',
    'onload',
    'onmessage',
    'ownerDocument',
    'ownerSVGElement',
    'parentElement',
    'parentNode',
    'passive',
    'pathname',
    'performance',
    'postMessage',
    'previousSibling',
    'querySelector',
    'querySelectorAll',
    'remove',
    'removeAttribute',
    'removeAttributeNS',
    'removeChild',
    'removeEventListener',
    'requestAnimationFrame',
    'requestIdleCallback',
    'search',
    'setAttribute',
    'setAttributeNS',
    'shadowRoot',
    'src',
    'style',
    'supports',
    'tagName',
    'text',
    'textContent',
    'timeRemaining',
    'warn',
    'webkitMatchesSelector',
    'window',
    'HTMLElement'
];

var __awaiter$46 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function buildCoreContent(config, compilerCtx, buildCtx, coreBuild, coreContent) {
    return __awaiter$46(this, void 0, void 0, function* () {
        const timespan = config.logger.createTimeSpan(`buildCoreContent ${coreBuild.coreId} start`, true);
        const transpileResults = yield transpileCoreBuild(compilerCtx, coreBuild, coreContent);
        if (transpileResults.diagnostics && transpileResults.diagnostics.length) {
            buildCtx.diagnostics.push(...transpileResults.diagnostics);
            return coreContent;
        }
        coreContent = transpileResults.code;
        const sourceTarget = coreBuild.es5 ? 'es5' : 'es2017';
        const minifyResults = yield minifyCore(config, compilerCtx, sourceTarget, coreContent);
        if (minifyResults.diagnostics && minifyResults.diagnostics.length) {
            buildCtx.diagnostics.push(...minifyResults.diagnostics);
            return coreContent;
        }
        timespan.finish(`buildCoreContent ${coreBuild.coreId} finished`);
        return minifyResults.output;
    });
}
function minifyCore(config, compilerCtx, sourceTarget, input) {
    return __awaiter$46(this, void 0, void 0, function* () {
        const opts = Object.assign({}, config.minifyJs ? PROD_MINIFY_OPTS : DEV_MINIFY_OPTS);
        if (sourceTarget === 'es5') {
            opts.ecma = 5;
            opts.output.ecma = 5;
            opts.compress.ecma = 5;
            opts.compress.arrows = false;
        }
        opts.compress.toplevel = true;
        if (config.minifyJs) {
            if (sourceTarget !== 'es5') {
                opts.compress.arrows = true;
            }
            // reserved properties is a list of properties to NOT rename
            // if something works in dev, but a runtime error in prod
            // chances are we need to add a property to this list
            opts.mangle.properties.reserved = RESERVED_PROPERTIES.slice();
            if (config.logLevel === 'debug') {
                // if in debug mode, still mangle the property names
                // but at least make them readable of what the
                // properties originally were named
                opts.mangle.properties.debug = true;
                opts.mangle.keep_fnames = true;
                opts.compress.drop_console = false;
                opts.compress.drop_debugger = false;
                opts.output.beautify = true;
                opts.output.bracketize = true;
                opts.output.indent_level = 2;
                opts.output.comments = 'all';
                opts.output.preserve_line = true;
            }
        }
        let cacheKey;
        if (compilerCtx) {
            cacheKey = compilerCtx.cache.createKey('minifyCore', opts, input);
            const cachedContent = yield compilerCtx.cache.get(cacheKey);
            if (cachedContent != null) {
                return {
                    output: cachedContent,
                    diagnostics: []
                };
            }
        }
        const results = config.sys.minifyJs(input, opts);
        if (results && results.diagnostics.length === 0 && compilerCtx) {
            yield compilerCtx.cache.put(cacheKey, results.output);
        }
        return results;
    });
}
// Documentation of uglify options: https://github.com/mishoo/UglifyJS2
const DEV_MINIFY_OPTS = {
    compress: {
        arrows: false,
        booleans: false,
        collapse_vars: false,
        comparisons: false,
        conditionals: true,
        dead_code: true,
        drop_console: false,
        drop_debugger: false,
        evaluate: true,
        expression: false,
        hoist_funs: false,
        hoist_vars: false,
        ie8: false,
        if_return: false,
        inline: false,
        join_vars: false,
        keep_fargs: true,
        keep_fnames: true,
        keep_infinity: true,
        loops: false,
        negate_iife: false,
        passes: 1,
        properties: true,
        pure_funcs: null,
        pure_getters: false,
        reduce_vars: false,
        sequences: false,
        side_effects: false,
        switches: false,
        typeofs: false,
        top_retain: false,
        unsafe: false,
        unsafe_arrows: false,
        unsafe_comps: false,
        unsafe_Function: false,
        unsafe_math: false,
        unsafe_proto: false,
        unsafe_regexp: false,
        unused: true,
        warnings: false
    },
    mangle: false,
    output: {
        ascii_only: false,
        beautify: true,
        bracketize: true,
        comments: 'all',
        ie8: false,
        indent_level: 2,
        indent_start: 0,
        inline_script: true,
        keep_quoted_props: true,
        max_line_len: false,
        preamble: null,
        preserve_line: true,
        quote_keys: false,
        quote_style: 1,
        semicolons: true,
        shebang: true,
        source_map: null,
        webkit: false,
        width: 80,
        wrap_iife: false
    }
};
const PROD_MINIFY_OPTS = {
    compress: {
        arrows: false,
        booleans: true,
        collapse_vars: true,
        comparisons: true,
        conditionals: true,
        dead_code: true,
        drop_console: true,
        drop_debugger: true,
        evaluate: true,
        expression: true,
        hoist_funs: true,
        hoist_vars: false,
        ie8: false,
        if_return: true,
        inline: true,
        join_vars: true,
        keep_fargs: true,
        keep_fnames: true,
        keep_infinity: true,
        loops: true,
        negate_iife: false,
        passes: 2,
        properties: true,
        pure_funcs: null,
        pure_getters: false,
        reduce_vars: true,
        sequences: true,
        side_effects: true,
        switches: true,
        typeofs: true,
        unsafe: false,
        unsafe_arrows: false,
        unsafe_comps: false,
        unsafe_Function: false,
        unsafe_math: false,
        unsafe_proto: false,
        unsafe_regexp: false,
        unused: true,
        warnings: false
    },
    mangle: {
        properties: {
            builtins: false,
            debug: false,
            keep_quoted: true
        },
        toplevel: true
    },
    output: {
        ascii_only: false,
        beautify: false,
        bracketize: false,
        comments: false,
        ie8: false,
        indent_level: 0,
        indent_start: 0,
        inline_script: false,
        keep_quoted_props: false,
        max_line_len: false,
        preamble: null,
        preserve_line: false,
        quote_keys: false,
        quote_style: 0,
        semicolons: true,
        shebang: true,
        source_map: null,
        webkit: false,
        width: 80,
        wrap_iife: false
    }
};

var __awaiter$47 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateCoreBrowser(config, compilerCtx, buildCtx, outputTarget, globalJsContent, buildConditionals) {
    return __awaiter$47(this, void 0, void 0, function* () {
        // mega-minify the core w/ property renaming, but not the user's globals
        // hardcode which features should and should not go in the core builds
        // process the transpiled code by removing unused code and minify when configured to do so
        let jsContent = yield config.sys.getClientCoreFile({ staticName: 'core.build.js' });
        jsContent = yield buildCoreContent(config, compilerCtx, buildCtx, buildConditionals, jsContent);
        if (globalJsContent) {
            // we've got global js to put in the core build too
            // concat the global js and transpiled code together
            jsContent = `${globalJsContent}\n${jsContent}`;
        }
        // wrap the core js code together
        jsContent = wrapCoreJs(config, jsContent);
        if (buildConditionals.polyfills) {
            // this build wants polyfills so let's
            // add the polyfills to the top of the core content
            // the polyfilled code is already es5/minified ready to go
            const polyfillsContent = yield getAppBrowserCorePolyfills(config);
            jsContent = polyfillsContent + '\n' + jsContent;
        }
        const coreFilename = getCoreFilename(config, buildConditionals.coreId, jsContent);
        // update the app core filename within the content
        jsContent = jsContent.replace(APP_NAMESPACE_PLACEHOLDER, config.fsNamespace);
        const appCorePath = pathJoin(config, getAppBuildDir(config, outputTarget), coreFilename);
        compilerCtx.appCoreWWWPath = appCorePath;
        yield compilerCtx.fs.writeFile(appCorePath, jsContent);
        return coreFilename;
    });
}
function wrapCoreJs(config, jsContent) {
    const output = [
        generatePreamble(config) + '\n',
        `(function(Context,namespace,hydratedCssClass,resourcesUrl,s){`,
        `"use strict";\n`,
        `s=document.querySelector("script[data-namespace='${config.fsNamespace}']");`,
        `if(s){resourcesUrl=s.getAttribute('data-resources-url');}\n`,
        jsContent.trim(),
        `\n})({},"${config.namespace}","${config.hydratedCssClass}");`
    ].join('');
    return output;
}
const APP_NAMESPACE_PLACEHOLDER = '__APPNAMESPACE__';

var __awaiter$48 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function setBuildConditionals(config, compilerCtx, coreId, buildCtx, entryModules) {
    return __awaiter$48(this, void 0, void 0, function* () {
        const existingCoreBuild = getLastBuildConditionals(compilerCtx, coreId, buildCtx);
        if (existingCoreBuild) {
            // cool we can use the last build conditionals
            // because it's a rebuild, and was probably only a css or html change
            // if it was a typescript change we need to do a full rebuild again
            return existingCoreBuild;
        }
        // figure out which sections of the core code this build doesn't even need
        const coreBuild = {};
        coreBuild.coreId = coreId;
        coreBuild.clientSide = true;
        coreBuild.isDev = !!config.devMode;
        coreBuild.isProd = !config.devMode;
        coreBuild.hasSlot = !!buildCtx.hasSlot;
        coreBuild.hasSvg = !!buildCtx.hasSvg;
        coreBuild.devInspector = config.devInspector;
        coreBuild.verboseError = config.devMode;
        const promises = [];
        entryModules.forEach(bundle => {
            bundle.moduleFiles.forEach(moduleFile => {
                if (moduleFile.cmpMeta) {
                    promises.push(setBuildFromComponent(config, compilerCtx, coreBuild, moduleFile));
                }
            });
        });
        yield Promise.all(promises);
        if (coreId === 'core') {
            coreBuild.browserModuleLoader = true;
            coreBuild.slotPolyfill = !!coreBuild.slotPolyfill;
            if (coreBuild.slotPolyfill) {
                coreBuild.slotPolyfill = !!(buildCtx.hasSlot);
            }
            compilerCtx.lastBuildConditionalsBrowserEsm = coreBuild;
        }
        else if (coreId === 'core.pf') {
            coreBuild.browserModuleLoader = true;
            coreBuild.es5 = true;
            coreBuild.polyfills = true;
            coreBuild.cssVarShim = true;
            coreBuild.slotPolyfill = !!(buildCtx.hasSlot);
            compilerCtx.lastBuildConditionalsBrowserEs5 = coreBuild;
        }
        else if (coreId === 'esm.es5') {
            coreBuild.es5 = true;
            coreBuild.externalModuleLoader = true;
            coreBuild.cssVarShim = true;
            coreBuild.slotPolyfill = true;
            compilerCtx.lastBuildConditionalsEsmEs5 = coreBuild;
        }
        coreBuild.slotPolyfill = true;
        coreBuild.hasSvg = true;
        return coreBuild;
    });
}
function getLastBuildConditionals(compilerCtx, coreId, buildCtx) {
    if (compilerCtx.isRebuild && Array.isArray(buildCtx.filesChanged)) {
        // this is a rebuild and we do have lastBuildConditionals already
        const hasChangedTsFile = buildCtx.filesChanged.some(filePath => {
            return isTsFile(filePath);
        });
        if (!hasChangedTsFile) {
            // we didn't have a typescript change
            // so it's ok to use the lastBuildConditionals
            if (coreId === 'core' && compilerCtx.lastBuildConditionalsBrowserEsm) {
                return compilerCtx.lastBuildConditionalsBrowserEsm;
            }
            if (coreId === 'core.pf' && compilerCtx.lastBuildConditionalsBrowserEs5) {
                return compilerCtx.lastBuildConditionalsBrowserEs5;
            }
            if (coreId === 'esm.es5' && compilerCtx.lastBuildConditionalsEsmEs5) {
                return compilerCtx.lastBuildConditionalsEsmEs5;
            }
        }
    }
    // we've gotta do a full rebuild of the build conditionals object again
    return null;
}
function setBuildFromComponent(config, compilerCtx, coreBuild, moduleFile) {
    return __awaiter$48(this, void 0, void 0, function* () {
        setBuildFromComponentMeta(coreBuild, moduleFile.cmpMeta);
        if (moduleFile.jsFilePath) {
            try {
                const jsText = yield compilerCtx.fs.readFile(moduleFile.jsFilePath);
                setBuildFromComponentContent(coreBuild, jsText);
            }
            catch (e) {
                config.logger.debug(`setBuildFromComponent: ${moduleFile.jsFilePath}: ${e}`);
            }
        }
    });
}
function setBuildFromComponentMeta(coreBuild, cmpMeta) {
    if (!cmpMeta)
        return;
    if (cmpMeta.encapsulation === 1 /* ShadowDom */) {
        coreBuild.shadowDom = true;
    }
    else {
        coreBuild.slotPolyfill = true;
    }
    if (cmpMeta.membersMeta) {
        const memberNames = Object.keys(cmpMeta.membersMeta);
        memberNames.forEach(memberName => {
            const memberMeta = cmpMeta.membersMeta[memberName];
            const memberType = memberMeta.memberType;
            const propType = memberMeta.propType;
            if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
                if (propType === 2 /* String */ || propType === 4 /* Number */ || propType === 3 /* Boolean */ || propType === 1 /* Any */) {
                    coreBuild.observeAttr = true;
                }
            }
            else if (memberType === 4 /* PropConnect */) {
                coreBuild.propConnect = true;
            }
            else if (memberType === 3 /* PropContext */) {
                coreBuild.propContext = true;
            }
            else if (memberType === 6 /* Method */) {
                coreBuild.method = true;
            }
            else if (memberType === 7 /* Element */) {
                coreBuild.element = true;
            }
            if (memberMeta.watchCallbacks && memberMeta.watchCallbacks.length > 0) {
                coreBuild.watchCallback = true;
            }
            if (memberMeta.reflectToAttrib) {
                coreBuild.reflectToAttr = true;
            }
        });
    }
    if (cmpMeta.eventsMeta && cmpMeta.eventsMeta.length) {
        coreBuild.event = true;
    }
    if (cmpMeta.listenersMeta && cmpMeta.listenersMeta.length) {
        coreBuild.listener = true;
    }
    if (cmpMeta.stylesMeta) {
        coreBuild.styles = true;
    }
    if (cmpMeta.hostMeta && cmpMeta.hostMeta.theme) {
        coreBuild.hostTheme = true;
    }
}
function setBuildFromComponentContent(coreBuild, jsText) {
    if (typeof jsText !== 'string')
        return;
    // hacky to do it this way...yeah
    // but with collections the components may have been
    // built many moons ago, so we don't want to lock ourselves
    // into a very certain way that components can be parsed
    // so here we're just doing raw string checks, and there
    // wouldn't be any harm if a build section was included when it
    // wasn't needed, but these keywords are all pretty unique already
    if (!coreBuild.cmpWillLoad) {
        coreBuild.cmpWillLoad = (jsText.includes('componentWillLoad'));
    }
    if (!coreBuild.cmpDidLoad) {
        coreBuild.cmpDidLoad = (jsText.includes('componentDidLoad'));
    }
    if (!coreBuild.cmpWillUpdate) {
        coreBuild.cmpWillUpdate = (jsText.includes('componentWillUpdate'));
    }
    if (!coreBuild.cmpDidUpdate) {
        coreBuild.cmpDidUpdate = (jsText.includes('componentDidUpdate'));
    }
    if (!coreBuild.cmpDidUnload) {
        coreBuild.cmpDidUnload = (jsText.includes('componentDidUnload'));
    }
    if (!coreBuild.hostData) {
        coreBuild.hostData = (jsText.includes('hostData'));
    }
}

var __awaiter$49 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateEsmCore(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry) {
    return __awaiter$49(this, void 0, void 0, function* () {
        if (outputTarget.type !== 'dist') {
            return;
        }
        // mega-minify the core w/ property renaming, but not the user's globals
        // hardcode which features should and should not go in the core builds
        // process the transpiled code by removing unused code and minify when configured to do so
        let jsContent = yield config.sys.getClientCoreFile({ staticName: 'core.esm.js' });
        // browser esm core build
        const globalJsContentsEsm = yield generateAppGlobalScript(config, compilerCtx, buildCtx, appRegistry);
        const hasAppGlobalImport = !!(globalJsContentsEsm && globalJsContentsEsm.length);
        if (hasAppGlobalImport) {
            jsContent = `import appGlobal from './${getGlobalEsmFileName(config)}';\n${jsContent}`;
        }
        else {
            jsContent = `var appGlobal = function(){};\n${jsContent}`;
        }
        // figure out which sections should be included in the core build
        const buildConditionals = yield setBuildConditionals(config, compilerCtx, 'esm.es5', buildCtx, entryModules);
        yield generateEsmCoreEs5(config, compilerCtx, buildCtx, outputTarget, buildConditionals, jsContent);
    });
}
function generateEsmCoreEs5(config, compilerCtx, buildCtx, outputTarget, buildConditionals, jsContent) {
    return __awaiter$49(this, void 0, void 0, function* () {
        buildConditionals.es5 = true;
        jsContent = yield buildCoreContent(config, compilerCtx, buildCtx, buildConditionals, jsContent);
        const coreEsm = getCoreEsmBuildPath(config, outputTarget, 'es5');
        // fighting with typescript/webpack/es5 builds too much
        // #dealwithit
        jsContent = jsContent.replace('export function applyPolyfills', 'function applyPolyfills');
        jsContent = jsContent.replace('__APP__NAMESPACE__PLACEHOLDER__', config.namespace);
        jsContent = jsContent.replace('__APP__HYDRATED__CSS__PLACEHOLDER__', config.hydratedCssClass);
        jsContent = generatePreamble(config, `${config.namespace}: Core, ES5`) + '\n' + jsContent;
        yield compilerCtx.fs.writeFile(coreEsm, jsContent);
    });
}

var __awaiter$50 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateEs5DisabledMessage(config, compilerCtx, outputTarget) {
    return __awaiter$50(this, void 0, void 0, function* () {
        // not doing an es5 right now
        // but it's possible during development the user
        // tests on a browser that doesn't support es2017
        const fileName = 'es5-build-disabled.js';
        const filePath = pathJoin(config, getAppBuildDir(config, outputTarget), fileName);
        yield compilerCtx.fs.writeFile(filePath, getDisabledMessageScript());
        return fileName;
    });
}
function getDisabledMessageScript() {
    const html = `
  <style>
  body {
    font-family: sans-serif;
    padding: 20px;
    line-height:22px;
  }
  h1 {
    font-size: 18px;
  }
  h2 {
    font-size: 14px;
    margin-top: 40px;
  }
  </style>

  <h1>This Stencil app is disabled for this browser.</h1>

  <h2>Developers:</h2>
  <ul>
    <li>ES5 builds are disabled <strong>during development</strong> to take advantage of 2x faster build times.</li>
    <li>Please see the example below or our <a href="https://stenciljs.com/docs/stencil-config" target="_blank">config docs</a> if you would like to develop on a browser that does not fully support ES2017 and custom elements.</li>
    <li>Note that by default, ES5 builds and polyfills are enabled during production builds.</li>
    <li>When testing browsers it is recommended to always test in production mode, and ES5 builds should always be enabled during production builds.</li>
    <li><em>This is only an experiement and if it slows down app development then we will revert this and enable ES5 builds during dev.</em></li>
  </ul>


  <h2>Enabling ES5 builds during development:</h2>
  <pre>
    <code>npm run dev --es5</code>
  </pre>


  <h2>Enabling full production builds during development:</h2>
  <pre>
    <code>npm run dev --prod</code>
  </pre>

  <h2>Current Browser's Support:</h2>
  <ul>
    <li>ES Module Imports: <span id="esModules"></span></li>
    <li>Custom Elements: <span id="customElements"></span></li>
    <li>fetch(): <span id="fetch"></span></li>
    <li>CSS Variables: <span id="cssVariables"></span></li>
  </ul>

  <h2>Current Browser:</h2>
  <pre>
    <code id="currentBrowser"></code>
  </pre>
  `;
    const script = `
    document.body.innerHTML = '${html.replace(/\r\n|\r|\n/g, '').replace(/\'/g, `\\'`).trim()}';

    document.getElementById('currentBrowser').textContent = window.navigator.userAgent;
    document.getElementById('esModules').textContent = !!('noModule' in document.createElement('script'));
    document.getElementById('customElements').textContent = !!(window.customElements);
    document.getElementById('fetch').textContent = !!(window.fetch);
    document.getElementById('cssVariables').textContent = !!(window.CSS && window.CSS.supports && window.CSS.supports('color', 'var(--c)'));
  `;
    // timeout just to ensure <body> is ready
    return `setTimeout(function(){ ${script} }, 10)`;
}

var __awaiter$51 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function runPluginResolveId(pluginCtx, importee) {
    return __awaiter$51(this, void 0, void 0, function* () {
        for (const plugin of pluginCtx.config.plugins) {
            if (typeof plugin.resolveId === 'function') {
                try {
                    const results = plugin.resolveId(importee, null, pluginCtx);
                    if (results != null) {
                        if (typeof results.then === 'function') {
                            const promiseResults = yield results;
                            if (promiseResults != null) {
                                return promiseResults;
                            }
                        }
                        else if (typeof results === 'string') {
                            return results;
                        }
                    }
                }
                catch (e) {
                    const d = catchError(pluginCtx.diagnostics, e);
                    d.header = `${plugin.name} resolveId error`;
                }
            }
        }
        // default resolvedId
        return importee;
    });
}
function runPluginLoad(pluginCtx, id) {
    return __awaiter$51(this, void 0, void 0, function* () {
        for (const plugin of pluginCtx.config.plugins) {
            if (typeof plugin.load === 'function') {
                try {
                    const results = plugin.load(id, pluginCtx);
                    if (results != null) {
                        if (typeof results.then === 'function') {
                            const promiseResults = yield results;
                            if (promiseResults != null) {
                                return promiseResults;
                            }
                        }
                        else if (typeof results === 'string') {
                            return results;
                        }
                    }
                }
                catch (e) {
                    const d = catchError(pluginCtx.diagnostics, e);
                    d.header = `${plugin.name} load error`;
                }
            }
        }
        // default load()
        return pluginCtx.fs.readFile(id);
    });
}
function runPluginTransforms(config, compilerCtx, buildCtx, id) {
    return __awaiter$51(this, void 0, void 0, function* () {
        const pluginCtx = {
            config: config,
            sys: config.sys,
            fs: compilerCtx.fs,
            cache: compilerCtx.cache,
            diagnostics: []
        };
        const resolvedId = yield runPluginResolveId(pluginCtx, id);
        const sourceText = yield runPluginLoad(pluginCtx, resolvedId);
        const transformResults = {
            code: sourceText,
            id: id
        };
        for (const plugin of pluginCtx.config.plugins) {
            if (typeof plugin.transform === 'function') {
                try {
                    let pluginTransformResults;
                    const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);
                    if (results != null) {
                        if (typeof results.then === 'function') {
                            pluginTransformResults = yield results;
                        }
                        else {
                            pluginTransformResults = results;
                        }
                        if (pluginTransformResults != null) {
                            if (typeof pluginTransformResults === 'string') {
                                transformResults.code = pluginTransformResults;
                            }
                            else {
                                if (typeof pluginTransformResults.code === 'string') {
                                    transformResults.code = pluginTransformResults.code;
                                }
                                if (typeof pluginTransformResults.id === 'string') {
                                    transformResults.id = pluginTransformResults.id;
                                }
                            }
                        }
                    }
                }
                catch (e) {
                    const d = catchError(buildCtx.diagnostics, e);
                    d.header = `${plugin.name} transform error: ${id}`;
                }
            }
        }
        buildCtx.diagnostics.push(...pluginCtx.diagnostics);
        return transformResults;
    });
}

var __awaiter$52 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateGlobalStyles(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$52(this, void 0, void 0, function* () {
        const filePaths = config.globalStyle;
        if (!filePaths || !filePaths.length) {
            config.logger.debug(`"config.globalStyle" not found`);
            return;
        }
        const timeSpan = config.logger.createTimeSpan(`compile global style start`);
        try {
            const styles = yield Promise.all(filePaths.map(filePath => {
                return loadGlobalStyle(config, compilerCtx, buildCtx, filePath);
            }));
            const styleText = styles.join('\n').trim();
            const fileName = getGlobalStyleFilename(config);
            const filePath = pathJoin(config, outputTarget.buildDir, fileName);
            config.logger.debug(`global style: ${filePath}`);
            yield compilerCtx.fs.writeFile(filePath, styleText);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`compile global style finish`);
    });
}
function loadGlobalStyle(config, compilerCtx, buildCtx, filePath) {
    return __awaiter$52(this, void 0, void 0, function* () {
        let style = '';
        try {
            filePath = normalizePath(filePath);
            const transformResults = yield runPluginTransforms(config, compilerCtx, buildCtx, filePath);
            style = transformResults.code;
        }
        catch (e) {
            const d = buildError(buildCtx.diagnostics);
            d.messageText = `config.globalStyle ${e}`;
        }
        return style;
    });
}

var __awaiter$53 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateLoader(config, compilerCtx, outputTarget, appRegistry, cmpRegistry) {
    return __awaiter$53(this, void 0, void 0, function* () {
        const appLoaderFileName = getLoaderFileName(config);
        const clientLoaderSource = `loader.js`;
        let loaderContent = yield config.sys.getClientCoreFile({ staticName: clientLoaderSource });
        loaderContent = injectAppIntoLoader(config, outputTarget, appRegistry.core, appRegistry.corePolyfilled, config.hydratedCssClass, cmpRegistry, loaderContent);
        // write the app loader file
        // app loader file is actually different from our last saved version
        config.logger.debug(`build, app loader: ${appLoaderFileName}`);
        if (config.minifyJs) {
            // minify the loader
            const minifyJsResults = yield minifyJs(config, compilerCtx, loaderContent, 'es5', true);
            minifyJsResults.diagnostics.forEach(d => {
                config.logger[d.level](d.messageText);
            });
            if (!minifyJsResults.diagnostics.length) {
                loaderContent = minifyJsResults.output;
            }
        }
        else {
            // dev
            loaderContent = generatePreamble(config) + '\n' + loaderContent;
        }
        const appLoadPath = getLoaderPath(config, outputTarget);
        yield compilerCtx.fs.writeFile(appLoadPath, loaderContent);
        return loaderContent;
    });
}
function injectAppIntoLoader(config, outputTarget, appCoreFileName, appCorePolyfilledFileName, hydratedCssClass, cmpRegistry, loaderContent) {
    const cmpLoaderRegistry = formatBrowserLoaderComponentRegistry(cmpRegistry);
    const cmpLoaderRegistryStr = JSON.stringify(cmpLoaderRegistry);
    const resourcesUrl = outputTarget.resourcesUrl ? `"${outputTarget.resourcesUrl}"` : 0;
    const loaderArgs = [
        `"${config.namespace}"`,
        `"${config.fsNamespace}"`,
        `${resourcesUrl}`,
        `"${appCoreFileName}"`,
        `"${appCorePolyfilledFileName}"`,
        `"${hydratedCssClass}"`,
        cmpLoaderRegistryStr,
        'HTMLElement.prototype'
    ].join(',');
    return loaderContent.replace(APP_NAMESPACE_REGEX, loaderArgs);
}

var __awaiter$54 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateAppFiles(config, compilerCtx, buildCtx, entryModules, cmpRegistry) {
    return __awaiter$54(this, void 0, void 0, function* () {
        const outputTargets = config.outputTargets.filter(outputTarget => {
            return outputTarget.appBuild;
        });
        const timespan = config.logger.createTimeSpan(`generate app files started`);
        yield Promise.all(outputTargets.map(outputTarget => {
            return generateAppFilesOutputTarget(config, compilerCtx, buildCtx, outputTarget, entryModules, cmpRegistry);
        }));
        timespan.finish(`generate app files finished`);
    });
}
function generateAppFilesOutputTarget(config, compilerCtx, buildCtx, outputTarget, entryModules, cmpRegistry) {
    return __awaiter$54(this, void 0, void 0, function* () {
        if (!config.buildAppCore) {
            config.logger.createTimeSpan(`generate app files skipped`, true);
            return;
        }
        try {
            // generate the shared app registry object
            const appRegistry = createAppRegistry(config);
            yield Promise.all([
                // browser core esm build
                generateBrowserCoreEsm(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry),
                // browser core es5 build
                generateBrowserCoreEs5(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry),
                // core esm
                generateEsmCore(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry)
            ]);
            yield Promise.all([
                // create a json file for the app registry
                writeAppRegistry(config, compilerCtx, outputTarget, appRegistry, cmpRegistry),
                // create the loader(s) after creating the loader file name
                generateLoader(config, compilerCtx, outputTarget, appRegistry, cmpRegistry),
                // create the global styles
                generateGlobalStyles(config, compilerCtx, buildCtx, outputTarget),
                // create the custom elements file
                generateEsmHosts(config, compilerCtx, cmpRegistry, outputTarget)
            ]);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
function generateBrowserCoreEsm(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry) {
    return __awaiter$54(this, void 0, void 0, function* () {
        // browser esm core build
        const globalJsContentsEsm = yield generateAppGlobalScript(config, compilerCtx, buildCtx, appRegistry);
        // figure out which sections should be included in the core build
        const buildConditionals = yield setBuildConditionals(config, compilerCtx, 'core', buildCtx, entryModules);
        const coreFilename = yield generateCoreBrowser(config, compilerCtx, buildCtx, outputTarget, globalJsContentsEsm, buildConditionals);
        appRegistry.core = coreFilename;
    });
}
function generateBrowserCoreEs5(config, compilerCtx, buildCtx, outputTarget, entryModules, appRegistry) {
    return __awaiter$54(this, void 0, void 0, function* () {
        if (config.buildEs5) {
            // browser core es5 build
            const globalJsContentsEs5 = yield generateAppGlobalScript(config, compilerCtx, buildCtx, appRegistry, 'es5');
            const buildConditionalsEs5 = yield setBuildConditionals(config, compilerCtx, 'core.pf', buildCtx, entryModules);
            const coreFilenameEs5 = yield generateCoreBrowser(config, compilerCtx, buildCtx, outputTarget, globalJsContentsEs5, buildConditionalsEs5);
            appRegistry.corePolyfilled = coreFilenameEs5;
        }
        else {
            // not doing an es5, probably in dev mode
            appRegistry.corePolyfilled = yield generateEs5DisabledMessage(config, compilerCtx, outputTarget);
        }
    });
}

var __awaiter$55 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateBundles(config, compilerCtx, buildCtx, entryModules, jsModules) {
    return __awaiter$55(this, void 0, void 0, function* () {
        // both styles and modules are done bundling
        // combine the styles and modules together
        // generate the actual files to write
        const timeSpan = config.logger.createTimeSpan(`generate bundles started`);
        const bundleKeys = {};
        yield Promise.all(entryModules.map((entryModule) => __awaiter$55(this, void 0, void 0, function* () {
            const bundleKeyPath = `${entryModule.entryKey}.js`;
            bundleKeys[bundleKeyPath] = entryModule.entryKey;
            entryModule.modeNames = entryModule.modeNames || [];
            return Promise.all(entryModule.modeNames.map((modeName) => __awaiter$55(this, void 0, void 0, function* () {
                const jsCode = Object.keys(jsModules).reduce((all, moduleType) => {
                    return Object.assign({}, all, { [moduleType]: jsModules[moduleType][bundleKeyPath].code });
                }, {});
                return yield generateBundleMode(config, compilerCtx, buildCtx, entryModule, modeName, jsCode);
            })));
        })));
        config.logger.debug(`bundle mode finished`);
        yield Promise.all([
            genereateBrowserEsm(config, compilerCtx, jsModules, bundleKeys),
            genereateBrowserEs5(config, compilerCtx, buildCtx, jsModules, bundleKeys),
            genereateEsmEs5(config, compilerCtx, buildCtx, jsModules, bundleKeys)
        ]);
        // create the registry of all the components
        const cmpRegistry = createComponentRegistry(entryModules);
        timeSpan.finish(`generate bundles finished`);
        return cmpRegistry;
    });
}
function genereateBrowserEsm(config, compilerCtx, jsModules, bundleKeys) {
    return __awaiter$55(this, void 0, void 0, function* () {
        const esmModules = jsModules.esm;
        const esmPromises = Object.keys(esmModules)
            .filter(key => !bundleKeys[key])
            .map(key => { return [key, esmModules[key]]; })
            .map(([key, value]) => __awaiter$55(this, void 0, void 0, function* () {
            const fileName = getBrowserFilename(key.replace('.js', ''), false, 'es2017');
            const jsText = replaceBundleIdPlaceholder(value.code, key);
            yield writeBundleJSFile(config, compilerCtx, fileName, jsText);
        }));
        yield Promise.all(esmPromises);
        config.logger.debug(`generate esm finished`);
    });
}
function genereateBrowserEs5(config, compilerCtx, buildCtx, jsModules, bundleKeys) {
    return __awaiter$55(this, void 0, void 0, function* () {
        if (config.buildEs5) {
            const es5Modules = jsModules.es5;
            const es5Promises = Object.keys(es5Modules)
                .filter(key => !bundleKeys[key])
                .map(key => { return [key, es5Modules[key]]; })
                .map(([key, value]) => __awaiter$55(this, void 0, void 0, function* () {
                const fileName = getBrowserFilename(key.replace('.js', ''), false, 'es5');
                let jsText = replaceBundleIdPlaceholder(value.code, key);
                jsText = yield transpileEs5Bundle(compilerCtx, buildCtx, jsText);
                yield writeBundleJSFile(config, compilerCtx, fileName, jsText);
            }));
            yield Promise.all(es5Promises);
            config.logger.debug(`generate es5 finished`);
        }
    });
}
function genereateEsmEs5(config, compilerCtx, buildCtx, jsModules, bundleKeys) {
    return __awaiter$55(this, void 0, void 0, function* () {
        const distOutputs = config.outputTargets.filter(o => o.type === 'dist');
        if (!distOutputs.length) {
            return;
        }
        yield Promise.all(distOutputs.map((distOutput) => __awaiter$55(this, void 0, void 0, function* () {
            const es5Modules = jsModules.esmEs5;
            const es5Promises = Object.keys(es5Modules)
                .filter(key => !bundleKeys[key])
                .map(key => { return [key, es5Modules[key]]; })
                .map(([key, value]) => __awaiter$55(this, void 0, void 0, function* () {
                const fileName = getBrowserFilename(key.replace('.js', ''), false);
                let jsText = replaceBundleIdPlaceholder(value.code, key);
                jsText = yield transpileEs5Bundle(compilerCtx, buildCtx, jsText);
                const distBuildPath = pathJoin(config, getDistEsmBuildDir(config, distOutput), 'es5', fileName);
                return compilerCtx.fs.writeFile(distBuildPath, jsText);
            }));
            yield Promise.all(es5Promises);
        })));
        config.logger.debug(`generate esmEs5 finished`);
    });
}
function writeBundleJSFile(config, compilerCtx, fileName, jsText) {
    return __awaiter$55(this, void 0, void 0, function* () {
        const outputTargets = config.outputTargets.filter(outputTarget => {
            return outputTarget.appBuild;
        });
        return Promise.all(outputTargets.map(outputTarget => {
            // get the absolute path to where it'll be saved in www
            const wwwBuildPath = pathJoin(config, getAppBuildDir(config, outputTarget), fileName);
            // write to the www build
            return compilerCtx.fs.writeFile(wwwBuildPath, jsText);
        }));
    });
}
function generateBundleMode(config, compilerCtx, buildCtx, entryModule, modeName, jsCode) {
    return __awaiter$55(this, void 0, void 0, function* () {
        // create js text for: mode, no scoped styles and esm
        let jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.esm, modeName, false);
        // the only bundle id comes from mode, no scoped styles and esm
        const bundleId = getBundleId(config, entryModule, modeName, jsText);
        // assign the bundle id build from the
        // mode, no scoped styles and esm to each of the components
        entryModule.moduleFiles.forEach(moduleFile => {
            moduleFile.cmpMeta.bundleIds = moduleFile.cmpMeta.bundleIds || {};
            if (typeof moduleFile.cmpMeta.bundleIds === 'object') {
                moduleFile.cmpMeta.bundleIds[modeName] = bundleId;
            }
        });
        // generate the bundle build for mode, no scoped styles, and esm
        yield generateBundleBrowserBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, false);
        if (entryModule.requiresScopedStyles) {
            // create js text for: mode, scoped styles, esm
            jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.esm, modeName, true);
            // generate the bundle build for: mode, esm and scoped styles
            yield generateBundleBrowserBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, true);
        }
        if (config.buildEs5) {
            // create js text for: mode, no scoped styles, es5
            jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.es5, modeName, false, 'es5');
            // generate the bundle build for: mode, no scoped styles and es5
            yield generateBundleBrowserBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, false, 'es5');
            if (entryModule.requiresScopedStyles) {
                // create js text for: mode, scoped styles, es5
                jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.es5, modeName, true, 'es5');
                // generate the bundle build for: mode, es5 and scoped styles
                yield generateBundleBrowserBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, true, 'es5');
            }
        }
        if (config.outputTargets.some(o => o.type === 'dist')) {
            // esm module with es5 target, not scoped
            jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.esmEs5, modeName, false, 'es5');
            yield generateBundleEsmBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, false, 'es5');
            if (entryModule.requiresScopedStyles) {
                jsText = yield createBundleJsText(config, compilerCtx, buildCtx, entryModule, jsCode.esmEs5, modeName, true, 'es5');
                yield generateBundleEsmBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, true, 'es5');
            }
        }
    });
}
function createBundleJsText(config, compilerCtx, buildCtx, entryModules, jsText, modeName, isScopedStyles, sourceTarget) {
    return __awaiter$55(this, void 0, void 0, function* () {
        if (sourceTarget === 'es5') {
            // use legacy bundling with commonjs/jsonp modules
            // and transpile the build to es5
            jsText = yield transpileEs5Bundle(compilerCtx, buildCtx, jsText);
        }
        if (config.minifyJs) {
            // minify the bundle js text
            const minifyJsResults = yield minifyJs(config, compilerCtx, jsText, sourceTarget, true);
            if (minifyJsResults.diagnostics.length) {
                minifyJsResults.diagnostics.forEach(d => {
                    buildCtx.diagnostics.push(d);
                });
            }
            else {
                jsText = minifyJsResults.output;
            }
        }
        return injectStyleMode(entryModules.moduleFiles, jsText, modeName, isScopedStyles);
    });
}
function generateBundleBrowserBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, isScopedStyles, sourceTarget) {
    return __awaiter$55(this, void 0, void 0, function* () {
        // create the file name
        const fileName = getBrowserFilename(bundleId, isScopedStyles, sourceTarget);
        // update the bundle id placeholder with the actual bundle id
        // this is used by jsonp callbacks to know which bundle loaded
        jsText = replaceBundleIdPlaceholder(jsText, bundleId);
        const entryBundle = {
            fileName: fileName,
            text: jsText,
            outputs: [],
            modeName: modeName,
            sourceTarget: sourceTarget,
            isScopedStyles: isScopedStyles
        };
        entryModule.entryBundles = entryModule.entryBundles || [];
        entryModule.entryBundles.push(entryBundle);
        const outputTargets = config.outputTargets.filter(outputTarget => {
            return outputTarget.appBuild;
        });
        return Promise.all(outputTargets.map((outputTarget) => __awaiter$55(this, void 0, void 0, function* () {
            // get the absolute path to where it'll be saved
            const wwwBuildPath = pathJoin(config, getAppBuildDir(config, outputTarget), fileName);
            // write to the build
            yield compilerCtx.fs.writeFile(wwwBuildPath, jsText);
            entryBundle.outputs.push(wwwBuildPath);
        })));
    });
}
function generateBundleEsmBuild(config, compilerCtx, entryModule, jsText, bundleId, modeName, isScopedStyles, sourceTarget) {
    return __awaiter$55(this, void 0, void 0, function* () {
        // create the file name
        const fileName = getEsmFilename(bundleId, isScopedStyles);
        // update the bundle id placeholder with the actual bundle id
        // this is used by jsonp callbacks to know which bundle loaded
        jsText = replaceBundleIdPlaceholder(jsText, bundleId);
        const entryBundle = {
            fileName: fileName,
            text: jsText,
            outputs: [],
            modeName: modeName,
            sourceTarget: sourceTarget,
            isScopedStyles: isScopedStyles
        };
        entryModule.entryBundles = entryModule.entryBundles || [];
        entryModule.entryBundles.push(entryBundle);
        const outputTargets = config.outputTargets.filter(o => o.type === 'dist');
        return Promise.all(outputTargets.map((outputTarget) => __awaiter$55(this, void 0, void 0, function* () {
            // get the absolute path to where it'll be saved
            const esmBuildPath = pathJoin(config, getDistEsmBuildDir(config, outputTarget), 'es5', fileName);
            // write to the build
            yield compilerCtx.fs.writeFile(esmBuildPath, jsText);
            entryBundle.outputs.push(esmBuildPath);
        })));
    });
}
function injectStyleMode(moduleFiles, jsText, modeName, isScopedStyles) {
    moduleFiles.forEach(moduleFile => {
        jsText = injectComponentStyleMode(moduleFile.cmpMeta, modeName, jsText, isScopedStyles);
    });
    return jsText;
}
function injectComponentStyleMode(cmpMeta, modeName, jsText, isScopedStyles) {
    const stylePlaceholder = getStylePlaceholder(cmpMeta.tagNameMeta);
    const stylePlaceholderId = getStyleIdPlaceholder(cmpMeta.tagNameMeta);
    let styleText = '';
    if (cmpMeta.stylesMeta) {
        let modeStyles = cmpMeta.stylesMeta[modeName];
        if (modeStyles) {
            if (isScopedStyles) {
                // we specifically want scoped css
                styleText = modeStyles.compiledStyleTextScoped;
            }
            if (!styleText) {
                // either we don't want scoped css
                // or we DO want scoped css, but we don't have any
                // use the un-scoped css
                styleText = modeStyles.compiledStyleText || '';
            }
        }
        else {
            modeStyles = cmpMeta.stylesMeta[DEFAULT_STYLE_MODE];
            if (modeStyles) {
                if (isScopedStyles) {
                    // we specifically want scoped css
                    styleText = modeStyles.compiledStyleTextScoped;
                }
                if (!styleText) {
                    // either we don't want scoped css
                    // or we DO want scoped css, but we don't have any
                    // use the un-scoped css
                    styleText = modeStyles.compiledStyleText || '';
                }
            }
        }
    }
    // replace the style placeholder string that's already in the js text
    jsText = jsText.replace(stylePlaceholder, styleText);
    // replace the style id placeholder string that's already in the js text
    jsText = jsText.replace(stylePlaceholderId, modeName);
    // return the js text with the newly inject style
    return jsText;
}
function transpileEs5Bundle(compilerCtx, buildCtx, jsText) {
    return __awaiter$55(this, void 0, void 0, function* () {
        // use typescript to convert this js text into es5
        const transpileResults = yield transpileToEs5(compilerCtx, jsText);
        if (transpileResults.diagnostics && transpileResults.diagnostics.length > 0) {
            buildCtx.diagnostics.push(...transpileResults.diagnostics);
        }
        if (hasError(transpileResults.diagnostics)) {
            return jsText;
        }
        return transpileResults.code;
    });
}
function getBundleId(config, entryModule, modeName, jsText) {
    if (config.hashFileNames) {
        // create style id from hashing the content
        return config.sys.generateContentHash(jsText, config.hashedFileNameLength);
    }
    return getBundleIdDev(entryModule, modeName);
}
function getBundleIdDev(entryModule, modeName) {
    const tags = entryModule.moduleFiles
        .sort((a, b) => {
        if (a.isCollectionDependency && !b.isCollectionDependency) {
            return 1;
        }
        if (!a.isCollectionDependency && b.isCollectionDependency) {
            return -1;
        }
        if (a.cmpMeta.tagNameMeta < b.cmpMeta.tagNameMeta)
            return -1;
        if (a.cmpMeta.tagNameMeta > b.cmpMeta.tagNameMeta)
            return 1;
        return 0;
    })
        .map(m => m.cmpMeta.tagNameMeta);
    if (modeName === DEFAULT_STYLE_MODE || !modeName) {
        return tags[0];
    }
    return `${tags[0]}.${modeName}`;
}
function createComponentRegistry(entryModules) {
    const registryComponents = [];
    const cmpRegistry = {};
    return entryModules
        .reduce((rcs, bundle) => {
        const cmpMetas = bundle.moduleFiles
            .filter(m => m.cmpMeta)
            .map(moduleFile => moduleFile.cmpMeta);
        return rcs.concat(cmpMetas);
    }, registryComponents)
        .sort((a, b) => {
        if (a.tagNameMeta < b.tagNameMeta)
            return -1;
        if (a.tagNameMeta > b.tagNameMeta)
            return 1;
        return 0;
    })
        .reduce((registry, cmpMeta) => {
        return Object.assign({}, registry, { [cmpMeta.tagNameMeta]: cmpMeta });
    }, cmpRegistry);
}

function getComponentRefsFromSourceStrings(allModuleFiles, buildCtx) {
    const componentRefs = [];
    const tags = Object.keys(allModuleFiles)
        .map(filePath => allModuleFiles[filePath].cmpMeta)
        .filter(cmpMeta => cmpMeta && cmpMeta.tagNameMeta)
        .map(cmpMeta => cmpMeta.tagNameMeta);
    buildCtx.componentRefs.forEach(src => {
        if (typeof src.tag === 'string') {
            src.tag = src.tag.toLowerCase();
            if (!buildCtx.hasSlot) {
                buildCtx.hasSlot = src.tag === 'slot';
            }
            if (!buildCtx.hasSvg) {
                buildCtx.hasSvg = src.tag === 'svg';
            }
            if (tags.some(tag => src.tag === tag)) {
                // exact match, we're good
                // probably something like h('ion-button') or
                // document.createElement('ion-toggle');
                componentRefs.push({
                    tag: src.tag,
                    filePath: src.filePath
                });
            }
        }
        else if (typeof src.html === 'string') {
            // string could be HTML
            // could be something like elm.innerHTML = '<ion-button>';
            // replace any whitespace with a ~ character
            // this is especially important for newlines and tabs
            // for tag with attributes and has a newline in the tag
            src.html = src.html.toLowerCase().replace(/\s/g, '~');
            const foundTags = tags.filter(tag => {
                return src.html.includes('<' + tag + '>') ||
                    src.html.includes('</' + tag + '>') ||
                    src.html.includes('<' + tag + '~');
            });
            foundTags.forEach(foundTag => {
                componentRefs.push({
                    tag: foundTag,
                    filePath: src.filePath
                });
            });
            if (!buildCtx.hasSlot) {
                buildCtx.hasSlot = src.html.includes('<slot>') ||
                    src.html.includes('</slot>') ||
                    src.html.includes('<slot~');
            }
            if (!buildCtx.hasSvg) {
                buildCtx.hasSvg = src.html.includes('<svg>') ||
                    src.html.includes('</svg>') ||
                    src.html.includes('<svg~');
            }
        }
    });
    buildCtx.componentRefs.length = 0;
    return componentRefs;
}

function calcModuleGraphImportPaths(compilerCtx, moduleGraphs) {
    // figure out the actual source's file path
    // cuz right now the import paths probably don't have the extension on them
    moduleGraphs.forEach(mg => {
        mg.importPaths = mg.importPaths.map(importPath => {
            if (importPath.startsWith('.') || importPath.startsWith('/')) {
                for (const srcExt of SRC_EXTS) {
                    const srcFilePath = importPath + srcExt;
                    if (compilerCtx.moduleFiles[srcFilePath]) {
                        return srcFilePath;
                    }
                }
            }
            return importPath;
        });
    });
}
const SRC_EXTS = ['.tsx', '.ts', '.js'];
function calcComponentDependencies(allModuleFiles, buildCtx) {
    // figure out all the component references seen in each file
    const componentRefs = getComponentRefsFromSourceStrings(allModuleFiles, buildCtx);
    Object.keys(allModuleFiles).forEach(filePath => {
        const moduleFile = allModuleFiles[filePath];
        if (moduleFile.cmpMeta) {
            getComponentDependencies(buildCtx.moduleGraphs, componentRefs, filePath, moduleFile.cmpMeta);
        }
    });
}
function getComponentDependencies(moduleGraphs, componentRefs, filePath, cmpMeta) {
    // we may have already figured out some dependencies (collections aready have this info)
    cmpMeta.dependencies = cmpMeta.dependencies || [];
    // figure out if this file has any components in it
    const refTags = componentRefs.filter(cr => cr.filePath === filePath).map(cr => cr.tag);
    refTags.forEach(tag => {
        if (tag !== cmpMeta.tagNameMeta && !cmpMeta.dependencies.includes(tag)) {
            cmpMeta.dependencies.push(tag);
        }
    });
    const importsInspected = [];
    const moduleGraph = moduleGraphs.find(mg => mg.filePath === filePath);
    if (moduleGraph) {
        getComponentDepsFromImports(moduleGraphs, componentRefs, importsInspected, moduleGraph, cmpMeta);
    }
    cmpMeta.dependencies.sort();
}
function getComponentDepsFromImports(moduleGraphs, componentRefs, importsInspected, moduleGraph, cmpMeta) {
    moduleGraph.importPaths.forEach(importPath => {
        if (importsInspected.includes(importPath)) {
            return;
        }
        importsInspected.push(importPath);
        const subModuleGraph = moduleGraphs.find(mg => {
            return (mg.filePath === importPath) ||
                (mg.filePath === importPath + '.ts') ||
                (mg.filePath === importPath + '.tsx') ||
                (mg.filePath === importPath + '.js');
        });
        if (subModuleGraph) {
            const tags = componentRefs.filter(cr => cr.filePath === subModuleGraph.filePath).map(cr => cr.tag);
            tags.forEach(tag => {
                if (!cmpMeta.dependencies.includes(tag)) {
                    cmpMeta.dependencies.push(tag);
                }
            });
            getComponentDepsFromImports(moduleGraphs, componentRefs, importsInspected, subModuleGraph, cmpMeta);
        }
    });
}

function processAppGraph(allModules, entryTags) {
    const graph = getGraph(allModules, entryTags);
    const entryPoints = [];
    for (const graphEntry of graph) {
        if (entryPoints.some(en => en.some(ec => ec.tag === graphEntry.tag))) {
            // already handled this one
            continue;
        }
        const depsOf = graph.filter(d => d.dependencies.includes(graphEntry.tag));
        if (depsOf.length > 1) {
            const commonEntryCmps = [];
            depsOf.forEach(depOf => {
                depOf.dependencies.forEach(depTag => {
                    if (depsOf.every(d => d.dependencies.includes(depTag))) {
                        const existingCommonEntryCmp = commonEntryCmps.find(ec => {
                            return ec.tag === depTag;
                        });
                        if (existingCommonEntryCmp) {
                            existingCommonEntryCmp.dependencyOf.push(depOf.tag);
                        }
                        else {
                            commonEntryCmps.push({
                                tag: depTag,
                                dependencyOf: [depOf.tag]
                            });
                        }
                    }
                });
            });
            const existingEntryPoint = entryPoints.find(ep => {
                return ep.some(ec => commonEntryCmps.some(cec => cec.tag === ec.tag));
            });
            if (existingEntryPoint) {
                const depsOf = graph.filter(d => d.dependencies.includes(graphEntry.tag));
                if (depsOf.length > 0) {
                    const existingEntryPointDepOf = entryPoints.find(ep => ep.some(ec => depsOf.some(d => d.dependencies.includes(ec.tag))));
                    if (existingEntryPointDepOf) {
                        existingEntryPointDepOf.push({
                            tag: graphEntry.tag,
                            dependencyOf: depsOf.map(d => d.tag)
                        });
                    }
                    else {
                        entryPoints.push([
                            {
                                tag: graphEntry.tag,
                                dependencyOf: []
                            }
                        ]);
                    }
                }
                else {
                    entryPoints.push([
                        {
                            tag: graphEntry.tag,
                            dependencyOf: []
                        }
                    ]);
                }
            }
            else {
                entryPoints.push(commonEntryCmps);
            }
        }
        else if (depsOf.length === 1) {
            const existingEntryPoint = entryPoints.find(ep => ep.some(ec => ec.tag === depsOf[0].tag));
            if (existingEntryPoint) {
                existingEntryPoint.push({
                    tag: graphEntry.tag,
                    dependencyOf: [depsOf[0].tag]
                });
            }
            else {
                entryPoints.push([
                    {
                        tag: depsOf[0].tag,
                        dependencyOf: []
                    },
                    {
                        tag: graphEntry.tag,
                        dependencyOf: [depsOf[0].tag]
                    }
                ]);
            }
        }
        else {
            entryPoints.push([
                {
                    tag: graphEntry.tag,
                    dependencyOf: []
                }
            ]);
        }
    }
    entryPoints.forEach(entryPoint => {
        entryPoint.forEach(entryCmp => {
            entryCmp.dependencyOf.sort();
        });
        entryPoint.sort((a, b) => {
            if (a.tag < b.tag)
                return -1;
            if (a.tag > b.tag)
                return 1;
            return 0;
        });
    });
    entryPoints.sort((a, b) => {
        if (a[0].tag < b[0].tag)
            return -1;
        if (a[0].tag > b[0].tag)
            return 1;
        return 0;
    });
    return entryPoints;
}
function getGraph(allModules, entryTags) {
    const graph = [];
    function addDeps(tag) {
        if (graph.some(d => d.tag === tag)) {
            return;
        }
        const m = allModules.find(m => m.cmpMeta && m.cmpMeta.tagNameMeta === tag);
        if (!m) {
            throw new Error(`processAppGraph, unable to find tag: ${tag}`);
        }
        m.cmpMeta.dependencies = (m.cmpMeta.dependencies || []);
        const dependencies = m.cmpMeta.dependencies.filter(t => t !== tag).sort();
        graph.push({
            tag: tag,
            dependencies: dependencies
        });
        dependencies.forEach(addDeps);
    }
    entryTags.forEach(addDeps);
    return graph;
}

function generateComponentEntries(allModules, userConfigEntryTags, appEntryTags) {
    // user config entry modules you leave as is
    // whatever the user put in the bundle is how it goes
    const entryPoints = [];
    const userConfigEntryPoints = processUserConfigBundles(userConfigEntryTags);
    entryPoints.push(...userConfigEntryPoints);
    // process all of the app's components not already found
    // in the config or the root html
    const appEntries = processAppComponentEntryTags(allModules, entryPoints, appEntryTags);
    entryPoints.push(...appEntries);
    return entryPoints;
}
function processAppComponentEntryTags(allModules, entryPoints, appEntryTags) {
    // remove any tags already found in user config
    appEntryTags = appEntryTags.filter(tag => !entryPoints.some(ep => ep.some(em => em.tag === tag)));
    return processAppGraph(allModules, appEntryTags);
}
function processUserConfigBundles(userConfigEntryTags) {
    return userConfigEntryTags.map(entryTags => {
        return entryTags.map(entryTag => {
            const entryComponent = {
                tag: entryTag,
                dependencyOf: ['#config']
            };
            return entryComponent;
        });
    });
}

/**
 * This file is a port of shadow_css.ts from Angular,
 * which is a port of shadowCSS from webcomponents.js to TypeScript.
 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */
/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsulation: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to implement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/
class ShadowCss {
    constructor() {
        this.strictStyling = true;
    }
    /*
    * Shim some cssText with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    *
    * When strictStyling is true:
    * - selector is the attribute added to all elements inside the host,
    * - hostSelector is the attribute added to the host itself.
    */
    shimCssText(cssText, selector, hostSelector = '', slotSelector = '') {
        const sourceMappingUrl = extractSourceMappingUrl(cssText);
        cssText = stripComments(cssText);
        cssText = this._insertDirectives(cssText);
        return this._scopeCssText(cssText, selector, hostSelector, slotSelector) + sourceMappingUrl;
    }
    _insertDirectives(cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
    }
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
    **/
    _insertPolyfillDirectivesInCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        return cssText.replace(_cssContentNextSelectorRe, function (...m) { return m[2] + '{'; });
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
    **/
    _insertPolyfillRulesInCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        return cssText.replace(_cssContentRuleRe, (...m) => {
            const rule = m[0].replace(m[1], '').replace(m[2], '');
            return m[4] + rule;
        });
    }
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
    */
    _scopeCssText(cssText, scopeSelector, hostSelector, slotSelector) {
        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertColonSlotted(cssText, slotSelector);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (scopeSelector) {
            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector, slotSelector);
        }
        cssText = cssText + '\n' + unscopedRules;
        cssText = cssText.replace(/-shadowcsshost-no-combinator/g, `[${hostSelector}]`);
        return cssText.trim();
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
    **/
    _extractUnscopedRulesFromCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        let r = '';
        let m;
        _cssContentUnscopedRuleRe.lastIndex = 0;
        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
            r += rule + '\n\n';
        }
        return r;
    }
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar
    */
    _convertColonHost(cssText) {
        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    }
    /*
     * convert a rule like ::slotted(.foo) { }
    */
    _convertColonSlotted(cssText, slotAttr) {
        const regExp = _cssColonSlottedRe;
        return cssText.replace(regExp, function (...m) {
            if (m[2]) {
                const compound = m[2].trim();
                const suffix = m[3];
                const sel = '[' + slotAttr + '] > ' + compound + suffix;
                return sel;
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    }
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar, .foo scopeName > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * .foo<scopeName> .bar { ... }
    */
    _convertColonHostContext(cssText) {
        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    }
    _convertColonRule(cssText, regExp, partReplacer) {
        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
        return cssText.replace(regExp, function (...m) {
            if (m[2]) {
                const parts = m[2].split(',');
                const r = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i].trim();
                    if (!p)
                        break;
                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    }
    _colonHostContextPartReplacer(host, part, suffix) {
        if (part.indexOf(_polyfillHost) > -1) {
            return this._colonHostPartReplacer(host, part, suffix);
        }
        else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
        }
    }
    _colonHostPartReplacer(host, part, suffix) {
        return host + part.replace(_polyfillHost, '') + suffix;
    }
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
    */
    _convertShadowDOMSelectors(cssText) {
        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
    }
    // change a selector like 'div' to 'name div'
    _scopeSelectors(cssText, scopeSelector, hostSelector, slotSelector) {
        return processRules(cssText, (rule) => {
            let selector = rule.selector;
            let content = rule.content;
            if (rule.selector[0] !== '@') {
                selector =
                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, slotSelector, this.strictStyling);
            }
            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector, slotSelector);
            }
            return new CssRule(selector, content);
        });
    }
    _scopeSelector(selector, scopeSelector, hostSelector, slotSelector, strict) {
        return selector.split(',')
            .map(part => part.trim().split(_shadowDeepSelectors))
            .map((deepParts) => {
            const [shallowPart, ...otherParts] = deepParts;
            const applyScope = (shallowPart) => {
                if (shallowPart.indexOf('[' + slotSelector + ']') > -1) {
                    return shallowPart;
                }
                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                    return strict ?
                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                }
                else {
                    return shallowPart;
                }
            };
            return [applyScope(shallowPart), ...otherParts].join(' ');
        })
            .join(', ');
    }
    _selectorNeedsScoping(selector, scopeSelector) {
        const re = this._makeScopeMatcher(scopeSelector);
        return !re.test(selector);
    }
    _makeScopeMatcher(scopeSelector) {
        const lre = /\[/g;
        const rre = /\]/g;
        scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    }
    _applySelectorScope(selector, scopeSelector, hostSelector) {
        // Difference from webcomponents.js: scopeSelector could not be an array
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    }
    // scope via name and [is=name]
    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
        _polyfillHostRe.lastIndex = 0;
        if (_polyfillHostRe.test(selector)) {
            const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
            return selector
                .replace(_polyfillHostNoCombinatorRe, (_, selector) => {
                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                    return before + replaceBy + colon + after;
                });
            })
                .replace(_polyfillHostRe, replaceBy + ' ');
        }
        return scopeSelector + ' ' + selector;
    }
    // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
        const isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
        const attrName = '[' + scopeSelector + ']';
        const _scopeSelectorPart = (p) => {
            let scopedP = p.trim();
            if (!scopedP) {
                return '';
            }
            if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
            }
            else {
                // remove :host since it should be unnecessary
                const t = p.replace(_polyfillHostRe, '');
                if (t.length > 0) {
                    const matches = t.match(/([^:]*)(:*)(.*)/);
                    if (matches) {
                        scopedP = matches[1] + attrName + matches[2] + matches[3];
                    }
                }
            }
            return scopedP;
        };
        const safeContent = new SafeSelector(selector);
        selector = safeContent.content();
        let scopedSelector = '';
        let startIndex = 0;
        let res;
        const sep = /( |>|\+|~(?!=))\s*/g;
        const scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
        while ((res = sep.exec(selector)) !== null) {
            const separator = res[1];
            const part = selector.slice(startIndex, res.index).trim();
            // if a selector appears before :host-context it should not be shimmed as it
            // matches on ancestor elements and not on elements in the host's shadow
            const scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
            scopedSelector += `${scopedPart} ${separator} `;
            startIndex = sep.lastIndex;
        }
        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
        // replace the placeholders with their original values
        return safeContent.restore(scopedSelector);
    }
    _insertPolyfillHostInCssText(selector) {
        return selector
            .replace(_colonHostContextRe, _polyfillHostContext)
            .replace(_colonHostRe, _polyfillHost)
            .replace(_colonSlottedRe, _polyfillSlotted);
    }
}
class SafeSelector {
    constructor(selector) {
        this.placeholders = [];
        this.index = 0;
        // Replaces attribute selectors with placeholders.
        // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
        selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
            const replaceBy = `__ph-${this.index}__`;
            this.placeholders.push(keep);
            this.index++;
            return replaceBy;
        });
        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
        // WS and "+" would otherwise be interpreted as selector separators.
        this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
            const replaceBy = `__ph-${this.index}__`;
            this.placeholders.push(exp);
            this.index++;
            return pseudo + replaceBy;
        });
    }
    restore(content) {
        return content.replace(/__ph-(\d+)__/g, (_, index) => this.placeholders[+index]);
    }
    content() { return this._content; }
}
const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
const _polyfillHost = '-shadowcsshost';
const _polyfillSlotted = '-shadowcssslotted';
// note: :host-context pre-processed to -shadowcsshostcontext.
const _polyfillHostContext = '-shadowcsscontext';
const _parenSuffix = ')(?:\\((' +
    '(?:\\([^)(]*\\)|[^)(]*)+?' +
    ')\\))?([^,{]*)';
const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
const _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
const _shadowDOMSelectorsRe = [
    /::shadow/g,
    /::content/g,
    // Deprecated selectors
    /\/shadow-deep\//g,
    /\/shadow\//g,
];
// The deep combinator is deprecated in the CSS spec
// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
// see https://github.com/angular/angular/pull/17677
const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
const _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
const _polyfillHostRe = /-shadowcsshost/gim;
const _colonHostRe = /:host/gim;
const _colonSlottedRe = /::slotted/gim;
const _colonHostContextRe = /:host-context/gim;
const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
function stripComments(input) {
    return input.replace(_commentRe, '');
}
// all comments except inline source mapping
const _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
function extractSourceMappingUrl(input) {
    const matcher = input.match(_sourceMappingUrlRe);
    return matcher ? matcher[0] : '';
}
const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
const _curlyRe = /([{}])/g;
const OPEN_CURLY = '{';
const CLOSE_CURLY = '}';
const BLOCK_PLACEHOLDER = '%BLOCK%';
class CssRule {
    constructor(selector, content) {
        this.selector = selector;
        this.content = content;
    }
}
function processRules(input, ruleCallback) {
    const inputWithEscapedBlocks = escapeBlocks(input);
    let nextBlockIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {
        const selector = m[2];
        let content = '';
        let suffix = m[4];
        let contentPrefix = '';
        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
            contentPrefix = '{';
        }
        const rule = ruleCallback(new CssRule(selector, content));
        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
    });
}
class StringWithEscapedBlocks {
    constructor(escapedString, blocks) {
        this.escapedString = escapedString;
        this.blocks = blocks;
    }
}
function escapeBlocks(input) {
    const inputParts = input.split(_curlyRe);
    const resultParts = [];
    const escapedBlocks = [];
    let bracketCount = 0;
    let currentBlockParts = [];
    for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
        const part = inputParts[partIndex];
        if (part === CLOSE_CURLY) {
            bracketCount--;
        }
        if (bracketCount > 0) {
            currentBlockParts.push(part);
        }
        else {
            if (currentBlockParts.length > 0) {
                escapedBlocks.push(currentBlockParts.join(''));
                resultParts.push(BLOCK_PLACEHOLDER);
                currentBlockParts = [];
            }
            resultParts.push(part);
        }
        if (part === OPEN_CURLY) {
            bracketCount++;
        }
    }
    if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
}

function scopeComponentCss(buildCtx, cmpMeta, cssText) {
    try {
        const scopeAttribute = getScopeAttribute(cmpMeta);
        const hostScopeAttr = getHostScopeAttribute(cmpMeta);
        const slotScopeAttr = getSlotScopeAttribute(cmpMeta);
        cssText = scopeCss(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr);
    }
    catch (e) {
        catchError(buildCtx.diagnostics, e);
    }
    return cssText;
}
function scopeCss(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr) {
    const sc = new ShadowCss();
    return sc.shimCssText(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr);
}
function getScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}`;
}
function getHostScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}-host`;
}
function getSlotScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}-slot`;
}

var __awaiter$56 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateStyles(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$56(this, void 0, void 0, function* () {
        config.logger.debug(`generate styles started`);
        yield Promise.all(entryModules.map((bundle) => __awaiter$56(this, void 0, void 0, function* () {
            yield Promise.all(bundle.moduleFiles.map((moduleFile) => __awaiter$56(this, void 0, void 0, function* () {
                yield generateComponentStyles(config, compilerCtx, buildCtx, moduleFile);
            })));
        })));
        config.logger.debug(`generate styles ended`);
    });
}
function generateComponentStyles(config, compilerCtx, buildCtx, moduleFile) {
    return __awaiter$56(this, void 0, void 0, function* () {
        const stylesMeta = moduleFile.cmpMeta.stylesMeta = moduleFile.cmpMeta.stylesMeta || {};
        yield Promise.all(Object.keys(stylesMeta).map((modeName) => __awaiter$56(this, void 0, void 0, function* () {
            // compile each style mode's sass/css
            const styles = yield compileStyles(config, compilerCtx, buildCtx, moduleFile, stylesMeta[modeName]);
            // format and set the styles for use later
            yield setStyleText(config, compilerCtx, buildCtx, moduleFile.cmpMeta, stylesMeta[modeName], styles);
        })));
    });
}
function compileStyles(config, compilerCtx, buildCtx, moduleFile, styleMeta) {
    return __awaiter$56(this, void 0, void 0, function* () {
        const extStylePaths = styleMeta.externalStyles.map(extStyle => {
            return extStyle.absolutePath;
        });
        if (typeof styleMeta.styleStr === 'string') {
            // plain styles just in a string
            // let's put these file in an in-memory file
            const inlineAbsPath = moduleFile.jsFilePath + '.css';
            extStylePaths.push(inlineAbsPath);
            yield compilerCtx.fs.writeFile(inlineAbsPath, styleMeta.styleStr, { inMemoryOnly: true });
        }
        const styles = yield Promise.all(extStylePaths.map(extStylePath => {
            return compileExternalStyle(config, compilerCtx, buildCtx, moduleFile, extStylePath);
        }));
        return styles;
    });
}
function compileExternalStyle(config, compilerCtx, buildCtx, moduleFile, extStylePath) {
    return __awaiter$56(this, void 0, void 0, function* () {
        extStylePath = normalizePath(extStylePath);
        if (moduleFile.isCollectionDependency) {
            // if it's a collection dependency and it's a preprocessor file like sass
            // AND we have the correct plugin then let's compile it
            const hasPlugin = hasPluginInstalled(config, extStylePath);
            if (!hasPlugin) {
                // the collection has this style as a preprocessor file, like sass
                // however the user doesn't have this plugin installed, which is file
                // instead of using the preprocessor file (sass) use the vanilla css file
                const parts = extStylePath.split('.');
                parts[parts.length - 1] = 'css';
                extStylePath = parts.join('.');
            }
        }
        else {
            // not a collection dependency
            // check known extensions just for a helpful message
            checkPluginHelpers(config, buildCtx, extStylePath);
        }
        const transformResults = yield runPluginTransforms(config, compilerCtx, buildCtx, extStylePath);
        if (!moduleFile.isCollectionDependency) {
            const collectionDirs = config.outputTargets.filter(o => o.collectionDir);
            const relPath = config.sys.path.relative(config.srcDir, transformResults.id);
            yield Promise.all(collectionDirs.map((outputTarget) => __awaiter$56(this, void 0, void 0, function* () {
                const collectionPath = config.sys.path.join(outputTarget.collectionDir, relPath);
                yield compilerCtx.fs.writeFile(collectionPath, transformResults.code);
            })));
        }
        return transformResults.code;
    });
}
function checkPluginHelpers(config, buildCtx, externalStylePath) {
    PLUGIN_HELPERS.forEach(p => {
        checkPluginHelper(config, buildCtx, externalStylePath, p.pluginExts, p.pluginId, p.pluginName);
    });
}
function checkPluginHelper(config, buildCtx, externalStylePath, pluginExts, pluginId, pluginName) {
    if (!hasFileExtension(externalStylePath, pluginExts)) {
        return;
    }
    if (config.plugins.some(p => p.name === pluginId)) {
        return;
    }
    const errorKey = 'styleError' + pluginId;
    if (buildCtx.data[errorKey]) {
        // already added this key
        return;
    }
    buildCtx.data[errorKey] = true;
    const relPath = config.sys.path.relative(config.rootDir, externalStylePath);
    const msg = [
        `Style "${relPath}" is a ${pluginName} file, however the "${pluginId}" `,
        `plugin has not been installed. Please install the "@stencil/${pluginId}" `,
        `plugin and add it to "config.plugins" within the project's stencil.config.js `,
        `file. For more info please see: https://www.npmjs.com/package/@stencil/${pluginId}`
    ].join('');
    const d = buildError(buildCtx.diagnostics);
    d.header = 'style error';
    d.messageText = msg;
}
function hasPluginInstalled(config, filePath) {
    // TODO: don't hard these
    const plugin = PLUGIN_HELPERS.find(p => hasFileExtension(filePath, p.pluginExts));
    if (plugin) {
        return config.plugins.some(p => p.name === plugin.pluginId);
    }
    return false;
}
function setStyleText(config, compilerCtx, buildCtx, cmpMeta, styleMeta, styles) {
    return __awaiter$56(this, void 0, void 0, function* () {
        // join all the component's styles for this mode together into one line
        styleMeta.compiledStyleText = styles.join('\n\n').trim();
        // auto add css prefixes
        const autoprefixConfig = config.autoprefixCss;
        if (autoprefixConfig !== false) {
            styleMeta.compiledStyleText = yield config.sys.autoprefixCss(styleMeta.compiledStyleText, autoprefixConfig);
        }
        // minify css
        if (config.minifyCss) {
            styleMeta.compiledStyleText = yield minifyStyle(config, compilerCtx, buildCtx.diagnostics, styleMeta.compiledStyleText);
        }
        if (requiresScopedStyles(cmpMeta.encapsulation)) {
            // only create scoped styles if we need to
            styleMeta.compiledStyleTextScoped = scopeComponentCss(buildCtx, cmpMeta, styleMeta.compiledStyleText);
        }
        styleMeta.compiledStyleText = escapeCssForJs(styleMeta.compiledStyleText);
        if (styleMeta.compiledStyleTextScoped) {
            styleMeta.compiledStyleTextScoped = escapeCssForJs(styleMeta.compiledStyleTextScoped);
        }
    });
}
function escapeCssForJs(style) {
    return style
        .replace(/\\[\D0-7]/g, (v) => '\\' + v)
        .replace(/\r\n|\r|\n/g, `\\n`)
        .replace(/\"/g, `\\"`)
        .replace(/\@/g, `\\@`);
}
function requiresScopedStyles(encapsulation) {
    return (encapsulation === 2 /* ScopedCss */ || encapsulation === 1 /* ShadowDom */);
}
const PLUGIN_HELPERS = [
    {
        pluginName: 'PostCSS',
        pluginId: 'postcss',
        pluginExts: ['pcss']
    },
    {
        pluginName: 'Sass',
        pluginId: 'sass',
        pluginExts: ['scss', 'sass']
    },
    {
        pluginName: 'Stylus',
        pluginId: 'stylus',
        pluginExts: ['styl', 'stylus']
    }, {
        pluginName: 'Less',
        pluginId: 'less',
        pluginExts: ['less']
    }
];

function validateComponentTag(tag) {
    if (typeof tag !== 'string') {
        throw new Error(`Tag "${tag}" must be a string type`);
    }
    tag = tag.trim().toLowerCase();
    if (tag.length === 0) {
        throw new Error(`Received empty tag value`);
    }
    if (tag.indexOf(' ') > -1) {
        throw new Error(`"${tag}" tag cannot contain a space`);
    }
    if (tag.indexOf(',') > -1) {
        throw new Error(`"${tag}" tag cannot be use for multiple tags`);
    }
    const invalidChars = tag.replace(/\w|-/g, '');
    if (invalidChars !== '') {
        throw new Error(`"${tag}" tag contains invalid characters: ${invalidChars}`);
    }
    if (tag.indexOf('-') === -1) {
        throw new Error(`"${tag}" tag must contain a dash (-) to work as a valid web component`);
    }
    if (tag.indexOf('--') > -1) {
        throw new Error(`"${tag}" tag cannot contain multiple dashes (--) next to each other`);
    }
    if (tag.indexOf('-') === 0) {
        throw new Error(`"${tag}" tag cannot start with a dash (-)`);
    }
    if (tag.lastIndexOf('-') === tag.length - 1) {
        throw new Error(`"${tag}" tag cannot end with a dash (-)`);
    }
    return tag;
}

function generateEntryModules(config, compilerCtx, buildCtx) {
    buildCtx.entryModules = [];
    // figure out all the actual import paths (basically which extension each import uses)
    calcModuleGraphImportPaths(compilerCtx, buildCtx.moduleGraphs);
    // figure out how modules and components connect
    calcComponentDependencies(compilerCtx.moduleFiles, buildCtx);
    try {
        const allModules = Object.keys(compilerCtx.moduleFiles).map(filePath => compilerCtx.moduleFiles[filePath]);
        const userConfigEntryModulesTags = getUserConfigEntryTags(config.bundles, allModules);
        const appEntryTags = getAppEntryTags(allModules);
        buildCtx.entryPoints = generateComponentEntries(allModules, userConfigEntryModulesTags, appEntryTags);
        const cleanedEntryModules = regroupEntryModules(allModules, buildCtx.entryPoints);
        buildCtx.entryModules = cleanedEntryModules
            .map(createEntryModule)
            .filter((entryModule, index, array) => {
            const firstIndex = array.findIndex(e => e.entryKey === entryModule.entryKey);
            return firstIndex === index;
        });
    }
    catch (e) {
        catchError(buildCtx.diagnostics, e);
    }
    return buildCtx.entryModules;
}
function getEntryEncapsulations(entryModule) {
    const encapsulations = [];
    entryModule.moduleFiles.forEach(m => {
        const encapsulation = m.cmpMeta.encapsulation || 0 /* NoEncapsulation */;
        if (!encapsulations.includes(encapsulation)) {
            encapsulations.push(encapsulation);
        }
    });
    if (encapsulations.length === 0) {
        encapsulations.push(0 /* NoEncapsulation */);
    }
    else if (encapsulations.includes(1 /* ShadowDom */) && !encapsulations.includes(2 /* ScopedCss */)) {
        encapsulations.push(2 /* ScopedCss */);
    }
    return encapsulations.sort();
}
function getEntryModes(moduleFiles) {
    const styleModeNames = [];
    moduleFiles.forEach(m => {
        const cmpStyleModes = getComponentStyleModes(m.cmpMeta);
        cmpStyleModes.forEach(modeName => {
            if (!styleModeNames.includes(modeName)) {
                styleModeNames.push(modeName);
            }
        });
    });
    if (styleModeNames.length === 0) {
        styleModeNames.push(DEFAULT_STYLE_MODE);
    }
    else if (styleModeNames.length > 1) {
        const index = (styleModeNames.indexOf(DEFAULT_STYLE_MODE));
        if (index > -1) {
            styleModeNames.splice(index, 1);
        }
    }
    return styleModeNames.sort();
}
function getComponentStyleModes(cmpMeta) {
    return (cmpMeta && cmpMeta.stylesMeta) ? Object.keys(cmpMeta.stylesMeta) : [];
}
function entryRequiresScopedStyles(encapsulations) {
    return encapsulations.some(e => requiresScopedStyles(e));
}
function regroupEntryModules(allModules, entryPoints) {
    const outtedNoEncapsulation = [];
    const outtedScopedCss = [];
    const outtedShadowDom = [];
    const cleanedEntryModules = [
        outtedNoEncapsulation,
        outtedScopedCss,
        outtedShadowDom
    ];
    entryPoints.forEach(entryPoint => {
        const entryModules = allModules.filter(m => {
            return entryPoint.some(ep => m.cmpMeta && ep.tag === m.cmpMeta.tagNameMeta);
        });
        const noEncapsulation = entryModules.filter(m => {
            return m.cmpMeta.encapsulation !== 2 /* ScopedCss */ && m.cmpMeta.encapsulation !== 1 /* ShadowDom */;
        });
        const scopedCss = entryModules.filter(m => {
            return m.cmpMeta.encapsulation === 2 /* ScopedCss */;
        });
        const shadowDom = entryModules.filter(m => {
            return m.cmpMeta.encapsulation === 1 /* ShadowDom */;
        });
        if ((noEncapsulation.length > 0 && scopedCss.length === 0 && shadowDom.length === 0) ||
            (noEncapsulation.length === 0 && scopedCss.length > 0 && shadowDom.length === 0) ||
            (noEncapsulation.length === 0 && scopedCss.length === 0 && shadowDom.length > 0)) {
            cleanedEntryModules.push(entryModules);
        }
        else if (noEncapsulation.length >= scopedCss.length && noEncapsulation.length >= shadowDom.length) {
            cleanedEntryModules.push(noEncapsulation);
            outtedScopedCss.push(...scopedCss);
            outtedShadowDom.push(...shadowDom);
        }
        else if (scopedCss.length >= noEncapsulation.length && scopedCss.length >= shadowDom.length) {
            cleanedEntryModules.push(scopedCss);
            outtedNoEncapsulation.push(...noEncapsulation);
            outtedShadowDom.push(...shadowDom);
        }
        else if (shadowDom.length >= noEncapsulation.length && shadowDom.length >= scopedCss.length) {
            cleanedEntryModules.push(shadowDom);
            outtedNoEncapsulation.push(...noEncapsulation);
            outtedScopedCss.push(...scopedCss);
        }
    });
    return cleanedEntryModules
        .filter(m => m.length > 0)
        .sort((a, b) => {
        if (a[0].cmpMeta.tagNameMeta < b[0].cmpMeta.tagNameMeta)
            return -1;
        if (a[0].cmpMeta.tagNameMeta > b[0].cmpMeta.tagNameMeta)
            return 1;
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
}
function createEntryModule(moduleFiles) {
    const entryModule = {
        moduleFiles: moduleFiles
    };
    // generate a unique entry key based on the components within this entry module
    entryModule.entryKey = 'entry:' + entryModule.moduleFiles
        .sort((a, b) => {
        if (a.isCollectionDependency && !b.isCollectionDependency) {
            return 1;
        }
        if (!a.isCollectionDependency && b.isCollectionDependency) {
            return -1;
        }
        if (a.cmpMeta.tagNameMeta < b.cmpMeta.tagNameMeta)
            return -1;
        if (a.cmpMeta.tagNameMeta > b.cmpMeta.tagNameMeta)
            return 1;
        return 0;
    })
        .map(m => {
        return m.cmpMeta.tagNameMeta;
    }).join('.');
    // get the modes used in this bundle
    entryModule.modeNames = getEntryModes(entryModule.moduleFiles);
    // get the encapsulations used in this bundle
    const encapsulations = getEntryEncapsulations(entryModule);
    // figure out if we'll need a scoped css build
    entryModule.requiresScopedStyles = entryRequiresScopedStyles(encapsulations);
    return entryModule;
}
function getAppEntryTags(allModules) {
    return allModules
        .filter(m => m.cmpMeta && !m.isCollectionDependency)
        .map(m => m.cmpMeta.tagNameMeta)
        .sort((a, b) => {
        if (a.length < b.length)
            return 1;
        if (a.length > b.length)
            return -1;
        if (a[0] < b[0])
            return -1;
        if (a[0] > b[0])
            return 1;
        return 0;
    });
}
function getUserConfigEntryTags(configBundles, allModules) {
    configBundles = (configBundles || [])
        .filter(b => b.components && b.components.length > 0)
        .sort((a, b) => {
        if (a.components.length < b.components.length)
            return 1;
        if (a.components.length > b.components.length)
            return -1;
        return 0;
    });
    const definedTags = [];
    const entryTags = configBundles
        .map(b => {
        return b.components
            .map(tag => {
            tag = validateComponentTag(tag);
            const moduleFile = allModules.find(m => m.cmpMeta && m.cmpMeta.tagNameMeta === tag);
            if (!moduleFile) {
                throw new Error(`Component tag "${tag}" is defined in a bundle but no matching component was found within this app or its collections.`);
            }
            if (definedTags.includes(tag)) {
                throw new Error(`Component tag "${tag}" has been defined multiple times in the "bundles" config.`);
            }
            definedTags.push(tag);
            return tag;
        })
            .sort();
    });
    return entryTags;
}

function generateServiceWorkerUrl(config, outputTarget) {
    let swUrl = normalizePath(config.sys.path.relative(outputTarget.dir, outputTarget.serviceWorker.swDest));
    if (swUrl.charAt(0) !== '/') {
        swUrl = '/' + swUrl;
    }
    swUrl = outputTarget.baseUrl + swUrl.substring(1);
    return swUrl;
}
function appendSwScript(indexHtml, htmlToAppend) {
    const match = indexHtml.match(BODY_CLOSE_REG);
    if (match) {
        indexHtml = indexHtml.replace(match[0], `${htmlToAppend}\n${match[0]}`);
    }
    else {
        indexHtml += '\n' + htmlToAppend;
    }
    return indexHtml;
}
const BODY_CLOSE_REG = /<\/body>/i;

var __awaiter$57 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function updateIndexHtmlServiceWorker(config, outputTarget, indexHtml) {
    return __awaiter$57(this, void 0, void 0, function* () {
        if (!outputTarget.serviceWorker && config.devMode) {
            // if we're not generating a sw, and this is a dev build
            // then let's inject a script that always unregisters any service workers
            indexHtml = injectUnregisterServiceWorker(indexHtml);
        }
        else if (outputTarget.serviceWorker) {
            // we have a valid sw config, so we'll need to inject the register sw script
            indexHtml = yield injectRegisterServiceWorker(config, outputTarget, indexHtml);
        }
        return indexHtml;
    });
}
function injectRegisterServiceWorker(config, outputTarget, indexHtml) {
    return __awaiter$57(this, void 0, void 0, function* () {
        const swUrl = generateServiceWorkerUrl(config, outputTarget);
        const serviceWorker = getRegisterSwScript(swUrl);
        const swHtml = `<script>${serviceWorker}</script>`;
        return appendSwScript(indexHtml, swHtml);
    });
}
function injectUnregisterServiceWorker(indexHtml) {
    return appendSwScript(indexHtml, UNREGSITER_SW);
}
function getRegisterSwScript(swUrl) {
    return `
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('${swUrl}')
          .then(function(reg) {
            console.log('service worker registered', reg);

            reg.onupdatefound = function() {
              var installingWorker = reg.installing;

              installingWorker.onstatechange = function() {
                if (installingWorker.state === 'installed') {
                  window.dispatchEvent(new Event('swUpdate'))
                }
              }
            }
          })
          .catch(function(err) { console.log('service worker error', err) });
      });
    }
`;
}
const UNREGSITER_SW = `
  <script>
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      // auto-unregister service worker during dev mode
      navigator.serviceWorker.getRegistration().then(function(registration) {
        if (registration) {
          registration.unregister().then(function() { location.reload(true) });
        }
      });
    }
  </script>
`;

var __awaiter$58 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateIndexHtmls(config, compilerCtx, buildCtx) {
    const indexHtmlOutputs = config.outputTargets.filter(o => o.indexHtml);
    return Promise.all(indexHtmlOutputs.map(outputTarget => {
        return generateIndexHtml(config, compilerCtx, buildCtx, outputTarget);
    }));
}
function generateIndexHtml(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$58(this, void 0, void 0, function* () {
        if (hasError(buildCtx.diagnostics)) {
            return;
        }
        if (!outputTarget.indexHtml || !config.srcIndexHtml) {
            return;
        }
        if (compilerCtx.hasSuccessfulBuild && buildCtx.appFileBuildCount === 0) {
            // no need to rebuild index.html if there were no app file changes
            return;
        }
        // get the source index html content
        try {
            let indexSrcHtml = yield compilerCtx.fs.readFile(config.srcIndexHtml);
            try {
                indexSrcHtml = yield updateIndexHtmlServiceWorker(config, outputTarget, indexSrcHtml);
                // add the prerendered html to our list of files to write
                yield compilerCtx.fs.writeFile(outputTarget.indexHtml, indexSrcHtml);
                config.logger.debug(`optimizeHtml, write: ${outputTarget.indexHtml}`);
            }
            catch (e) {
                catchError(buildCtx.diagnostics, e);
            }
        }
        catch (e) {
            // it's ok if there's no index file
            config.logger.debug(`no index html: ${config.srcIndexHtml}: ${e}`);
        }
    });
}

function bundleEntryFile(config, entryModules) {
    return {
        name: 'bundleEntryFilePlugin',
        resolveId(importee) {
            const bundle = entryModules.find(b => b.entryKey === importee);
            if (bundle) {
                return bundle.entryKey;
            }
            return null;
        },
        load(id) {
            const bundle = entryModules.find(b => b.entryKey === id);
            if (bundle) {
                return createEntryPointString(config, bundle);
            }
            return null;
        }
    };
}
function createEntryPointString(config, entryModule) {
    const path$$1 = config.sys.path;
    return entryModule.moduleFiles
        .map(moduleFile => {
        const originalClassName = moduleFile.cmpMeta.componentClass;
        const pascalCasedClassName = dashToPascalCase(moduleFile.cmpMeta.tagNameMeta);
        const filePath = normalizePath(path$$1.relative(path$$1.dirname(entryModule.entryKey), moduleFile.jsFilePath));
        return `export { ${originalClassName} as ${pascalCasedClassName} } from './${filePath}';`;
    })
        .join('\n');
}

function bundleJson(config, options = {}) {
    const path$$1 = config.sys.path;
    const filter = rollupPluginutils.createFilter(options.include, options.exclude);
    const collectionDirs = config.outputTargets.filter(o => o.collectionDir).map(o => o.collectionDir);
    const inMemoryDir = pathJoin(config, config.rootDir, IN_MEMORY_DIR);
    collectionDirs.push(inMemoryDir);
    return {
        name: 'json',
        resolveId(importee, importer) {
            if (importer && importee.endsWith('.json')) {
                const collectionDir = collectionDirs.find(cd => importer.startsWith(cd));
                if (collectionDir) {
                    return path$$1.resolve(path$$1.dirname(importer).replace(collectionDir, config.srcDir), importee);
                }
            }
            return null;
        },
        transform(json, id) {
            if (id.slice(-5) !== '.json')
                return null;
            if (!filter(id))
                return null;
            const data = JSON.parse(json);
            let code = '';
            const ast = {
                type: 'Program',
                sourceType: 'module',
                start: 0,
                end: null,
                body: []
            };
            if (Object.prototype.toString.call(data) !== '[object Object]') {
                code = `export default ${json};`;
                ast.body.push({
                    type: 'ExportDefaultDeclaration',
                    start: 0,
                    end: code.length,
                    declaration: {
                        type: 'Literal',
                        start: 15,
                        end: code.length - 1,
                        value: null,
                        raw: 'null'
                    }
                });
            }
            else {
                const indent = 'indent' in options ? options.indent : '\t';
                const validKeys = [];
                const invalidKeys = [];
                Object.keys(data).forEach(key => {
                    if (key === rollupPluginutils.makeLegalIdentifier(key)) {
                        validKeys.push(key);
                    }
                    else {
                        invalidKeys.push(key);
                    }
                });
                let char = 0;
                validKeys.forEach(key => {
                    const declarationType = options.preferConst ? 'const' : 'var';
                    const declaration = `export ${declarationType} ${key} = ${JSON.stringify(data[key])};`;
                    const start = char;
                    const end = start + declaration.length;
                    // generate fake AST node while we're here
                    ast.body.push({
                        type: 'ExportNamedDeclaration',
                        start: char,
                        end: char + declaration.length,
                        declaration: {
                            type: 'VariableDeclaration',
                            start: start + 7,
                            end,
                            declarations: [
                                {
                                    type: 'VariableDeclarator',
                                    start: start + 7 + declarationType.length + 1,
                                    end: end - 1,
                                    id: {
                                        type: 'Identifier',
                                        start: start + 7 + declarationType.length + 1,
                                        end: start + 7 + declarationType.length + 1 + key.length,
                                        name: key
                                    },
                                    init: {
                                        type: 'Literal',
                                        start: start +
                                            7 +
                                            declarationType.length +
                                            1 +
                                            key.length +
                                            3,
                                        end: end - 1,
                                        value: null,
                                        raw: 'null'
                                    }
                                }
                            ],
                            kind: declarationType
                        },
                        specifiers: [],
                        source: null
                    });
                    char = end + 1;
                    code += `${declaration}\n`;
                });
                const defaultExportNode = {
                    type: 'ExportDefaultDeclaration',
                    start: char,
                    end: null,
                    declaration: {
                        type: 'ObjectExpression',
                        start: char + 15,
                        end: null,
                        properties: []
                    }
                };
                char += 17 + indent.length; // 'export default {\n\t'.length'
                const defaultExportRows = validKeys
                    .map(key => {
                    const row = `${key}: ${key}`;
                    const start = char;
                    const end = start + row.length;
                    defaultExportNode.declaration.properties.push({
                        type: 'Property',
                        start,
                        end,
                        method: false,
                        shorthand: false,
                        computed: false,
                        key: {
                            type: 'Identifier',
                            start,
                            end: start + key.length,
                            name: key
                        },
                        value: {
                            type: 'Identifier',
                            start: start + key.length + 2,
                            end,
                            name: key
                        },
                        kind: 'init'
                    });
                    char += row.length + (2 + indent.length); // ',\n\t'.length
                    return row;
                })
                    .concat(invalidKeys.map(key => `"${key}": ${JSON.stringify(data[key])}`));
                code += `export default {\n${indent}${defaultExportRows.join(`,\n${indent}`)}\n};`;
                ast.body.push(defaultExportNode);
                const end = code.length;
                defaultExportNode.declaration.end = end - 1;
                defaultExportNode.end = end;
            }
            ast.end = code.length;
            return { ast, code, map: { mappings: '' } };
        }
    };
}

var __awaiter$59 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function localResolution(config, compilerCtx) {
    return {
        name: 'localResolution',
        resolveId(importee, importer) {
            return __awaiter$59(this, void 0, void 0, function* () {
                importee = normalizePath(importee);
                importer = normalizePath(importer);
                if (importee.indexOf('./') === -1) {
                    return null;
                }
                if (!importer) {
                    return null;
                }
                if (importee.endsWith('.js')) {
                    return null;
                }
                const basename = config.sys.path.basename(importer);
                const directory = importer.split(basename)[0];
                const dirIndexFile = config.sys.path.join(directory + importee, 'index.js');
                let stats;
                try {
                    stats = yield compilerCtx.fs.stat(dirIndexFile);
                }
                catch (e) {
                    return null;
                }
                if (stats.isFile) {
                    return dirIndexFile;
                }
                return null;
            });
        }
    };
}

function nodeEnvVars(config) {
    // replace build time expressions, like process.env.NODE_ENV === 'production'
    return {
        name: 'nodeEnvVarsPlugin',
        transform(sourceText) {
            return Promise.resolve({
                code: buildExpressionReplacer(config, sourceText)
            });
        }
    };
}

var __awaiter$60 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function pathsResolver(config, compilerCtx, testTsconfig) {
    return __awaiter$60(this, void 0, void 0, function* () {
        const tsconfig = testTsconfig || (yield getUserTsConfig(config, compilerCtx));
        const extensions = [
            'ts',
            'tsx'
        ];
        return {
            name: 'pathsResolverPlugin',
            resolveId(importee, importer) {
                importee = normalizePath(importee);
                importer = normalizePath(importer);
                if (!importer) {
                    return null;
                }
                const paths = tsconfig.paths || {};
                // Parse each rule from tsconfig
                for (const rule in paths) {
                    const normalizedRule = normalizePath(rule);
                    // The rule without the wildcard
                    const standaloneRule = normalizedRule.replace(/\*$/, '');
                    if (importee.indexOf(standaloneRule) === 0) {
                        // Get the wildcard part from importee
                        const wildcard = importee.slice(standaloneRule.length);
                        // Parse each sub-rule of a rule
                        for (const subrule of paths[rule]) {
                            const normalizedSubrule = normalizePath(subrule);
                            // Build the subrule replacing the wildcard with actual path
                            const enrichedSubrule = normalizePath(normalizedSubrule.replace(/\*$/, wildcard));
                            const finalPath = normalizePath(config.sys.path.join(config.rootDir, enrichedSubrule));
                            const moduleFiles = compilerCtx.moduleFiles;
                            for (let i = 0; i < extensions.length; i++) {
                                const moduleFile = moduleFiles[`${finalPath}.${extensions[i]}`];
                                if (moduleFile) {
                                    return moduleFile.jsFilePath;
                                }
                            }
                        }
                    }
                }
                return null;
            },
        };
    });
}

var __awaiter$61 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createBundle(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$61(this, void 0, void 0, function* () {
        const builtins = require('rollup-plugin-node-builtins');
        const globals = require('rollup-plugin-node-globals');
        let rollupBundle;
        const commonjsConfig = Object.assign({ include: 'node_modules/**', sourceMap: false }, config.commonjs);
        const nodeResolveConfig = Object.assign({ jsnext: true, main: true }, config.nodeResolve);
        const rollupConfig = {
            input: entryModules.map(b => b.entryKey),
            experimentalCodeSplitting: true,
            preserveSymlinks: false,
            experimentalDynamicImport: true,
            plugins: [
                resolveCollections(compilerCtx),
                config.sys.rollup.plugins.nodeResolve(nodeResolveConfig),
                config.sys.rollup.plugins.commonjs(commonjsConfig),
                bundleJson(config),
                globals(),
                builtins(),
                bundleEntryFile(config, entryModules),
                inMemoryFsRead(config, config.sys.path, compilerCtx),
                yield pathsResolver(config, compilerCtx),
                localResolution(config, compilerCtx),
                nodeEnvVars(config),
                ...config.plugins
            ],
            onwarn: createOnWarnFn(config, buildCtx.diagnostics)
        };
        try {
            rollupBundle = yield rollup.rollup(rollupConfig);
        }
        catch (err) {
            console.log(err);
            loadRollupDiagnostics(config, compilerCtx, buildCtx, err);
        }
        if (hasError(buildCtx.diagnostics) || !rollupBundle) {
            throw new Error('rollup died');
        }
        return rollupBundle;
    });
}
function writeEsModules(config, rollupBundle) {
    return __awaiter$61(this, void 0, void 0, function* () {
        const results = yield rollupBundle.generate({
            format: 'es',
            banner: generatePreamble(config),
            intro: `const { h } = window.${config.namespace};`,
        });
        return results;
    });
}
function writeLegacyModules(config, rollupBundle, entryModules) {
    return __awaiter$61(this, void 0, void 0, function* () {
        rollupBundle.cache.modules.forEach(module => {
            const key = module.id;
            const entryModule = entryModules.find(b => b.entryKey === `./${key}.js`);
            if (entryModule) {
                entryModule.dependencies = module.dependencies.slice();
            }
        });
        const results = yield rollupBundle.generate({
            format: 'amd',
            amd: {
                id: getBundleIdPlaceholder(),
                define: `${config.namespace}.loadBundle`
            },
            banner: generatePreamble(config),
            intro: `const h = window.${config.namespace}.h;`,
            strict: false,
        });
        return results;
    });
}
function writeEsmEs5Modules(config, rollupBundle) {
    return __awaiter$61(this, void 0, void 0, function* () {
        const results = yield rollupBundle.generate({
            format: 'es',
            banner: generatePreamble(config),
            intro: `import { h } from './${getHyperScriptFnEsmFileName(config)}';`,
            strict: false,
        });
        return results;
    });
}

var __awaiter$62 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateBundleModules(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$62(this, void 0, void 0, function* () {
        const results = {};
        try {
            // run rollup, but don't generate yet
            // returned rollup bundle can be reused for es module and legacy
            const rollupBundle = yield createBundle(config, compilerCtx, buildCtx, entryModules);
            // bundle using only es modules and dynamic imports
            results.esm = yield writeEsModules(config, rollupBundle);
            buildCtx.bundleBuildCount = Object.keys(results.esm).length;
            if (config.buildEs5) {
                // only create legacy modules when generating es5 fallbacks
                // bundle using commonjs using jsonp callback
                results.es5 = yield writeLegacyModules(config, rollupBundle, entryModules);
            }
            if (config.outputTargets.some(o => o.type === 'dist')) {
                results.esmEs5 = yield writeEsmEs5Modules(config, rollupBundle);
            }
            if (config.minifyJs) {
                yield minifyChunks(config, compilerCtx, buildCtx, results);
            }
        }
        catch (err) {
            catchError(buildCtx.diagnostics, err);
        }
        return results;
    });
}
function minifyChunks(config, compilerCtx, buildCtx, results) {
    return __awaiter$62(this, void 0, void 0, function* () {
        const promises = Object.keys(results).map((moduleType) => {
            const jsModuleList = results[moduleType];
            const promises = Object.keys(jsModuleList)
                .filter(m => !m.startsWith('entry:'))
                .map(chunkKey => jsModuleList[chunkKey])
                .map((chunk) => __awaiter$62(this, void 0, void 0, function* () {
                const sourceTarget = (moduleType === 'es5' || moduleType === 'esmEs5') ? 'es5' : 'es2017';
                const minifyJsResults = yield minifyJs(config, compilerCtx, chunk.code, sourceTarget, true);
                if (minifyJsResults.diagnostics.length) {
                    minifyJsResults.diagnostics.forEach(d => {
                        buildCtx.diagnostics.push(d);
                    });
                }
                else {
                    chunk.code = minifyJsResults.output;
                }
            }));
            return Promise.all(promises);
        });
        return Promise.all(promises);
    });
}

var __awaiter$63 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateModuleMap(config, compilerCtx, buildCtx, entryModules) {
    return __awaiter$63(this, void 0, void 0, function* () {
        const timeSpan = config.logger.createTimeSpan(`module map started`);
        let jsModules;
        try {
            jsModules = yield generateBundleModules(config, compilerCtx, buildCtx, entryModules);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`module map finished`);
        config.logger.debug(`module map finished`);
        return jsModules;
    });
}

function validateCollectinCompatibility(config, collection) {
    if (!collection.compiler) {
        // if there is no compiler data at all then this was probably
        // set on purpose and we should avoid doing any upgrading
        return [];
    }
    // fill in any default data if somehow it's missing entirely
    collection.compiler.name = collection.compiler.name || '@stencil/core';
    collection.compiler.version = collection.compiler.version || '0.0.1';
    collection.compiler.typescriptVersion = collection.compiler.typescriptVersion || '2.5.3';
    // figure out which compiler upgrades, if any, we need to do
    return calculateRequiredUpgrades(config, collection.compiler.version);
}
function calculateRequiredUpgrades(config, collectionVersion) {
    // CUSTOM CHECKS PER KNOWN BREAKING CHANGES
    // UNIT TEST UNIT TEST UNIT TEST
    const upgrades = [];
    if (config.sys.semver.lte(collectionVersion, '0.0.6-10')) {
        // 2017-10-04
        // between 0.0.5 and 0.0.6-11 we no longer have a custom JSX parser
        upgrades.push(0 /* JSX_Upgrade_From_0_0_5 */);
    }
    if (config.sys.semver.lte(collectionVersion, '0.1.0')) {
        // 2017-12-27
        // from 0.1.0 and earlier, metadata was stored separately
        // from the component constructor. Now it puts the metadata
        // as static properties on each component constructor
        upgrades.push(1 /* Metadata_Upgrade_From_0_1_0 */);
    }
    if (config.sys.semver.lte(collectionVersion, '0.2.0')) {
        // 2018-01-19
        // ensure all @stencil/core imports are removed
        upgrades.push(2 /* Remove_Stencil_Imports */);
    }
    if (config.sys.semver.lte(collectionVersion, '0.3.0')) {
        // 2018-01-30
        // add dependencies to component metadata
        upgrades.push(3 /* Add_Component_Dependencies */);
    }
    return upgrades;
}

/* tslint:disable */
function upgradeJsxProps(transformContext) {
    return (tsSourceFile) => {
        return visit(tsSourceFile);
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.CallExpression:
                    const callNode = node;
                    if (callNode.expression.text === 'h') {
                        const tag = callNode.arguments[0];
                        if (tag && typeof tag.text === 'string') {
                            node = upgradeCall(callNode);
                        }
                    }
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node);
                    }, transformContext);
            }
        }
    };
}
function upgradeCall(callNode) {
    const [tag, props, ...children] = callNode.arguments;
    let newArgs = [];
    newArgs.push(upgradeTagName(tag));
    newArgs.push(upgradeProps(props));
    if (children != null) {
        newArgs = newArgs.concat(upgradeChildren(children));
    }
    return ts.updateCall(callNode, callNode.expression, undefined, newArgs);
}
function upgradeTagName(tagName) {
    if (ts.isNumericLiteral(tagName) &&
        tagName.text === '0') {
        return ts.createLiteral('slot');
    }
    return tagName;
}
function upgradeProps(props) {
    let upgradedProps = {};
    let propHackValue;
    if (!ts.isObjectLiteralExpression(props)) {
        return ts.createNull();
    }
    const objectProps = objectLiteralToObjectMap(props);
    upgradedProps = Object.keys(objectProps).reduce((newProps, propName) => {
        const propValue = objectProps[propName];
        // If the propname is c, s, or k then map to proper name
        if (propName === 'c') {
            return Object.assign({}, newProps, { 'class': propValue });
        }
        if (propName === 's') {
            return Object.assign({}, newProps, { 'style': propValue });
        }
        if (propName === 'k') {
            return Object.assign({}, newProps, { 'key': propValue });
        }
        // If the propname is p or a then spread the value into props
        if (propName === 'a') {
            return Object.assign({}, newProps, propValue);
        }
        if (propName === 'p') {
            if (isInstanceOfObjectMap(propValue)) {
                return Object.assign({}, newProps, propValue);
            }
            else {
                propHackValue = propValue;
            }
        }
        // If the propname is o then we need to update names and then spread into props
        if (propName === 'o') {
            const eventListeners = Object.keys(propValue).reduce((newValue, eventName) => {
                return Object.assign({}, newValue, { [`on${eventName}`]: propValue[eventName] });
            }, {});
            return Object.assign({}, newProps, eventListeners);
        }
        return newProps;
    }, upgradedProps);
    try {
    }
    catch (e) {
        console.log(upgradedProps);
        console.log(objectProps);
        console.log(props);
        throw e;
    }
    const response = objectMapToObjectLiteral(upgradedProps);
    // Looks like someone used the props hack. So we need to create the following code:
    // Object.assign({}, upgradedProps, propHackValue);
    if (propHackValue) {
        const emptyObjectLiteral = ts.createObjectLiteral();
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('Object'), ts.createIdentifier('assign')), undefined, [emptyObjectLiteral, response, propHackValue]);
    }
    return response;
}
function upgradeChildren(children) {
    return children.map(upgradeChild);
}
function upgradeChild(child) {
    if (ts.isCallExpression(child) && child.expression.text === 't') {
        return child.arguments[0];
    }
    return child;
}

function upgradeFromMetadata(moduleFiles) {
    const allModuleFiles = Object.keys(moduleFiles).map(filePath => {
        return moduleFiles[filePath];
    });
    return (tsSourceFile) => {
        const tsFilePath = normalizePath(tsSourceFile.fileName);
        let moduleFile = moduleFiles[tsFilePath];
        if (!moduleFile || !moduleFile.cmpMeta) {
            moduleFile = allModuleFiles.find(m => m.jsFilePath === tsFilePath);
        }
        if (moduleFile) {
            tsSourceFile = upgradeModuleFile(tsSourceFile, moduleFile.cmpMeta);
        }
        return tsSourceFile;
    };
}
function upgradeModuleFile(tsSourceFile, cmpMeta) {
    const staticMembers = addStaticMeta(cmpMeta);
    const newStatements = Object.keys(staticMembers).map(memberName => {
        return ts.createBinary(ts.createPropertyAccess(ts.createIdentifier(cmpMeta.componentClass), memberName), ts.createToken(ts.SyntaxKind.EqualsToken), staticMembers[memberName]);
    });
    return ts.updateSourceFileNode(tsSourceFile, [
        ...tsSourceFile.statements,
        ...newStatements
    ]);
}

var __awaiter$64 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function upgradeCollection(config, compilerCtx, buildCtx, collection) {
    return __awaiter$64(this, void 0, void 0, function* () {
        try {
            const upgradeTransforms = validateCollectinCompatibility(config, collection);
            if (upgradeTransforms.length === 0) {
                return;
            }
            const timeSpan = config.logger.createTimeSpan(`upgrade ${collection.collectionName} started`, true);
            const doUpgrade = createDoUpgrade(config, compilerCtx, buildCtx);
            yield doUpgrade(collection, upgradeTransforms);
            timeSpan.finish(`upgrade ${collection.collectionName} finished`);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
function createDoUpgrade(config, compilerCtx, buildCtx) {
    return (collection, upgrades) => __awaiter$64(this, void 0, void 0, function* () {
        const upgradeTransforms = (upgrades.map((upgrade) => {
            switch (upgrade) {
                case 0 /* JSX_Upgrade_From_0_0_5 */:
                    config.logger.debug(`JSX_Upgrade_From_0_0_5, ${collection.collectionName}, compiled by v${collection.compiler.version}`);
                    return upgradeJsxProps;
                case 1 /* Metadata_Upgrade_From_0_1_0 */:
                    config.logger.debug(`Metadata_Upgrade_From_0_1_0, ${collection.collectionName}, compiled by v${collection.compiler.version}`);
                    return () => {
                        return upgradeFromMetadata(compilerCtx.moduleFiles);
                    };
                case 2 /* Remove_Stencil_Imports */:
                    config.logger.debug(`Remove_Stencil_Imports, ${collection.collectionName}, compiled by v${collection.compiler.version}`);
                    return (transformContext) => {
                        return removeStencilImports()(transformContext);
                    };
                case 3 /* Add_Component_Dependencies */:
                    config.logger.debug(`Add_Component_Dependencies, ${collection.collectionName}, compiled by v${collection.compiler.version}`);
                    return (transformContext) => {
                        return componentDependencies(compilerCtx, buildCtx)(transformContext);
                    };
            }
            return () => (tsSourceFile) => (tsSourceFile);
        }));
        yield Promise.all(collection.moduleFiles.map((moduleFile) => __awaiter$64(this, void 0, void 0, function* () {
            try {
                const source = yield compilerCtx.fs.readFile(moduleFile.jsFilePath);
                const output = yield transformSourceString(moduleFile.jsFilePath, source, upgradeTransforms);
                yield compilerCtx.fs.writeFile(moduleFile.jsFilePath, output, { inMemoryOnly: true });
            }
            catch (e) {
                const d = catchError(buildCtx.diagnostics, e);
                d.messageText = `error performing compiler upgrade on ${moduleFile.jsFilePath}: ${e}`;
            }
        })));
    });
}

var __awaiter$65 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function initCollections(config, compilerCtx, buildCtx) {
    return __awaiter$65(this, void 0, void 0, function* () {
        const uninitialized = compilerCtx.collections.filter(c => !c.isInitialized);
        return Promise.all(uninitialized.map((collection) => __awaiter$65(this, void 0, void 0, function* () {
            // Look at all dependent components from outside collections and
            // upgrade the components to be compatible with this version if need be
            yield upgradeCollection(config, compilerCtx, buildCtx, collection);
            collection.isInitialized = true;
        })));
    });
}

var __awaiter$66 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function initIndexHtmls(config, compilerCtx, buildCtx) {
    return Promise.all(config.outputTargets.map(outputTarget => {
        return initIndexHtml(config, compilerCtx, buildCtx, outputTarget);
    }));
}
function initIndexHtml(config, compilerCtx, buildCtx, outputTarget) {
    return __awaiter$66(this, void 0, void 0, function* () {
        // if there isn't an index.html yet
        // let's generate a slim one quick so that
        // on the first build the user sees a loading indicator
        // this is synchronous on purpose so that it's saved
        // before the dev server fires up and loads the index.html page
        if (outputTarget.type !== 'www') {
            // only worry about this when generating www directory
            return;
        }
        // check if there's even a src index.html file
        const hasSrcIndexHtml = yield compilerCtx.fs.access(config.srcIndexHtml);
        if (!hasSrcIndexHtml) {
            // there is no src index.html file in the config, which is fine
            // since there is no src index file at all, don't bother
            // this isn't actually an error, don't worry about it
            return;
        }
        if (compilerCtx.hasSuccessfulBuild) {
            // we've already had a successful build, we're good
            // always recopy index.html (it's all cached if it didn't actually change, all good)
            const srcIndexHtmlContent = yield compilerCtx.fs.readFile(config.srcIndexHtml);
            yield compilerCtx.fs.writeFile(outputTarget.indexHtml, srcIndexHtmlContent);
            return;
        }
        try {
            // ok, so we haven't written an index.html build file yet
            // and we do know they have a src one, so let's write a
            // filler index.html file that shows while the first build is happening
            yield compilerCtx.fs.writeFile(outputTarget.indexHtml, APP_LOADING_HTML);
            yield compilerCtx.fs.commit();
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
const APP_LOADING_HTML = `
<!DOCTYPE html>
<html dir="ltr" lang="en" data-init="app-dev-first-build-loader">
<head>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then(function(registration) {
        registration.unregister();
      });
    }
  </script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="x-ua-compatible" content="IE=Edge">
  <title>Initializing First Build...</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      position: absolute;
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    .toast {
      position: absolute;
      top: 10px;
      right: 10px;
      left: 10px;
      margin: auto;
      max-width: 700px;
      border-radius: 3px;
      background: rgba(0,0,0,.9);
      -webkit-transform: translate3d(0px, -60px, 0px);
      transform: translate3d(0px, -60px, 0px);
      -webkit-transition: -webkit-transform 75ms ease-out;
      transition: transform 75ms ease-out;
      pointer-events: none;
    }

    .active {
      -webkit-transform: translate3d(0px, 0px, 0px);
      transform: translate3d(0px, 0px, 0px);
    }

    .content {
      display: flex;
      -webkit-align-items: center;
      -ms-flex-align: center;
      align-items: center;
      pointer-events: auto;
    }

    .message {
      -webkit-flex: 1;
      -ms-flex: 1;
      flex: 1;
      padding: 15px;
      font-size: 14px;
      color: #fff;
    }

    .spinner {
      position: relative;
      display: inline-block;
      width: 56px;
      height: 28px;
    }

    svg:not(:root) {
      overflow: hidden;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation: rotate 600ms linear infinite;
      animation: rotate 600ms linear infinite;
    }

    @-webkit-keyframes rotate {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    @keyframes rotate {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    svg circle {
      fill: transparent;
      stroke: white;
      stroke-width: 4px;
      stroke-dasharray: 128px;
      stroke-dashoffset: 82px;
    }
  </style>
</head>
<body>

  <div class="toast">
    <div class="content">
      <div class="message">Initializing First Build...</div>
      <div class="spinner">
        <svg viewBox="0 0 64 64"><circle transform="translate(32,32)" r="26"></circle></svg>
      </div>
    </div>
  </div>

  <script>
    setTimeout(function() {
      document.querySelector('.toast').classList.add('active');
    }, 100);

    setInterval(function() {
      try {
        var xhr = new XMLHttpRequest();
        xhr.addEventListener('load', function() {
          try {
            if (this.responseText.indexOf('app-dev-first-build-loader') === -1) {
              window.location.reload(true);
            }
          } catch (e) {
            console.error(e);
          }
        });
        var url = window.location.pathname + '?' + Math.random();
        xhr.open('GET', url);
        xhr.send();
      } catch (e) {
        console.error(e);
      }
    }, 1000);
  </script>

</body>
</html>
`;

var __awaiter$67 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function copyComponentAssets(config, compilerCtx, buildCtx) {
    return __awaiter$67(this, void 0, void 0, function* () {
        if (canSkipAssetsCopy(config, compilerCtx, buildCtx)) {
            // no need to recopy all assets again
            return;
        }
        const outputTargets = config.outputTargets.filter(outputTarget => {
            return outputTarget.appBuild;
        });
        config.logger.debug(`copy assets`);
        try {
            // get a list of all the directories to copy
            // these paths should be absolute
            const copyToBuildDir = [];
            const copyToCollectionDir = [];
            const copyTasks = [];
            buildCtx.entryModules.forEach(entryModule => {
                const moduleFiles = entryModule.moduleFiles.filter(m => {
                    return m.cmpMeta.assetsDirsMeta && m.cmpMeta.assetsDirsMeta.length;
                });
                moduleFiles.forEach(moduleFile => {
                    moduleFile.cmpMeta.assetsDirsMeta.forEach(assetsMeta => {
                        copyToBuildDir.push(assetsMeta);
                        if (!moduleFile.excludeFromCollection && !moduleFile.isCollectionDependency) {
                            copyToCollectionDir.push(assetsMeta);
                        }
                    });
                });
            });
            // copy all of the files in asset directories to the app's build and/or dist directory
            copyToBuildDir.forEach(assetsMeta => {
                // figure out what the path is to the component directory
                outputTargets.forEach(outputTarget => {
                    const buildDirDestination = pathJoin(config, getAppBuildDir(config, outputTarget), assetsMeta.cmpRelativePath);
                    copyTasks.push({
                        src: assetsMeta.absolutePath,
                        dest: buildDirDestination
                    });
                });
            });
            outputTargets.forEach(outputTarget => {
                if (outputTarget.collectionDir) {
                    // copy all of the files in asset directories to the app's collection directory
                    copyToCollectionDir.forEach(assetsMeta => {
                        // figure out what the path is to the component directory
                        const collectionDirDestination = pathJoin(config, outputTarget.collectionDir, config.sys.path.relative(config.srcDir, assetsMeta.absolutePath));
                        copyTasks.push({
                            src: assetsMeta.absolutePath,
                            dest: collectionDirDestination
                        });
                    });
                }
            });
            // queue up all the asset copy tasks
            yield Promise.all(copyTasks.map(copyTask => {
                return compilerCtx.fs.copy(copyTask.src, copyTask.dest);
            }));
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
    });
}
function canSkipAssetsCopy(config, compilerCtx, buildCtx) {
    if (!compilerCtx.hasSuccessfulBuild) {
        // always copy assets if we haven't had a successful build yet
        // cannot skip build
        return false;
    }
    // assume we want to skip copying assets again
    let shouldSkipAssetsCopy = true;
    // loop through each of the changed files
    buildCtx.filesChanged.forEach(changedFile => {
        // get the directory of where the changed file is in
        const changedFileDirPath = normalizePath(config.sys.path.dirname(changedFile));
        // loop through all the possible asset directories
        buildCtx.entryModules.forEach(entryModule => {
            entryModule.moduleFiles.forEach(moduleFile => {
                if (moduleFile.cmpMeta && moduleFile.cmpMeta.assetsDirsMeta) {
                    // loop through each of the asset directories of each component
                    moduleFile.cmpMeta.assetsDirsMeta.forEach(assetsDir => {
                        // get the absolute of the asset directory
                        const assetDirPath = normalizePath(assetsDir.absolutePath);
                        // if the changed file directory is this asset directory
                        // then we should recopy everything over again
                        if (changedFileDirPath === assetDirPath) {
                            shouldSkipAssetsCopy = false;
                            return;
                        }
                    });
                }
            });
        });
    });
    return shouldSkipAssetsCopy;
}

var __awaiter$68 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function writeBuildFiles(config, compilerCtx, buildCtx) {
    return __awaiter$68(this, void 0, void 0, function* () {
        // serialize and write the manifest file if need be
        yield writeAppCollections(config, compilerCtx, buildCtx);
        const timeSpan = config.logger.createTimeSpan(`writeBuildFiles started`, true);
        // kick off copying component assets
        // and copy www/build to dist/ if generateDistribution is enabled
        yield Promise.all([
            copyComponentAssets(config, compilerCtx, buildCtx),
            generateDistributions(config, compilerCtx, buildCtx)
        ]);
        let totalFilesWrote = 0;
        try {
            // commit all the writeFiles, mkdirs, rmdirs and unlinks to disk
            const commitResults = yield compilerCtx.fs.commit();
            // get the results from the write to disk commit
            buildCtx.filesWritten = commitResults.filesWritten;
            buildCtx.filesDeleted = commitResults.filesDeleted;
            buildCtx.dirsDeleted = commitResults.dirsDeleted;
            buildCtx.dirsAdded = commitResults.dirsAdded;
            totalFilesWrote = commitResults.filesWritten.length;
            // successful write
            // kick off writing the cached file stuff
            // no need to wait on it finishing
            compilerCtx.cache.commit();
            config.logger.debug(`in-memory-fs: ${compilerCtx.fs.getMemoryStats()}`);
            config.logger.debug(`cache: ${compilerCtx.cache.getMemoryStats()}`);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`writeBuildFiles finished, files wrote: ${totalFilesWrote}`);
    });
}

var __awaiter$69 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * DEPRECATED "config.collections" since 0.6.0, 2018-02-13
 */
function _deprecatedConfigCollections(config, compilerCtx, buildCtx) {
    return __awaiter$69(this, void 0, void 0, function* () {
        const timeSpan = config.logger.createTimeSpan(`load collections started`, true);
        try {
            buildCtx.collections = yield loadConfigCollections(config, compilerCtx, buildCtx);
        }
        catch (e) {
            catchError(buildCtx.diagnostics, e);
        }
        timeSpan.finish(`load collections finished`);
    });
}
function loadConfigCollections(config, compilerCtx, buildCtx) {
    // load up all of the collections which this app is dependent on
    return Promise.all(config._deprecatedCollections.map(configCollection => {
        return loadConfigCollection(config, compilerCtx, buildCtx, configCollection);
    }));
}
function loadConfigCollection(config, compilerCtx, buildCtx, configCollection) {
    return __awaiter$69(this, void 0, void 0, function* () {
        let collection = compilerCtx.collections.find(c => c.collectionName === configCollection.name);
        if (collection) {
            // we've already cached the collection, no need for another resolve/readFile/parse
            return collection;
        }
        // figure out the path to the dependent collection's package.json
        const collectionJsonFilePath = config.sys.resolveModule(config.rootDir, configCollection.name);
        // parse the dependent collection's package.json
        const packageJsonStr = yield compilerCtx.fs.readFile(collectionJsonFilePath);
        const packageData = JSON.parse(packageJsonStr);
        // verify this package has a "collection" property in its package.json
        if (!packageData.collection) {
            throw new Error(`stencil collection "${configCollection.name}" is missing the "collection" key from its package.json: ${collectionJsonFilePath}`);
        }
        // get the root directory of the dependency
        const collectionPackageRootDir = config.sys.path.dirname(collectionJsonFilePath);
        // figure out the full path to the collection collection file
        const collectionFilePath = pathJoin(config, collectionPackageRootDir, packageData.collection);
        config.logger.debug(`load colleciton: ${collectionFilePath}`);
        // we haven't cached the collection yet, let's read this file
        const collectionJsonStr = yield compilerCtx.fs.readFile(collectionFilePath);
        // get the directory where the collection collection file is sitting
        const collectionDir = normalizePath(config.sys.path.dirname(collectionFilePath));
        // parse the json string into our collection data
        collection = parseCollectionData(config, configCollection.name, collectionDir, collectionJsonStr);
        // append any collection data
        collection.moduleFiles.forEach(collectionModuleFile => {
            if (!compilerCtx.moduleFiles[collectionModuleFile.jsFilePath]) {
                compilerCtx.moduleFiles[collectionModuleFile.jsFilePath] = collectionModuleFile;
            }
        });
        // Look at all dependent components from outside collections and
        // upgrade the components to be compatible with this version if need be
        yield upgradeCollection(config, compilerCtx, buildCtx, collection);
        // cache it for later yo
        compilerCtx.collections.push(collection);
        // so let's recap: we've read the file, parsed it apart, and cached it, congrats
        return collection;
    });
}

var __awaiter$70 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function build(config, compilerCtx, watcher) {
    return __awaiter$70(this, void 0, void 0, function* () {
        // create the build context if it doesn't exist
        // the buid context is the same object used for all builds and rebuilds
        // ctx is where stuff is cached for fast in-memory lookups later
        compilerCtx = getCompilerCtx(config, compilerCtx);
        // reset the build context, this is important for rebuilds
        const buildCtx = getBuildContext(config, compilerCtx, watcher);
        try {
            // create an initial index.html file if one doesn't already exist
            // this is synchronous on purpose
            yield initIndexHtmls(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // empty the directories on the first build
            yield emptyOutputTargetDirs(config, compilerCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // DEPRECATED config.colllections 2018-02-13
            yield _deprecatedConfigCollections(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // async scan the src directory for ts files
            // then transpile them all in one go
            yield transpileAppModules(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // initialize all the collections we found when transpiling
            // async copy collection files and upgrade collections as needed
            yield initCollections(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // we've got the compiler context filled with app modules and collection dependency modules
            // figure out how all these components should be connected
            const entryModules = generateEntryModules(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // bundle modules and styles into separate files phase
            const jsModules = yield generateModuleMap(config, compilerCtx, buildCtx, entryModules);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // create each of the components's styles
            yield generateStyles(config, compilerCtx, buildCtx, entryModules);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // both styles and modules are done bundling
            // inject the styles into the modules and
            // generate each of the output bundles
            const cmpRegistry = yield generateBundles(config, compilerCtx, buildCtx, entryModules, jsModules);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // generate the app files, such as app.js, app.core.js
            yield generateAppFiles(config, compilerCtx, buildCtx, entryModules, cmpRegistry);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // copy all assets
            if (!compilerCtx.hasSuccessfulBuild) {
                // only do the initial copy on the first build
                // watcher handles any re-copies
                yield copyTasks(config, compilerCtx, buildCtx.diagnostics, false);
                if (buildCtx.shouldAbort())
                    return buildCtx.finish();
            }
            // build index file and service worker
            yield generateIndexHtmls(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            // write all the files and copy asset files
            yield writeBuildFiles(config, compilerCtx, buildCtx);
            if (buildCtx.shouldAbort())
                return buildCtx.finish();
            yield buildAuxiliaries(config, compilerCtx, buildCtx, entryModules);
        }
        catch (e) {
            // ¯\_(ツ)_/¯
            catchError(buildCtx.diagnostics, e);
        }
        // return what we've learned today
        return buildCtx.finish();
    });
}

class Compiler {
    constructor(rawConfig) {
        [this.isValid, this.config] = isValid(rawConfig);
        if (this.isValid) {
            this.ctx = getCompilerCtx(this.config);
            let startupMsg = `${this.config.sys.compiler.name} v${this.config.sys.compiler.version} `;
            if (this.config.sys.platform !== 'win32') {
                startupMsg += `🍁`;
            }
            this.config.logger.info(this.config.logger.cyan(startupMsg));
            this.config.logger.debug(`compiler runtime: ${this.config.sys.compiler.runtime}`);
        }
    }
    build() {
        return build(this.config, this.ctx);
    }
    on(eventName, cb) {
        return this.ctx.events.subscribe(eventName, cb);
    }
    once(eventName) {
        return new Promise(resolve => {
            const off = this.ctx.events.subscribe(eventName, (...args) => {
                off();
                resolve.apply(this, args);
            });
        });
    }
    off(eventName, cb) {
        this.ctx.events.unsubscribe(eventName, cb);
    }
    trigger(eventName, ...args) {
        args.unshift(eventName);
        this.ctx.events.emit.apply(this.ctx.events, args);
    }
    docs() {
        return docs(this.config, this.ctx);
    }
    get fs() {
        return this.ctx.fs;
    }
    get name() {
        return this.config.sys.compiler.name;
    }
    get version() {
        return this.config.sys.compiler.version;
    }
}
function isValid(config) {
    try {
        // validate the build config
        validateConfig(config, true);
        return [true, config];
    }
    catch (e) {
        if (config.logger) {
            const diagnostics = [];
            catchError(diagnostics, e);
            config.logger.printDiagnostics(diagnostics);
        }
        else {
            console.error(e);
        }
        return [false, null];
    }
}

exports.Compiler = Compiler;
